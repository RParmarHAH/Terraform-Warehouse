resource "snowflake_view" "DW_REPORT_VW_DAYFALL_CALC_WIP" {
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "REPORT"
	name = "VW_DAYFALL_CALC_WIP"
	statement = <<-SQL
	 WITH PAYROLLPERIODS
AS
(
SELECT OFFICE_STATE_CODE AS STATE,CAST(MAX(PERIOD_END_DATE) AS DATE) as PERIODEND
FROM DW_${var.SF_ENVIRONMENT}.HAH.FACT_BRANCH_PAYROLL_PERIODS o       
WHERE CHECK_DATE < Current_Date() -- This should be CheckDate NOT PeriodEnd, it takes a while for all the timesheets to be entered
group by OFFICE_STATE_CODE
) /* SELECT * FROM PAYROLLPERIODS; */
,
-- pulls all dates with their various attributes needed later on
DIMDATE
AS
(
  select CALENDAR_DATE,FIRST_DAY_OF_MONTH,
  DATEDIFF(day,FIRST_DAY_OF_MONTH,LAST_DAY_OF_MONTH) + 1 AS MONTHDAYS,
  CASE WHEN DATEDIFF(MONTH,CALENDAR_DATE,PERIODEND) = 0 THEN 
  DATEDIFF(day,FIRST_DAY_OF_MONTH,PERIODEND) + 1 ELSE 
  DATEDIFF(day,FIRST_DAY_OF_MONTH,LAST_DAY_OF_MONTH) + 1 END TOTALDAYSOFMONTHSOFAR,
  CASE WHEN DATEDIFF(MONTH,CALENDAR_DATE,PERIODEND) = 0 THEN 
  PERIODEND ELSE LAST_DAY_OF_MONTH END PERIOD_END_DATE,
  STATE,PERIODEND,HAH_CURRENT_WEEK_LAST_DAY
  FROM
  DW_${var.SF_ENVIRONMENT}.hah.dim_date
  cross join 
  (select state,PERIODEND from PAYROLLPERIODS) PAYROLLPERIODS
  where CALENDAR_DATE >= '2017-12-01' and CALENDAR_DATE <= PERIODEND -- need to go back to Dec. 2017 because we calculate holiday dayfall on 12 mos
) --SELECT * FROM DIMDATE;
,Actual_hour_1
AS
(
select SERVICE_DATE,NULL AS TYPE,CONTRACT.REVENUE_CATEGORY,
    --COMBINING WARRINGTON & PHILADELPHIA
    CASE WHEN VISIT.BRANCH_KEY = 'd9833aeae3e12be4707fa3a06454704a' THEN 
  '0010d523d5db5f536745453dc9f21c60' ELSE VISIT.BRANCH_KEY END AS BRANCH_KEY,
  	--CASE WHEN VISIT.SYSTEM_CODE = '8485' THEN 'PA' ELSE VISIT.SYSTEM_CODE END AS STATE,
  	BRANCH.OFFICE_STATE_CODE AS STATE,
    SUM(HOURS_SERVED) AS HOURS,
    SUM(HOURS_SERVED * BILL_RATE) + COALESCE(SUM(OVERHEAD_RATE),0) As REVENUE 
    from DW_${var.SF_ENVIRONMENT}.HAH.FACT_VISIT VISIT 
    inner join 
    (SELECT CONTRACT_KEY, NULL AS SCHEDULE_TYPE,
     CONTRACT_CODE,contract_name,
     CASE WHEN SOURCE_SYSTEM_ID = 4 THEN 'HC' ELSE REVENUE_CATEGORY END AS REVENUE_CATEGORY,
     CASE WHEN SOURCE_SYSTEM_ID = 4 THEN TRUE ELSE BILLABLE_FLAG END AS BILLABLE_FLAG,
     CASE WHEN CONTRACT_STATE_CODE = 'AL' AND  CONTRACT_CODE = 'Z2' THEN TRUE
          WHEN CONTRACT_STATE_CODE = 'MO' AND CONTRACT_CODE = 'MI' THEN TRUE 
          WHEN SOURCE_SYSTEM_ID = 4 THEN FALSE 
          ELSE MILEAGE_FLAG END AS MILEAGE_FLAG
     FROM DW_${var.SF_ENVIRONMENT}.HAH.DIM_CONTRACT) CONTRACT 
    	ON CONTRACT.CONTRACT_KEY = VISIT.CONTRACT_KEY
    	AND BILLABLE_FLAG = TRUE and NVL(MILEAGE_FLAG,FALSE) = FALSE
    	AND CONTRACT.CONTRACT_KEY NOT IN 
    (
      select distinct contract_KEY from DW_${var.SF_ENVIRONMENT}.hah.dim_contract where upper(contract_name) like '%DCFS%' or 
      upper(contract_name) like '%DRUG%' or upper(contract_name) like '%TRANSPORT%'
     )
    INNER JOIN 
    (
      select DISTINCT SOURCE_SYSTEM_ID,BRANCH_KEY,DETAILED_OFFICE_NAME,OFFICE_STATE_CODE,
       CASE WHEN SYSTEM_CODE = '8485' THEN 'PA' ELSE SYSTEM_CODE END as SYSTEM_CODE,OFFICE_NUMBER 
       FROM DW_${var.SF_ENVIRONMENT}.HAH.DIM_BRANCH
    )BRANCH
    	ON BRANCH.BRANCH_KEY = VISIT.BRANCH_KEY
    INNER JOIN PAYROLLPERIODS
    	ON SERVICE_DATE >= '2017-12-01' AND SERVICE_DATE <= PayrollPeriods.PeriodEnd -- this should be the end of the period not CURRENT_DATE() 
    		AND PAYROLLPERIODS.STATE = BRANCH.OFFICE_STATE_CODE
    WHERE  NVL(VISIT.CONFIRMED_FLAG,'YES') ='YES' -- NVL(VISIT.STATUS_CODE, '02') IN ('02', '03', '04', '05') 
    AND  visit.SOURCE_SYSTEM_ID NOT IN (4,7,17,13,9,3,8,19,1,2,16)
    GROUP BY SERVICE_DATE,CONTRACT.REVENUE_CATEGORY, CASE WHEN VISIT.BRANCH_KEY = 'd9833aeae3e12be4707fa3a06454704a' THEN 
  		'0010d523d5db5f536745453dc9f21c60' ELSE VISIT.BRANCH_KEY END, BRANCH.OFFICE_STATE_CODE
  ) --SELECT * FROM  Actual_hour_1;
,Actual_hour_2
AS
(
select SERVICE_DATE,PCS.SCHEDULE_TYPE AS TYPE,PCS.REVENUE_CATEGORY,
    --COMBINING WARRINGTON & PHILADELPHIA
    CASE WHEN VISIT.BRANCH_KEY = 'd9833aeae3e12be4707fa3a06454704a' THEN 
  '0010d523d5db5f536745453dc9f21c60' ELSE VISIT.BRANCH_KEY END AS BRANCH_KEY,
  	--CASE WHEN VISIT.SYSTEM_CODE = '8485' THEN 'PA' ELSE VISIT.SYSTEM_CODE END AS STATE,
  	BRANCH.OFFICE_STATE_CODE AS STATE,
    SUM(HOURS_SERVED) AS HOURS,
    SUM(HOURS_SERVED * BILL_RATE) + COALESCE(SUM(OVERHEAD_RATE),0) As REVENUE 
    from DW_${var.SF_ENVIRONMENT}.HAH.FACT_VISIT VISIT
    INNER JOIN  
    (SELECT PARTNER_CONTRACT_SERVICE_KEY,PRNTER_CNTCT.SCHEDULE_TYPE,
     CONTRACT_CODE,contract_name,
     CASE WHEN PRNTER_CNTCT.SOURCE_SYSTEM_ID = 4 THEN 'HC' ELSE DIM_SERV.REVENUE_CATEGORY END AS REVENUE_CATEGORY,
     CASE WHEN PRNTER_CNTCT.SOURCE_SYSTEM_ID = 4 THEN TRUE ELSE PRNTER_CNTCT.BILLABLE_FLAG END AS BILLABLE_FLAG,
     CASE WHEN PRNTER_CNTCT.SYSTEM_CODE  = 'AL' AND  PARTNER_CODE = 'Z2' THEN TRUE
          WHEN PRNTER_CNTCT.SYSTEM_CODE  = 'MO' AND PARTNER_CODE = 'MI' THEN TRUE
          WHEN PRNTER_CNTCT.SOURCE_SYSTEM_ID = 4 THEN FALSE
          ELSE PRNTER_CNTCT.MILEAGE_FLAG END AS MILEAGE_FLAG
     FROM DW_${var.SF_ENVIRONMENT}.HAH.FACT_PARTNER_CONTRACT_SERVICE PRNTER_CNTCT 
     LEFT JOIN DW_${var.SF_ENVIRONMENT}.HAH.DIM_SERVICES  DIM_SERV ON PRNTER_CNTCT.SERVICE_KEY = DIM_SERV.SERVICE_KEY)PCS
     ON PCS.PARTNER_CONTRACT_SERVICE_KEY = VISIT.PARTNER_CONTRACT_SERVICE_KEY 
    	AND BILLABLE_FLAG = TRUE and NVL(MILEAGE_FLAG,FALSE) = FALSE
    	AND PCS.PARTNER_CONTRACT_SERVICE_KEY NOT IN 
    (
      SELECT DISTINCT  PARTNER_CONTRACT_SERVICE_KEY  FROM  DW_${var.SF_ENVIRONMENT}.HAH.FACT_PARTNER_CONTRACT_SERVICE
      WHERE  upper(contract_name) like '%DCFS%' OR upper(contract_name) like '%DRUG%' or upper(contract_name) 
      like '%TRANSPORT%'
    )
    INNER JOIN 
    (
      select DISTINCT SOURCE_SYSTEM_ID,BRANCH_KEY,DETAILED_OFFICE_NAME,OFFICE_STATE_CODE,
       CASE WHEN SYSTEM_CODE = '8485' THEN 'PA' ELSE SYSTEM_CODE END as SYSTEM_CODE,OFFICE_NUMBER 
        from DW_${var.SF_ENVIRONMENT}.HAH.DIM_BRANCH
    )BRANCH
    	ON BRANCH.BRANCH_KEY = VISIT.BRANCH_KEY
    INNER JOIN PAYROLLPERIODS
    	ON SERVICE_DATE >= '2017-12-01' AND SERVICE_DATE <= PayrollPeriods.PeriodEnd -- this should be the end of the period not CURRENT_DATE() 
    		AND PAYROLLPERIODS.STATE = BRANCH.OFFICE_STATE_CODE
    WHERE  NVL(VISIT.CONFIRMED_FLAG,'YES') ='YES' -- NVL(VISIT.STATUS_CODE, '02') IN ('02', '03', '04', '05') 
    AND VISIT.SOURCE_SYSTEM_ID IN (4,7,17,13,9,3,8,19,1,2,16)
    GROUP BY SERVICE_DATE,PCS.REVENUE_CATEGORY,PCS.SCHEDULE_TYPE, CASE WHEN VISIT.BRANCH_KEY = 'd9833aeae3e12be4707fa3a06454704a' THEN 
  		'0010d523d5db5f536745453dc9f21c60' ELSE VISIT.BRANCH_KEY END, BRANCH.OFFICE_STATE_CODE --VISIT.SYSTEM_CODE
) 
,ACTUALHOURS_DAY
AS 
(
SELECT * FROM Actual_hour_1
UNION 
SELECT * FROM Actual_hour_2
) 
--SELECT * FROM ACTUALHOURS_DAY;--662,632
-- sets up day types for various dayfall comparisons; holiday vs. weekday, weekend day vs. weekday
,DAY_TYPE
AS
(
SELECT CALENDAR_DATE
	,CASE WHEN ((MONTH = 1 AND DAY_OF_MONTH = 1)										-- New Year's Day
			OR (MONTH = 7 AND DAY_OF_MONTH = 4)											-- 4th of July
			OR (MONTH = 12 AND DAY_OF_MONTH = 25)										-- Christmas
			OR (MONTH = 1 AND Day_Name = 'Mon' AND Day_of_Month BETWEEN 15 AND 21)		-- Martin Luther King Jr Day
			OR (MONTH = 5 AND Day_Name = 'Mon' AND Day_of_Month BETWEEN 25 AND 31)		-- Memorial Day
			OR (MONTH = 9 AND Day_Name = 'Mon' AND Day_of_Month BETWEEN 1 AND 7)		-- Labor Day
			OR (MONTH = 11 AND Day_Name = 'Thu' AND Day_of_Month BETWEEN 22 AND 28)		-- Thanksgiving Day
			) THEN 'Holiday'
		WHEN DAY_NAME IN ('Sat','Sun') THEN DAY_NAME	-- we treat the weekend days individually
		ELSE 'Weekday' END AS DAY_TYPE					-- everything that's not a holiday or weekend day is logically a weekday
FROM HAH.DIM_DATE dd
) --SELECT * FROM DAY_TYPE ORDER BY 1,2
,
-- count of day_type in each month, informs dayfall calculation
MONTHCOUNT
AS
(
SELECT p.*
FROM
	(
	 SELECT DATE_TRUNC( 'MONTH',CALENDAR_DATE) AS MONTH, DAY_TYPE, COUNT( CALENDAR_DATE) AS DAYTYPE_COUNT
	 FROM DAY_TYPE
	 WHERE CALENDAR_DATE BETWEEN '2017-12-01' AND DATEADD(DAY,-1,ADD_MONTHS( (SELECT MAX( CAST( DATE_TRUNC(MONTH,CALENDAR_DATE) AS DATE)) FROM HAH.FACT_BUDGET),1))
	 GROUP BY DATE_TRUNC( 'MONTH',CALENDAR_DATE), DAY_TYPE
	) x
PIVOT( AVG( DAYTYPE_COUNT) FOR DAY_TYPE IN ('Weekday','Sat','Sun','Holiday')) AS p -- pivot brings each day type into a column with its own values
) -- SELECT * FROM MONTHCOUNT WHERE MONTH IN ('2020-10-01','2020-11-01','2020-12-01') ORDER BY 1 DESC;
,
-- weekend day hour totals for comparison with weekday totals of same timeframe
DAYFALL_WEEKEND
AS
(
SELECT *
FROM (
 SELECT ahd.STATE
	,ahd.REVENUE_CATEGORY
	,AHD.TYPE
	,mc.MONTH
	,dt.DAY_TYPE
--	,ahd.HOURS
--	,ahd.SERVICE_DATE
--	,SUM( ahd.HOURS) AS SUM_HOURS
--	,COUNT(*)
	,AVG( ahd.HOURS) AS HOURS
 FROM MONTHCOUNT mc
 INNER JOIN (SELECT SERVICE_DATE, TYPE,REVENUE_CATEGORY, STATE, SUM( HOURS) AS HOURS, SUM( REVENUE) AS REVENUE
 			 FROM ACTUALHOURS_DAY
 			 GROUP BY 1,2,3,4
 			) ahd
	 ON DATE_TRUNC(MONTH,ahd.SERVICE_DATE) BETWEEN ADD_MONTHS(mc.MONTH,-4) AND ADD_MONTHS(mc.MONTH,-2) -- 3-month rolling average
 INNER JOIN DAY_TYPE dt
 	ON ahd.SERVICE_DATE = dt.CALENDAR_DATE
 WHERE dt.DAY_TYPE <> 'Holiday'
 	AND mc.MONTH <= DATE_TRUNC( MONTH,Current_Date())
 GROUP BY 1,2,3,4,5
 ORDER BY 1,2,3,4,5
)--) SELECT * FROM DAYFALL_WEEKEND WHERE STATE = 'GA' AND "MONTH" = '2021-01-01' ORDER BY 1,2,3,4;
AS x
PIVOT( AVG( HOURS) FOR DAY_TYPE IN ('Sat','Sun','Weekday')) AS p -- pivot brings each day type into a column with its own values
) -- SELECT * FROM DAYFALL_WEEKEND WHERE STATE = 'GA' AND "MONTH" = '2021-01-01' ORDER BY 1,2,3,4;
,
-- holiday hour totals for comparison with weekday totals of same timeframe
DAYFALL_HOLIDAY
AS
(
SELECT *
FROM (
 SELECT ahd.STATE
	,ahd.REVENUE_CATEGORY
	,AHD.TYPE
	,mc.MONTH
	,dt.DAY_TYPE
	,AVG( ahd.HOURS) AS HOURS
 FROM MONTHCOUNT mc
 INNER JOIN (SELECT SERVICE_DATE,TYPE, REVENUE_CATEGORY, STATE, SUM( HOURS) AS HOURS, SUM( REVENUE) AS REVENUE
 			 FROM ACTUALHOURS_DAY
 			 GROUP BY 1,2,3,4
 			) ahd
 ON DATE_TRUNC(MONTH,ahd.SERVICE_DATE) BETWEEN ADD_MONTHS(mc.MONTH,-13) AND ADD_MONTHS(mc.MONTH,-2) -- 12-month rolling average
 INNER JOIN DAY_TYPE dt
 ON ahd.SERVICE_DATE = dt.CALENDAR_DATE
 WHERE dt.DAY_TYPE NOT IN ('Sat','Sun')
 	AND mc.MONTH <= DATE_TRUNC(MONTH,Current_Date())
 GROUP BY 1,2,3,4,5
 ORDER BY 1,2,3,4,5
) AS x
PIVOT( AVG( HOURS) FOR DAY_TYPE IN ('Holiday','Weekday')) AS p -- pivot brings each day type into a column with its own values
) --SELECT * FROM DAYFALL_HOLIDAY WHERE STATE = 'MO' AND MONTH = '2021-01-01' ORDER BY 1,2,3;
,
-- calculates what percent of the accompanying weekday value each day type is
DAYFALL_PERCENT_OFWEEKDAY
AS
(
SELECT dw.STATE
	,dw.REVENUE_CATEGORY
	,DW.TYPE
	,dw.MONTH
	,CASE WHEN dw."'Weekday'" = 0 THEN 0 ELSE IFNULL(IFNULL(dw."'Sat'",dw."'Sun'"),dh."'Holiday'")/dw."'Weekday'" END AS PERCENT_SATURDAY
	,CASE WHEN dw."'Weekday'" = 0 THEN 0 ELSE IFNULL(IFNULL(dw."'Sun'",dw."'Sat'"),dh."'Holiday'")/dw."'Weekday'" END AS PERCENT_SUNDAY
	,CASE WHEN dw."'Weekday'" = 0 THEN 0 ELSE IFNULL(IFNULL(dh."'Holiday'",dw."'Sun'"),dw."'Sat'")/dh."'Weekday'" END AS PERCENT_HOLIDAY
FROM DAYFALL_WEEKEND dw -- weekend days and weekdays based on 3-month rolling average
INNER JOIN DAYFALL_HOLIDAY dh -- holidays and weekdays based on 12-month rolling average
ON dw.STATE = dh.STATE
	AND dw.REVENUE_CATEGORY = dh.REVENUE_CATEGORY
	AND dw.MONTH = dh.MONTH
	AND DW.TYPE = DH.TYPE
WHERE dw.REVENUE_CATEGORY IN ('HH','HC', 'OTHER')
	AND dw.MONTH >= '2020-01-01'
) --SELECT * FROM DAYFALL_PERCENT_OFWEEKDAY ORDER BY 1,2,3
,
-- calc dayfall at month, revenue category, branch, and state level
DAYFALL_BYMONTH
AS
(
SELECT --b.SOURCE_SYSTEM_ID,
	wd.STATE
	,wd.REVENUE_CATEGORY
	,wd.type
--	,b.OFFICE_NUMBER
--	,b.BRANCH_KEY
	,wd.MONTH
	,wd.PERCENT_SATURDAY
	,wd.PERCENT_SUNDAY
	,wd.PERCENT_HOLIDAY
FROM DAYFALL_PERCENT_OFWEEKDAY wd
INNER JOIN MONTHCOUNT mc
ON wd.MONTH = mc.MONTH
) -- SELECT * FROM DAYFALL_BYMONTH ORDER BY 1,2,3,4;
,
-- applies dayfall amount for each day and what the month dayfall amount should be for that day within the month
DAYFALL_BYDAY
AS
(
SELECT --dm.SOURCE_SYSTEM_ID,
	dm.STATE,dm.TYPE, dm.REVENUE_CATEGORY, /*dm.OFFICE_NUMBER, dm.BRANCH_KEY,*/ dm.MONTH
	,dt.CALENDAR_DATE, dt.DAY_TYPE
	,CASE WHEN dt.DAY_TYPE = 'Weekday' THEN 1
		WHEN dt.DAY_TYPE = 'Sat' THEN dm.PERCENT_SATURDAY
		WHEN dt.DAY_TYPE = 'Sun' THEN dm.PERCENT_SUNDAY
		WHEN dt.DAY_TYPE = 'Holiday' THEN dm.PERCENT_HOLIDAY
		ELSE NULL END AS DAYFALL_AMT -- parcels out which dayfall amount should be used for which day
	,SUM(DAYFALL_AMT) OVER( PARTITION BY /*dm.SOURCE_SYSTEM_ID,*/ dm.STATE, dm.REVENUE_CATEGORY, /*dm.OFFICE_NUMBER, dm.BRANCH_KEY,*/ dm.MONTH
							ORDER BY dt.CALENDAR_DATE -- applied at state, branch, office, revenue category, and month level
							ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS MONTH_DAYFALL -- how many hours budgeted by this point in the month
	,dd.TOTALDAYSOFMONTHSOFAR -- for display use in dashboard
    ,dd.MonthDays
    ,dd.PERIOD_END_DATE
	,dm.PERCENT_SATURDAY
	,dm.PERCENT_SUNDAY
	,dm.PERCENT_HOLIDAY
	,dd.HAH_CURRENT_WEEK_LAST_DAY
FROM DAYFALL_BYMONTH dm
INNER JOIN DAY_TYPE dt
ON dm.MONTH = DATE_TRUNC( MONTH,dt.CALENDAR_DATE)
INNER JOIN DIMDATE dd
ON dt.CALENDAR_DATE = dd.CALENDAR_DATE
	AND dm.STATE = dd.STATE
) SELECT * FROM DAYFALL_BYDAY;
SQL
	or_replace = true 
	is_secure = false 
}

