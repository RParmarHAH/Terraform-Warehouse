resource "snowflake_procedure" "DW_REPORT_GET_REPORT_OVERTIME_2_BACKUP_20210913" {
	name ="GET_REPORT_OVERTIME_2_BACKUP_20210913"
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "REPORT"
	language  = "JAVASCRIPT"

	arguments {
		name = "STR_ETL_TASK_KEY"
		type = "VARCHAR(16777216)"
}	

	arguments {
		name = "STR_CDC_START"
		type = "VARCHAR(16777216)"
}	

	arguments {
		name = "STR_CDC_END"
		type = "VARCHAR(16777216)"
}	
	return_type = "VARCHAR(16777216)"
	execute_as = "OWNER"
	statement = <<-EOT

        var sql = `
INSERT OVERWRITE INTO REPORT.OVERTIME_2
WITH master_emp AS (
    SELECT coalesce(M.employee_key,otr.EMPLOYEE_KEY) AS otr_employee_key,M.original_SOURCE_SYSTEM_ID,M.SYSTEM_CODE,gp.*
    FROM INTEGRATION.DIM_EMPLOYEE_MERGED gp
    LEFT JOIN INTEGRATION.DIM_EMPLOYEE_MERGED otr ON gp.original_EMPLOYEE_PID = otr.original_EMPLOYEE_PID AND otr.SOURCE_SYSTEM_ID <> 5
    LEFT join INTEGRATION.DIM_EMPLOYEE_MERGED M on otr.EMPLOYEE_KEY=M.original_EMPLOYEE_KEY
    WHERE gp.SOURCE_SYSTEM_ID = 5 AND gp.EMPLOYEE_CATEGORY = ''Field''
    )
SELECT DISTINCT
      emp.EMPLOYEE_KEY
     , emp.EMPLOYEE_ID
     , emp.PRIMARY_BRANCH_KEY
     , pay.PAYROLL_DATE
     , pay.PAY_HOURS as payroll_hours
     , pay.SERVICE_HOURS / (SUM(vis.HOURS_SERVED) OVER (PARTITION BY emp.EMPLOYEE_KEY,CHECK_NUMBER,pay.PAYROLL_DATE,pay.PAY_PERIOD_START_DATE,pay.PAY_PERIOD_END_DATE))* (SUM(vis.HOURS_SERVED) 
       OVER (PARTITION BY vis.SUPERVISOR_KEY, vis.CLIENT_KEY, vis.BRANCH_KEY, vis.CONTRACT_KEY,CHECK_NUMBER,date_trunc(''month'', vis.SERVICE_DATE))) as payroll_service_hours
     , pay.OVERTIME_HOURS as payroll_overtime_hours
     , pay.NON_SERVICE_UNITS as payroll_non_service_units
     , pay.PAY_RATE
     , pay.PAY_PERIOD_START_DATE
     , pay.PAY_PERIOD_END_DATE
     , pay.CHECK_NUMBER
     , vis.SUPERVISOR_KEY
     , vis.CLIENT_KEY
     , vis.CONTRACT_KEY
     , date_trunc(''month'', vis.SERVICE_DATE) as service_month
     , SUM(vis.HOURS_SERVED) OVER (PARTITION BY vis.SUPERVISOR_KEY, vis.CLIENT_KEY
         , vis.BRANCH_KEY, vis.CONTRACT_KEY, CHECK_NUMBER, date_trunc(''month'', vis.SERVICE_DATE)) AS hours_served
     , IFF(pay.SERVICE_HOURS > 0, (SUM(vis.HOURS_SERVED) OVER (PARTITION BY vis.SUPERVISOR_KEY
            , vis.CLIENT_KEY, vis.BRANCH_KEY, vis.CONTRACT_KEY, CHECK_NUMBER, date_trunc(''month'', vis.SERVICE_DATE)
         )) / pay.SERVICE_HOURS , 0) as overtime_ratio
     , IFF(pay.SERVICE_HOURS > 0, (SUM(vis.HOURS_SERVED) OVER (PARTITION BY vis.SUPERVISOR_KEY
            , vis.CLIENT_KEY, vis.BRANCH_KEY, vis.CONTRACT_KEY, CHECK_NUMBER, date_trunc(''month'', vis.SERVICE_DATE)
         )) / pay.SERVICE_HOURS * pay.OVERTIME_HOURS, 0) as overtime_hours
    , pay.OVERTIME_PAY_AMOUNT AS PAYROLL_OVERTIME_PAY_AMOUNT
    , IFF(pay.SERVICE_HOURS > 0, (SUM(vis.HOURS_SERVED) OVER (PARTITION BY vis.SUPERVISOR_KEY
           , vis.CLIENT_KEY, vis.BRANCH_KEY, vis.CONTRACT_KEY, CHECK_NUMBER, date_trunc(''month'', vis.SERVICE_DATE)
         )) / pay.SERVICE_HOURS * pay.OVERTIME_PAY_AMOUNT, 0) as overtime_pay_amount
    , emp.otr_employee_key
    ,vis.BRANCH_KEY
	,
        `;    
             sql += STR_ETL_TASK_KEY;
             sql +=  
             ` AS ETL_TASK_KEY,
        `;    
             sql += STR_ETL_TASK_KEY;
             sql +=  
             ` AS ETL_INSERTED_TASK_KEY,
	   convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_INSERTED_DATE,
	   CURRENT_USER as ETL_INSERTED_BY ,
	   convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_UPDATED_DATE,
	   CURRENT_USER as ETL_LAST_UPDATED_BY,
	   0 as ETL_DELETED_FLAG
FROM master_emp emp
 JOIN INTEGRATION.FACT_PAYROLL_MERGED pay ON emp.EMPLOYEE_KEY = pay.EMPLOYEE_KEY
 JOIN INTEGRATION.FACT_VISIT_MERGED vis ON emp.otr_employee_key = vis.EMPLOYEE_KEY
    AND vis.SERVICE_DATE >= pay.PAY_PERIOD_START_DATE
    AND vis.SERVICE_DATE <= pay.PAY_PERIOD_END_DATE
 JOIN HAH.DIM_CONTRACT ctrct ON ctrct.Contract_Key = vis.Contract_Key
UNION ALL
 (
 WITH EMPLOYEE AS (
 SELECT
   EMPLOYEE_KEY,
   EMPLOYEE_ID,
   PRIMARY_BRANCH_KEY
   FROM INTEGRATION.DIM_EMPLOYEE_MERGED WHERE SOURCE_SYSTEM_ID=4
 )
,VISITS AS (
      SELECT DISTINCT
      V.CLIENT_KEY,
      V.EMPLOYEE_KEY,
      V.EMPLOYEE_ID,
      SERVICE_DATE,
      PAYROLL_DATE,
      SUM(HOURS_SERVED) AS HOURS_SERVED,
      BRANCH_KEY,
      CONTRACT_KEY,
      SUPERVISOR_KEY
      FROM INTEGRATION.FACT_VISIT_MERGED V
      WHERE NVL(V.STATUS_CODE,''02'') IN (''02'',''03'',''04'',''05'')
      GROUP BY CLIENT_KEY,V.EMPLOYEE_ID,V.EMPLOYEE_KEY,SERVICE_DATE,PAYROLL_DATE,BRANCH_KEY,SUPERVISOR_KEY,CONTRACT_KEY)
    ,PAYROLL AS (
      SELECT
      P.EMPLOYEE_KEY,
      P.EMPLOYEE_ID,
      PAYROLL_DATE,
      SUM(ABS(PAY_HOURS)) AS PAY_HOURS,
      SUM(ABS(SERVICE_HOURS)) AS SERVICE_HOURS,
      SUM(OVERTIME_HOURS) AS OVERTIME_HOURS,
      SUM(OVERTIME_PAY_AMOUNT) AS OVERTIME_PAY_AMOUNT,
      BRANCH_KEY
      FROM INTEGRATION.FACT_PAYROLL_MERGED P
      WHERE P.original_SOURCE_SYSTEM_ID=6
      GROUP BY P.EMPLOYEE_KEY,P.EMPLOYEE_ID,PAYROLL_DATE,BRANCH_KEY
    )
    SELECT DISTINCT
    E.EMPLOYEE_KEY,
    E.EMPLOYEE_ID,
    E.PRIMARY_BRANCH_KEY,
    P.PAYROLL_DATE,
    CASE WHEN P.PAY_HOURS>0 AND V.HOURS_SERVED>0 THEN (P.PAY_HOURS * (V.HOURS_SERVED) / SUM(V.HOURS_SERVED)
        OVER (PARTITION BY V.EMPLOYEE_KEY,V.PAYROLL_DATE,V.BRANCH_KEY,V.SUPERVISOR_KEY,V.CONTRACT_KEY))
    ELSE NULL END AS PAYROLL_HOURS,
    CASE WHEN P.SERVICE_HOURS>0 AND V.HOURS_SERVED>0 THEN (P.SERVICE_HOURS * (V.HOURS_SERVED) / SUM(V.HOURS_SERVED)
        OVER (PARTITION BY V.EMPLOYEE_KEY,V.PAYROLL_DATE,V.BRANCH_KEY,V.SUPERVISOR_KEY,V.CONTRACT_KEY))
    ELSE NULL END AS PAYROLL_SERVICE_HOURS,
    NULL AS PAYROLL_OVERTIME_HOURS,
    NULL AS PAYROLL_NON_SERVICE_UNITS,
    NULL AS PAY_RATE,
    NULL AS PAY_PERIOD_START_DATE,
    NULL AS PAY_PERIOD_END_DATE,
    NULL AS CHECK_NUMBER,
    V.SUPERVISOR_KEY,
    V.CLIENT_KEY,
    V.CONTRACT_KEY,
    V.SERVICE_DATE AS SERVICE_MONTH,
    IFF(P.SERVICE_HOURS>0,V.HOURS_SERVED,0) AS HOURS_SERVED,
    NULL AS OVERTIME_RATIO,
    CASE WHEN P.SERVICE_HOURS>0 AND V.HOURS_SERVED>0 THEN (P.OVERTIME_HOURS * (V.HOURS_SERVED) / SUM(V.HOURS_SERVED)
        OVER (PARTITION BY V.EMPLOYEE_KEY,V.PAYROLL_DATE,V.BRANCH_KEY,V.SUPERVISOR_KEY,V.CONTRACT_KEY))
    ELSE NULL END AS OVERTIME_HOURS,
    CASE WHEN P.OVERTIME_PAY_AMOUNT>0 AND P.PAY_HOURS>0 THEN (P.OVERTIME_PAY_AMOUNT * (P.PAY_HOURS) / SUM(P.PAY_HOURS)
    OVER (PARTITION BY V.EMPLOYEE_KEY,V.PAYROLL_DATE,V.BRANCH_KEY,V.SUPERVISOR_KEY,V.CONTRACT_KEY))
    ELSE NULL END AS PAYROLL_OVERTIME_PAY_AMOUNT,
    NULL AS OVERTIME_PAY_AMOUNT,
    NULL AS OTR_EMPLOYEE_KEY,
    V.BRANCH_KEY AS BRANCH_KEY
    ,-1 AS ETL_TASK_KEY
    ,-1 AS ETL_INSERTED_TASK_KEY
    ,convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_INSERTED_DATE
    ,CURRENT_USER as ETL_INSERTED_BY
    ,convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_UPDATED_DATE
    ,CURRENT_USER as ETL_LAST_UPDATED_BY
    ,0 as ETL_DELETED_FLAG
    FROM EMPLOYEE E
    JOIN PAYROLL P ON E.EMPLOYEE_KEY=P.EMPLOYEE_KEY
    LEFT JOIN VISITS V ON V.EMPLOYEE_KEY=P.EMPLOYEE_KEY
        AND V.PAYROLL_DATE=P.PAYROLL_DATE
)
`;
          try {
                snowflake.execute (
                    {sqlText: sql}
                    );
                return "Succeeded.";   // Return a success/error indicator.
                }
            catch (err)  {
                return "Failed: " + err;   // Return a success/error indicator.
                }  
          
 EOT
}

