resource "snowflake_procedure" "DW_INTEGRATION_GET_MASTER_FACT_EMPLOYEE_CROSS_WALK" {
	name ="GET_MASTER_FACT_EMPLOYEE_CROSS_WALK"
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "INTEGRATION"
	language  = "SQL"

	arguments {
		name = "STR_ETL_TASK_KEY"
		type = "VARCHAR(16777216)"
}	
	return_type = "VARCHAR(16777216)"
	execute_as = "OWNER"
	statement = <<-EOT

DECLARE
    return_result VARCHAR;

BEGIN
--*****************************************************************************************************************************
-- NAME:  GET_MASTER_FACT_EMPLOYEE_CROSS_WALK
-- 
-- PURPOSE: MASTER PROC TO UPDATE CROSSWALK AND MAINTAIN LOG FOR ANY CHANGES
--		
-- DEVELOPMENT LOG:
-- DATE        AUTHOR                NOTES:
-- --------    -------------------   -----------------------------------------------------------------------------------------------
-- 09/13/2023	Gaurav / Leo / Moin          Initial development 
--*****************************************************************************************************************************


------------------------------------------------------------------------------
-- ********************** FLOW TO REFRESH CROSSWALK ************************

-- STEP 1 : CREATE CLONE TABLE FOR DUPS BY CLONNING CURRENT CROSSWALK  
-- STEP 2 : RUN UPDATE STATEMENTS ON CLONE DUPS TABLE 
-- STEP 3 : INSERT MAPPING CHANGED AND KEYS CHANGED INTO LOG TABLE
-- STEP 4 : INSERT MERGED KEYS INTO THE MERGED TABLE
-- STEP 5 : SETTING INACTIVE FLAG TRUE FOR INACTIVE EMPLOYEES
-- STEP 6 : MERGE INTO ACTUAL TABLE 
-- STEP 7 : INSERT CHANGED RECORDS INTO HISTORICAL TABLE
-- STEP 8 : UPDATE AMS PUBLIC AND IVR ID




---------------------------------------------------------------------------
-- STEP 1 : CREATE CLONE TABLE FOR DUPS BY CLONNING CURRENT CROSSWALK 

--** Updating AMS key for newly updated AMS employee ID, ss IDs

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
SET CW.AMS_EMPLOYEE_KEY = EM.EMPLOYEE_KEY
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_AMS_MERGED EM 
WHERE 
	(EM.SOURCE_SYSTEM_ID = CW.AMS_SOURCE_SYSTEM_ID
	AND EM.SYSTEM_CODE = CW.AMS_SYSTEM_CODE 
	AND EM.EMPLOYEE_ID = CW.AMS_EMPLOYEE_ID)
AND CW.INACTIVE <> TRUE AND CW.DUP_FLAG <> TRUE
AND 
	(CW.AMS_SOURCE_SYSTEM_ID IS NOT NULL 
	AND CW.AMS_SYSTEM_CODE IS NOT NULL 
	AND CW.AMS_EMPLOYEE_ID IS NOT NULL)
AND CW.AMS_EMPLOYEE_KEY IS NULL;

-- Purpose of this table is to find any duplicates, will be cloned from main table
CREATE OR REPLACE TABLE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
CLONE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK;



-- *************************************************************************
--- STEP 2 : RUN UPDATE STATEMENTS ON CLONE DUPS TABLE 


-- 1) AMS EMPLOYEE KEY UPDATION BASED ON INTERNAL DEDUPE
-- UPDATING THE LATEST KEYS FROM DISCOVERY LAYER WHICH ARE CHANGED DUE TO DATA REASONS 

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.AMS_EMPLOYEE_KEY=EM.MASTER_EMPLOYEE_KEY
FROM  DISC_DEDUPE_${var.SF_ENVIRONMENT}.PUBLIC.VW_EMPLOYEE_MATCH_LIST EM 
WHERE EM.EMPLOYEE_KEY =CW_D.AMS_EMPLOYEE_KEY
AND CW_D.AMS_EMPLOYEE_KEY <>EM.MASTER_EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND EM.MASTER_EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT AMS_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY''); 



-- 2) AMS EMPLOYEE KEY UPDATION BASED ON INTEGRATION DEDUPE
-- UPDATING THE LATEST EMPLOYEE KEY FROM INTEGRATION LAYER CORRESPONDING TO ORIGINAL_EMPLOYEE_KEY

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.AMS_EMPLOYEE_KEY=DM.EMPLOYEE_KEY
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_AMS_MERGED DM
WHERE CW_D.AMS_EMPLOYEE_KEY =DM.ORIGINAL_EMPLOYEE_KEY 
AND CW_D.AMS_EMPLOYEE_KEY<>DM.EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND DM.EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT AMS_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY'');


-- 3) PAYROLL EMPLOYEE KEY UPDATION BASED ON INTERNAL DEDUPE
-- UPDATING THE LATEST KEYS FROM DISCOVERY LAYER WHICH ARE CHANGED DUE TO DATA REASONS 

UPDATE  DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.PAYROLL_EMPLOYEE_KEY = PM.MASTER_EMPLOYEE_KEY
FROM  DISC_DEDUPE_${var.SF_ENVIRONMENT}."PUBLIC".VW_PAYROLL_EMPLOYEE_MATCH_LIST PM 
WHERE PM.EMPLOYEE_KEY =CW_D.PAYROLL_EMPLOYEE_KEY
AND CW_D.PAYROLL_EMPLOYEE_KEY <> PM.MASTER_EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND PM.MASTER_EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY''); 


-- 4) PAYROLL EMPLOYEE KEY UPDATION BASED ON INTEGRATION DEDUPE
-- UPDATING THE LATEST EMPLOYEE KEY FROM INTEGRATION LAYER CORRESPONDING TO ORIGINAL_EMPLOYEE_KEY

UPDATE  DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.PAYROLL_EMPLOYEE_KEY=PM.EMPLOYEE_KEY
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_PAYROLL_MERGE_DEDUPE PM 
WHERE  CW_D.PAYROLL_EMPLOYEE_KEY =PM.ORIGINAL_EMPLOYEE_KEY 
AND CW_D.PAYROLL_EMPLOYEE_KEY<>PM.EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND PM.EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY''); 


-- 5) UPDATING DUP FLAG TRUE IN "EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS" FOR DUPLICATES 
-- UPDATING DUP FLAG TRUE FOR KEYS MAPPING GOT CHANGED ON AMS AND PAYROLL AND BOTH KEYS ARE PRESENT IN CROSSWALK TABLE, THIS WILL CREATE ISSUE IN MERGE STATEMENT

--BELOW CODE IS FOR NOT VALID SCENARIOS: WE ARE NOT GOING TO UPDATE INVALID SCENARIOS DATA

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW
SET DUP_FLAG = TRUE ,DUP_FLAG_REASON = ''MAPPING_INTERCHANGED''
FROM (SELECT  AMS_EMPLOYEE_KEY||''-''||PAYROLL_EMPLOYEE_KEY A_P
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS D
		WHERE EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING M 
			WHERE M.AMS_EMPLOYEE_KEY = D.AMS_EMPLOYEE_KEY )
		AND EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING M 
			WHERE M.PAYROLL_EMPLOYEE_KEY = D.PAYROLL_EMPLOYEE_KEY )
	EXCEPT 
	SELECT  AMS_EMPLOYEE_KEY||''-''||PAYROLL_EMPLOYEE_KEY A_P
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING D
		WHERE EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS M 
			WHERE M.AMS_EMPLOYEE_KEY = D.AMS_EMPLOYEE_KEY )
		AND EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS M 
			WHERE M.PAYROLL_EMPLOYEE_KEY = D.PAYROLL_EMPLOYEE_KEY )
	) 
	AS SRC 
WHERE SRC.A_P = CW.AMS_EMPLOYEE_KEY||''-''||CW.PAYROLL_EMPLOYEE_KEY
;


-- *************************************************************************
-- STEP 3 : INSERT MAPPING CHANGED AND KEYS CHANGED INTO LOG TABLE 
--- Scenario  1 IS CONSIDERED AS "NEWLY_MAPPED" AND 
--- Scenario  2,3,5 ARE CONSIDERED AS ''MAPPING REMOVED''& "MAPPING CHANGED" 

-- CREATING TABLE FOR MASTER VIEW 
CREATE OR REPLACE TABLE DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK_TBL_MASTER 
AS SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK;

INSERT INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG
-----------------------------------
-- LOOKING FOR KEY GOT CHANGED
WITH KEYS_CHANGED AS 
	(SELECT CW.EMPLOYEE_ENTERPRISE_ID,
		''KEY_CHANGE'' AS CHANGE_TYPE,
		''AMS'' AS KEY_TYPE,
		CW.AMS_EMPLOYEE_KEY AS "AMS / PAYROLL_KEY", --OLD_KEY
		VW.MASTER_EMPLOYEE_KEY AS LATEST_DISC_LAYER_KEY, --LATEST_DISC_KEY
		EM.EMPLOYEE_KEY AS LATEST_INTEGRATION_LAYER_KEY, --LATEST_INTEGRATION_KEY
		NULL AS "PREVIOUSLY MAPPED PAYROLL / AMS",
		NULL AS OLD_MAPPED_APPLICANT
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS  D1
		ON CW.EMPLOYEE_ENTERPRISE_ID = D1.EMPLOYEE_ENTERPRISE_ID
		AND CW.AMS_EMPLOYEE_KEY <> D1.AMS_EMPLOYEE_KEY
		AND CW.INACTIVE <> TRUE 
		AND CW.DUP_FLAG <> TRUE
	LEFT JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}."PUBLIC".VW_EMPLOYEE_MATCH_LIST VW 
		ON VW.EMPLOYEE_KEY = CW.AMS_EMPLOYEE_KEY
		AND VW.MASTER_EMPLOYEE_KEY <> CW.AMS_EMPLOYEE_KEY 
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_AMS_MERGED EM 
		ON EM.ORIGINAL_EMPLOYEE_KEY = D1.AMS_EMPLOYEE_KEY
	WHERE CW.INACTIVE <> TRUE AND CW.DUP_FLAG <> TRUE 
		---------
		UNION 
		--------
	SELECT CW.EMPLOYEE_ENTERPRISE_ID,
			''KEY_CHANGE'' AS CHANGE_TYPE,
			''PAYROLL'' AS KEY_TYPE,
			CW.PAYROLL_EMPLOYEE_KEY AS "AMS / PAYROLL_KEY", --OLD_KEY
			VW.MASTER_EMPLOYEE_KEY AS LATEST_DISC_LAYER_KEY, --LATEST_DISC_KEY
			EMP.EMPLOYEE_KEY AS LATEST_INTEGRATION_LAYER_KEY, --LATEST_INTEGRATION_KEY
			NULL AS "PREVIOUSLY MAPPED PAYROLL / AMS",
			NULL AS OLD_MAPPED_APPLICANT
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS  D1
		ON CW.EMPLOYEE_ENTERPRISE_ID = D1.EMPLOYEE_ENTERPRISE_ID
		AND CW.PAYROLL_EMPLOYEE_KEY <> D1.PAYROLL_EMPLOYEE_KEY
		AND CW.INACTIVE <> TRUE 
		AND CW.DUP_FLAG <> TRUE
	LEFT JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}."PUBLIC".VW_PAYROLL_EMPLOYEE_MATCH_LIST VW 
		ON VW.EMPLOYEE_KEY = CW.PAYROLL_EMPLOYEE_KEY
		AND VW.MASTER_EMPLOYEE_KEY <> CW.PAYROLL_EMPLOYEE_KEY 
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_PAYROLL_MERGE_DEDUPE EMP 
		ON EMP.ORIGINAL_EMPLOYEE_KEY = D1.PAYROLL_EMPLOYEE_KEY
	WHERE CW.INACTIVE <> TRUE AND CW.DUP_FLAG <> TRUE
	)
-- TEMP CTE DURING TESTING
, KEY_CHANGED_FINAL AS 
	(SELECT * FROM KEYS_CHANGED 
--	WHERE EMPLOYEE_ENTERPRISE_ID||''--''||NVL(KEY_TYPE,'''')||''--''||NVL("AMS / PAYROLL_KEY",'''')
--	NOT IN 
--		(SELECT  ENTERPRISE_ID||''--''||NVL(KEY_TYPE,'''')||''--''||NVL("AMS / PAYROLL_KEY",'''')
--		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG WHERE CHANGE_TYPE = ''KEY_CHANGE'')
	)
----------------------------------
-- LOOKING FOR MAPPING CHANGED
,AMS_MAPP AS
	(SELECT CW.EMPLOYEE_ENTERPRISE_ID,
			''AMS'' "KEY_TYPE",
			CW.AMS_EMPLOYEE_KEY AS EMPLOYEE_KEY,
			CW.PAYROLL_EMPLOYEE_KEY AS OLD_MAPPED,
			NULL AS OLD_MAPPED_APPLICANT,
			VW.PAYROLL_EMPLOYEE_KEY AS NEW_MAPPING
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
		ON CW.AMS_EMPLOYEE_KEY = VW.AMS_EMPLOYEE_KEY 
		AND  NVL(CW.PAYROLL_EMPLOYEE_KEY,'''') <> NVL(VW.PAYROLL_EMPLOYEE_KEY,'''') 
	WHERE CW.INACTIVE <> TRUE AND CW.DUP_FLAG <> TRUE	
	UNION
	SELECT CW.EMPLOYEE_ENTERPRISE_ID,
			''AMS'' "KEY_TYPE",
			CW.AMS_EMPLOYEE_KEY AS EMPLOYEE_KEY,
			NULL AS OLD_MAPPED,
			CW.APPLICANT_EMPLOYEE_KEY AS OLD_MAPPED_APPLICANT,
			NULL AS NEW_MAPPING
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
		ON CW.AMS_EMPLOYEE_KEY = VW.AMS_EMPLOYEE_KEY 
		AND NVL(CW.APPLICANT_EMPLOYEE_KEY,'''') <> NVL(VW.APPLICANT_EMPLOYEE_KEY,'''')
	WHERE CW.INACTIVE <> TRUE AND CW.DUP_FLAG <> TRUE
	)
,PAYROLL_MAPP AS
	(SELECT CW.EMPLOYEE_ENTERPRISE_ID,
			''PAYROLL'' "KEY_TYPE",
			CW.PAYROLL_EMPLOYEE_KEY AS EMPLOYEE_KEY,
			CW.AMS_EMPLOYEE_KEY AS OLD_MAPPED,
			NULL AS OLD_MAPPED_APPLICANT,
			VW.AMS_EMPLOYEE_KEY AS NEW_MAPPING
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
		ON CW.PAYROLL_EMPLOYEE_KEY = VW.PAYROLL_EMPLOYEE_KEY 
		AND NVL(CW.AMS_EMPLOYEE_KEY,'''') <> NVL(VW.AMS_EMPLOYEE_KEY,'''') 
	WHERE CW.INACTIVE <> TRUE AND CW.DUP_FLAG <> TRUE
	)
,MAPPING_FINAL AS 
	(SELECT EMPLOYEE_ENTERPRISE_ID,
		CASE WHEN (OLD_MAPPED IS NULL AND NEW_MAPPING IS NOT NULL)
			THEN ''NEWLY_MAPPED''
			WHEN (NEW_MAPPING IS NULL AND OLD_MAPPED IS NOT NULL)
			THEN ''MAPPING REMOVED''
			WHEN (OLD_MAPPED IS NOT NULL AND NEW_MAPPING IS NOT NULL)
			THEN ''MAPPING CHANGED''
			ELSE ''APPLICANT_MAPPING_CHANGED''
			END AS CHANGE_TYPE,
			KEY_TYPE,
			EMPLOYEE_KEY AS "AMS / PAYROLL_KEY",
			NULL AS LATEST_DISC_LAYER_KEY,
			NULL AS LATEST_INTEGRATION_LAYER_KEY,
			OLD_MAPPED AS "PREVIOUSLY MAPPED PAYROLL / AMS",
			OLD_MAPPED_APPLICANT
	FROM (SELECT * FROM AMS_MAPP
			UNION 
			SELECT * FROM PAYROLL_MAPP)
	------------------------
	-- TEMPORARY CONDITION
--	WHERE EMPLOYEE_ENTERPRISE_ID||''-''||NVL(KEY_TYPE,'''')||''-''||NVL("AMS / PAYROLL_KEY",'''')||''-''||NVL("PREVIOUSLY MAPPED PAYROLL / AMS",'''')||''-''||NVL(OLD_MAPPED_APPLICANT,'''')
--	NOT IN 
--		(SELECT ENTERPRISE_ID||''-''||NVL(KEY_TYPE,'''')||''-''||NVL("AMS / PAYROLL_KEY",'''')||''-''||NVL("PREVIOUSLY MAPPED PAYROLL / AMS",'''')||''-''||NVL(OLD_MAPPED_APPLICANT,'''')
--		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
)
SELECT *,:STR_ETL_TASK_KEY AS ETL_INSERTED_TASK_KEY
		,:STR_ETL_TASK_KEY AS ETL_INSERTED_TASK_KEY
		,CURRENT_TIMESTAMP
		,CURRENT_USER
		,CURRENT_TIMESTAMP
		,CURRENT_USER
FROM (SELECT * FROM KEY_CHANGED_FINAL
		UNION SELECT * FROM MAPPING_FINAL);



-------------------------------------------------------------
-- NEED TO RUN THIS BEFORE MAPPING TABLE AND AFTER CHANGE LOG
-- UPDATING APPLICANT KEYS 
-- (DOING THIS BECAUSE MAPPING GOT CHANGED FOR APPLICANT KEYS)

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK TEMP_C
SET TEMP_C.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY 
FROM
	( SELECT COALESCE(CL."AMS / PAYROLL_KEY",VW.AMS_EMPLOYEE_KEY) AS AMS_EMPLOYEE_KEY, VW.APPLICANT_EMPLOYEE_KEY 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL -- JOINING ON CHANGE LOG TABLE TO GET THE LATEST KEYS
		ON COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,CL."AMS / PAYROLL_KEY") = VW.AMS_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) SRC
	WHERE TEMP_C.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY 
	AND NVL(TEMP_C.APPLICANT_EMPLOYEE_KEY,'''') <> NVL(SRC.APPLICANT_EMPLOYEE_KEY,'''')
	;

	
	
-- *************************************************************************
-- STEP 4 : INSERT MERGED KEYS INTO THE MERGED TABLE 
-- SOME KEYS ARE MERGED INTO ONE DUE TO SOME DATA CHANGES


--SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED;

--CREATE OR REPLACE TABLE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED
--CLONE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED;


INSERT INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED
-- Logic
-------------------------------------------
-- ************* CASE 1 ********************
-- SCENARIO 4 - FOR VIEW AND INTEGRATION CHANGES
-- MERGING BECAUSE OF KEY CHANGE
---------------------------------------------
WITH CROSSWALK AS
	(
	-- AMS AND PAYROLL KEYS FROM EMPLOYEE_CROSS_WALK TABLE
	SELECT DISTINCT AMS_EMPLOYEE_KEY,PAYROLL_EMPLOYEE_KEY,EMPLOYEE_ENTERPRISE_ID  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE )
------------------
,AMS_KEY_CHANGED AS
		(SELECT 
		CWD.AMS_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
		CWM.AMS_EMPLOYEE_KEY AS EMPLOYEE_KEY,
		CWD.PAYROLL_EMPLOYEE_KEY AS PAYROLL_EMPLOYEE_KEY 
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CWD
JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CWM -- NEED TO JOIN TO GET OLDER KEY 
	ON CWD.EMPLOYEE_ENTERPRISE_ID = CWM.EMPLOYEE_ENTERPRISE_ID 
WHERE CWD.AMS_EMPLOYEE_KEY IN 
	(
	SELECT AMS_EMPLOYEE_KEY
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE 
	-- FILTERING THOSE KEYS WHICH 
	AND AMS_EMPLOYEE_KEY IN 
		(SELECT COALESCE(LATEST_INTEGRATION_LAYER_KEY,LATEST_DISC_LAYER_KEY)
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG 
		WHERE CHANGE_TYPE =''KEY_CHANGE''
		AND KEY_TYPE= ''AMS'' 
		AND ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		)
	GROUP BY 1 HAVING COUNT(*)>1
	)
	)
,PAYROLL_KEY_CHANGED AS
		(
		SELECT 
		CWD.PAYROLL_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
		CWM.PAYROLL_EMPLOYEE_KEY AS EMPLOYEE_KEY,
		CWD.AMS_EMPLOYEE_KEY AS PAYROLL_EMPLOYEE_KEY 
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CWD
JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CWM -- NEED TO JOIN TO GET OLDER KEY 
	ON CWD.EMPLOYEE_ENTERPRISE_ID = CWM.EMPLOYEE_ENTERPRISE_ID 
WHERE CWD.PAYROLL_EMPLOYEE_KEY IN 
	(
	SELECT PAYROLL_EMPLOYEE_KEY
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE 
	-- FILTERING THOSE KEYS WHICH 
	AND PAYROLL_EMPLOYEE_KEY IN 
		(SELECT COALESCE(LATEST_INTEGRATION_LAYER_KEY,LATEST_DISC_LAYER_KEY)
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG 
		WHERE CHANGE_TYPE =''KEY_CHANGE''
		AND KEY_TYPE = ''PAYROLL''
		AND ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		)
	GROUP BY 1 HAVING COUNT(*)>1
	)
	)
,AMS_RANKED AS 
	(
	-- PROVIDING RANK TO MASTER_KEY AND EMPLOYEE_KEY ON THE BASIS OF PAYROLL_EMPLOYEE_KEY,ENTERPRISE_ID
	SELECT CW.AMS_EMPLOYEE_KEY AS CURRENT_KEY,
			AMS_ML.MASTER_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
			CW.EMPLOYEE_ENTERPRISE_ID,
			CW.PAYROLL_EMPLOYEE_KEY,   
			RANK() OVER(PARTITION BY MASTER_EMPLOYEE_KEY ORDER BY CW.PAYROLL_EMPLOYEE_KEY,EMPLOYEE_ENTERPRISE_ID) AS RANK
	FROM  CROSSWALK CW
	JOIN  AMS_KEY_CHANGED AMS_ML
		ON AMS_ML.EMPLOYEE_KEY  = CW.AMS_EMPLOYEE_KEY 
	WHERE CW.AMS_EMPLOYEE_KEY IN 
		(SELECT MASTER_EMPLOYEE_KEY FROM AMS_KEY_CHANGED
		UNION 
		SELECT EMPLOYEE_KEY FROM AMS_KEY_CHANGED)
	)
,PAYROLL_RANKED AS	 
	(
	-- PROVIDING RANK TO MASTER_KEY AND EMPLOYEE_KEY ON THE BASIS OF AMS_EMPLOYEE_KEY,ENTERPRISE_ID
	SELECT CW.PAYROLL_EMPLOYEE_KEY AS CURRENT_KEY,
			P_ML.MASTER_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
			CW.EMPLOYEE_ENTERPRISE_ID,
			CW.AMS_EMPLOYEE_KEY,
			RANK() OVER(PARTITION BY MASTER_EMPLOYEE_KEY ORDER BY CW.AMS_EMPLOYEE_KEY,EMPLOYEE_ENTERPRISE_ID) AS RANK
	FROM  CROSSWALK CW
	JOIN  PAYROLL_KEY_CHANGED P_ML
		ON P_ML.EMPLOYEE_KEY  = CW.PAYROLL_EMPLOYEE_KEY 
	WHERE CW.PAYROLL_EMPLOYEE_KEY IN 
		(SELECT MASTER_EMPLOYEE_KEY FROM PAYROLL_KEY_CHANGED
		UNION 
		SELECT EMPLOYEE_KEY FROM PAYROLL_KEY_CHANGED)
	)
, AMS_FINAL AS 
	(
	-- ASSIGNING LATEST ENTERPRISE_ID TO OLDER RECORD, AND MERGED ENTERPRISE_ID TO NEWER RECORD
	SELECT A1.EMPLOYEE_ENTERPRISE_ID AS LATEST_EMPLOYEE_ENTERPRISE_ID,
			A2.EMPLOYEE_ENTERPRISE_ID AS OLD_EMPLOYEE_ENTERPRISE_ID,
			''KEYS_MERGED'' AS MERGE_REASON
	FROM AMS_RANKED A1  
	JOIN AMS_RANKED A2
	ON A1.MASTER_EMPLOYEE_KEY = A2.MASTER_EMPLOYEE_KEY
	WHERE A1.RANK = 1 AND A2.RANK >= 2
	AND NOT (A1.PAYROLL_EMPLOYEE_KEY IS NOT NULL AND A2.PAYROLL_EMPLOYEE_KEY IS NOT NULL)
	)
, PAYROLL_FINAL AS 
	(
	-- ASSIGNING LATEST ENTERPRISE_ID TO OLDER RECORD, AND MERGED ENTERPRISE_ID TO NEWER RECORD
	SELECT P1.EMPLOYEE_ENTERPRISE_ID AS LATEST_EMPLOYEE_ENTERPRISE_ID,
			P2.EMPLOYEE_ENTERPRISE_ID AS OLD_EMPLOYEE_ENTERPRISE_ID,
			''KEYS_MERGED'' AS MERGE_REASON
	FROM PAYROLL_RANKED P1  
	JOIN PAYROLL_RANKED P2
	ON P1.MASTER_EMPLOYEE_KEY = P2.MASTER_EMPLOYEE_KEY
	WHERE P1.RANK = 1 AND P2.RANK >=2
	)
-------------------------------------------
-- ************* CASE 2 ********************
-- SCENARIO 1 - FOR MAPPING CHANGE
-- MERGING BECAUSE OF MAPPED WITH EACH OTHER
-- MAKING AMS RECORD AS OLDER AND PAYROLL AS LATEST (FOR NOW)
---------------------------------------------
,CROSSWALK_NOT_MAPPED_KEYS  AS 
	(
	-- AMS keys not mapped with any payroll
	SELECT DISTINCT 
	COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY, CW.AMS_EMPLOYEE_KEY) AS KEY
	FROM CROSSWALK CW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL -- JOINING ON CHANGE LOG TABLE TO GET THE LATEST KEYS WHICH GOT CHANGED IN PREVIOUS STEP
		ON CL."AMS / PAYROLL_KEY" = CW.AMS_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		WHERE PAYROLL_EMPLOYEE_KEY IS NULL 
		AND AMS_EMPLOYEE_KEY IS NOT NULL
		-- Putting this condition for enterprise IDs which are going to be inactive
		AND CW.EMPLOYEE_ENTERPRISE_ID NOT IN 
			(SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM AMS_FINAL)
	UNION
	-- Payroll keys not mapped with any AMS
	SELECT DISTINCT COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY, CW.PAYROLL_EMPLOYEE_KEY)  
	FROM CROSSWALK CW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL 
		ON CL."AMS / PAYROLL_KEY" = CW.PAYROLL_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		WHERE AMS_EMPLOYEE_KEY IS NULL 
		AND PAYROLL_EMPLOYEE_KEY IS NOT NULL
		-- Putting this condition for enterprise IDs which are going to be inactive
		AND CW.EMPLOYEE_ENTERPRISE_ID NOT IN 
			(SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM PAYROLL_FINAL)
	)
,RECENTLY_MAPPED AS 
	(
	SELECT *
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING --table contains only mapped keys 
	WHERE PAYROLL_EMPLOYEE_KEY IN (SELECT * FROM CROSSWALK_NOT_MAPPED_KEYS)
		OR AMS_EMPLOYEE_KEY IN (SELECT * FROM CROSSWALK_NOT_MAPPED_KEYS)
	)
,MAPPING_FINAL AS 
	(SELECT 
		CW_P.EMPLOYEE_ENTERPRISE_ID AS LATEST_EMPLOYEE_ENTERPRISE_ID, -- Payroll Enterprise ID
			CW_A.EMPLOYEE_ENTERPRISE_ID AS OLD_EMPLOYEE_ENTERPRISE_ID, -- AMS Enterprise ID
			''MAPPING_CHANGED'' AS MERGE_REASON
	FROM RECENTLY_MAPPED REC_MAP
	JOIN 
	(SELECT DISTINCT COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,C.PAYROLL_EMPLOYEE_KEY) AS PAYROLL_EMPLOYEE_KEY,C.EMPLOYEE_ENTERPRISE_ID
	FROM CROSSWALK C
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL 
		ON CL."AMS / PAYROLL_KEY" = C.PAYROLL_EMPLOYEE_KEY 
		AND CL.CHANGE_TYPE = ''KEY_CHANGE''
		AND CL."KEY_TYPE" = ''PAYROLL''
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) AS CW_P
		ON REC_MAP.PAYROLL_EMPLOYEE_KEY = CW_P.PAYROLL_EMPLOYEE_KEY 
	--
	JOIN 
	(SELECT DISTINCT COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,C.AMS_EMPLOYEE_KEY) AS AMS_EMPLOYEE_KEY, C.EMPLOYEE_ENTERPRISE_ID
	,C.PAYROLL_EMPLOYEE_KEY
	FROM CROSSWALK  C
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL 
		ON CL."AMS / PAYROLL_KEY" = C.AMS_EMPLOYEE_KEY 
		AND CL.CHANGE_TYPE = ''KEY_CHANGE''
		AND CL."KEY_TYPE" = ''AMS''
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) AS CW_A
		ON REC_MAP.AMS_EMPLOYEE_KEY = CW_A.AMS_EMPLOYEE_KEY
	WHERE NOT (CW_P.PAYROLL_EMPLOYEE_KEY IS NOT NULL AND CW_A.PAYROLL_EMPLOYEE_KEY IS NOT NULL)
	)
-------------------------------------------
-- ************* CASE 3 ********************
-- MERGING BECAUSE OF UNMAPPED APPLICANT KEYS MAPPED GOT MAPPED WITH AMS KEY
-- MAKING UNMAPPED RECORD AS OLDER AND MAPPED AS LATEST (FOR NOW)
---------------------------------------------
, APPLICANT_DUPS AS 
        (SELECT EMPLOYEE_ENTERPRISE_ID ,APPLICANT_EMPLOYEE_KEY ,AMS_EMPLOYEE_KEY ,PAYROLL_EMPLOYEE_KEY,
                RANK() OVER(PARTITION BY APPLICANT_EMPLOYEE_KEY ORDER BY AMS_EMPLOYEE_KEY) RANK_ 
        FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
            WHERE APPLICANT_EMPLOYEE_KEY IN
                (SELECT APPLICANT_EMPLOYEE_KEY 
                FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
                WHERE INACTIVE <> TRUE
                -- TEMPORARY EXCLUDING
                AND APPLICANT_EMPLOYEE_KEY <> ''87c0f006ae72b8114940595763b1d068''
                GROUP BY 1 HAVING COUNT(*)>1) -- DUPLICATE APPLICANT KEYS
        )
,APPLICANT_DUPS_EXCLUDE AS 
        (SELECT  c1.APPLICANT_EMPLOYEE_KEY,c1.EMPLOYEE_ENTERPRISE_ID AS EMPLOYEE_ENTERPRISE_ID_1,c1.AMS_EMPLOYEE_KEY,c1.PAYROLL_EMPLOYEE_KEY,C2.EMPLOYEE_ENTERPRISE_ID AS EMPLOYEE_ENTERPRISE_ID_2,c2.AMS_EMPLOYEE_KEY,c2.PAYROLL_EMPLOYEE_KEY 
         FROM APPLICANT_DUPS c1  
         JOIN APPLICANT_DUPS c2 
         ON c2.APPLICANT_EMPLOYEE_KEY = c1.APPLICANT_EMPLOYEE_KEY
         WHERE c1.rank_ = 1 AND c2.rank_ = 2
         AND ((c1.AMS_EMPLOYEE_KEY IS NOT NULL AND c2.AMS_EMPLOYEE_KEY IS NOT NULL) OR (C2.AMS_EMPLOYEE_KEY IS NOT NULL AND c1.PAYROLL_EMPLOYEE_KEY IS NOT null) OR (C1.AMS_EMPLOYEE_KEY IS NOT NULL AND c2.PAYROLL_EMPLOYEE_KEY IS NOT null)))
,APPLICANT_DUPS_FINAL AS
    (SELECT  
            A1.EMPLOYEE_ENTERPRISE_ID AS LATEST_ENTERPRISE_ID,
            A2.EMPLOYEE_ENTERPRISE_ID AS OLD_ENTERPRISE_ID,
            ''APPLICANT_KEYS_MERGED'' AS MERGE_REASON
        FROM APPLICANT_DUPS A1 
        JOIN APPLICANT_DUPS A2 
            ON A1.APPLICANT_EMPLOYEE_KEY = A2.APPLICANT_EMPLOYEE_KEY
        WHERE A1.RANK_ = 1 AND A2.RANK_ = 2
        -- Not considering enterprise IDs which are going to get inactive through previous CTEs i.e Keys_Change and Mapping_change  
        AND A1.EMPLOYEE_ENTERPRISE_ID NOT IN 
                (SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM AMS_FINAL 
                UNION 
                SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM PAYROLL_FINAL 
                UNION 
                SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM MAPPING_FINAL
                UNION
                SELECT EMPLOYEE_ENTERPRISE_ID_1 FROM APPLICANT_DUPS_EXCLUDE
                UNION
                SELECT EMPLOYEE_ENTERPRISE_ID_2 FROM APPLICANT_DUPS_EXCLUDE)
    )
,FINAL AS 
    (SELECT * FROM AMS_FINAL 
    UNION 
    SELECT * FROM PAYROLL_FINAL 
    UNION 
    SELECT * FROM MAPPING_FINAL
    UNION 
    SELECT * FROM APPLICANT_DUPS_FINAL)
                       
-----------------------------------
SELECT COALESCE((SELECT MAX(ID) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED),0)+ROW_NUMBER() OVER(ORDER BY (SELECT 1)) AS ID,
        LATEST_EMPLOYEE_ENTERPRISE_ID,
        OLD_EMPLOYEE_ENTERPRISE_ID,
        MERGE_REASON,
        TRUE AS ACTIVE_FLAG,
        CURRENT_TIMESTAMP AS INSERTED_DATE,
        CURRENT_USER AS INSERTED_BY
FROM FINAL
-- TEMPORARY CONDITION
--WHERE LATEST_EMPLOYEE_ENTERPRISE_ID||''--''||OLD_EMPLOYEE_ENTERPRISE_ID||''--''||MERGE_REASON
--NOT IN 
--  (SELECT LATEST_ENTERPRISE_ID||''--''||OLD_ENTERPRISE_ID||''--''||MERGE_REASON
--  FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED)
WHERE LATEST_EMPLOYEE_ENTERPRISE_ID <> OLD_EMPLOYEE_ENTERPRISE_ID
;




-- *************************************************************************
-- STEP 5 : SETTING INACTIVE FLAG TRUE FOR INACTIVE EMPLOYEES
-- AND DUPLICATE APPLICANT KEYS WHICH ARE NEWLY MAPPED WITH ANOTHER EMPLOYEE KEYS


UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
SET INACTIVE = TRUE 
WHERE EMPLOYEE_ENTERPRISE_ID IN 
	(SELECT OLD_ENTERPRISE_ID FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED
	WHERE INSERTED_DATE = (SELECT MAX(INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED)
	);

-- SETTING INACTIVE TRUE FOR THE APPLICANT KEYS WHICH ARE NEWLY MAPPED WITH AN AMS WHICH IS NOT CURRENTLY PRESENT IN CROSSWALK
-- BUT THE PAYROLL CORRESPONDING TO THAT AMS IS ALREADY PRESENT IN CROSSWALK
-- MAKING THE ENTERPRISE ID INACTIVE WHICH CONTAINS ONLY APPLICANT, AND MAPPING THE AMS AND APPLICANT TO THAT PAYROLL
 
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
SET INACTIVE = TRUE
WHERE EMPLOYEE_ENTERPRISE_ID IN 
	(SELECT CW.EMPLOYEE_ENTERPRISE_ID 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW 
		ON VW.APPLICANT_EMPLOYEE_KEY = CW.APPLICANT_EMPLOYEE_KEY 
	WHERE CW.INACTIVE <> TRUE 
		AND CW.AMS_EMPLOYEE_KEY IS NULL 
		AND VW.AMS_EMPLOYEE_KEY IS NOT NULL);


-- Updating AMS key Null for the records where the records were previously mapped but later got Unmapped
-- Doing this to keep the older Enterprise ID for Payroll record and the newer record will get created for AMS

--UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
--SET	 AMS_EMPLOYEE_KEY = NULL,
--	AMS_SOURCE_SYSTEM_ID = NULL,
--	AMS_SYSTEM_CODE = NULL,
--	AMS_EMPLOYEE_ID = NULL,
--	AMS_METADATA = NULL,
--	APPLICANT_EMPLOYEE_KEY = NULL
--WHERE PAYROLL_EMPLOYEE_KEY IN 
--	(
--	(SELECT NVL(PAYROLL_EMPLOYEE_KEY,'''') AS PAYROLL_EMPLOYEE_KEY
--	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
--	WHERE (AMS_EMPLOYEE_KEY IS NOT NULL AND PAYROLL_EMPLOYEE_KEY IS NOT NULL)
--	AND INACTIVE <> TRUE AND DUP_FLAG <> TRUE)
--	---------
--	EXCEPT  
--	--------
--	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY 
--	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING)
--	);

-- Updated logic on 09/09/2023 for new case 6 founded

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
SET AMS_EMPLOYEE_KEY = NULL, 
	AMS_SOURCE_SYSTEM_ID = NULL, 
	AMS_SYSTEM_CODE = NULL, 
	AMS_EMPLOYEE_ID = NULL, 
	AMS_METADATA = NULL,
	APPLICANT_EMPLOYEE_KEY = NULL,
    APPLICANT_SOURCE_SYSTEM_ID = NULL,
    APPLICANT_SYSTEM_CODE = NULL,
	WORKDAY_INTERNAL_ID = NULL
WHERE NVL(PAYROLL_EMPLOYEE_KEY,'''')||''-''||NVL(AMS_EMPLOYEE_KEY,'''') NOT IN 
	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY||''-''||AMS_EMPLOYEE_KEY 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING)
AND (AMS_EMPLOYEE_KEY IS NOT NULL AND PAYROLL_EMPLOYEE_KEY IS NOT NULL)
AND INACTIVE <> TRUE AND DUP_FLAG <> TRUE;
	

--  UPDATING KEYS FROM FACT_AMS_PAYROLL_MAPPING_TABLE IN "EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS"

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.PAYROLL_EMPLOYEE_KEY = FM.PAYROLL_EMPLOYEE_KEY,
	CW_D.AMS_EMPLOYEE_KEY = FM.AMS_EMPLOYEE_KEY
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING FM 
WHERE (
		FM.AMS_EMPLOYEE_KEY = CW_D.AMS_EMPLOYEE_KEY 
		OR FM.PAYROLL_EMPLOYEE_KEY = CW_D.PAYROLL_EMPLOYEE_KEY
	  )
AND (CW_D.INACTIVE <> TRUE AND CW_D.DUP_FLAG <> TRUE)
AND FM.PAYROLL_STATE_CODE <> ''NY''
-- Added on 09/27/23
-- To prevent AMS keys getting updated if data is updated by Workday but not yet recieved in WH
AND CW_D.PAYROLL_EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE
	AND 
		(AMS_SOURCE_SYSTEM_ID IS NOT NULL 
		AND AMS_SYSTEM_CODE IS NOT NULL 
		AND AMS_EMPLOYEE_ID IS NOT NULL)
	AND AMS_EMPLOYEE_KEY IS NULL
	)
;	

-- UPDATING DUP AND INACTIVE IN "EMPLOYEE_CROSS_WALK_TO_UPDATE_MAIN" TABLE 
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK M
SET	 M.DUP_FLAG = T.DUP_FLAG,
	M.DUP_FLAG_REASON = T.DUP_FLAG_REASON,
	M.INACTIVE = T.INACTIVE
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS T 
WHERE T.EMPLOYEE_ENTERPRISE_ID = M.EMPLOYEE_ENTERPRISE_ID 
AND (T.DUP_FLAG = TRUE OR T.INACTIVE = TRUE);


-- UPDATING KEYS CHANGED IN "EMPLOYEE_CROSS_WALK_TO_UPDATE_MAIN"

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK M
SET M.AMS_EMPLOYEE_KEY = T.AMS_EMPLOYEE_KEY, 
	M.PAYROLL_EMPLOYEE_KEY = T.PAYROLL_EMPLOYEE_KEY,
	M.APPLICANT_EMPLOYEE_KEY = T.APPLICANT_EMPLOYEE_KEY,
	M.AMS_SOURCE_SYSTEM_ID = T.AMS_SOURCE_SYSTEM_ID, 
	M.AMS_SYSTEM_CODE = T.AMS_SYSTEM_CODE, 
	M.AMS_EMPLOYEE_ID = T.AMS_EMPLOYEE_ID, 
	M.AMS_METADATA = T.AMS_METADATA,
    M.APPLICANT_SOURCE_SYSTEM_ID = T.APPLICANT_SOURCE_SYSTEM_ID,
    M.APPLICANT_SYSTEM_CODE = T.APPLICANT_SYSTEM_CODE,
	M.WORKDAY_INTERNAL_ID = T.WORKDAY_INTERNAL_ID
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS T 
WHERE T.EMPLOYEE_ENTERPRISE_ID = M.EMPLOYEE_ENTERPRISE_ID 
AND NOT (T.DUP_FLAG = TRUE OR T.INACTIVE = TRUE)
;

--------
-- UPDATING APPLICANT KEYS 
-- (DOING THIS BECAUSE MAPPING GOT CHANGED FOR APPLICANT KEYS)

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK TEMP_C
SET TEMP_C.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY 
FROM
	( SELECT COALESCE(CL."AMS / PAYROLL_KEY",VW.AMS_EMPLOYEE_KEY) AS AMS_EMPLOYEE_KEY, VW.APPLICANT_EMPLOYEE_KEY 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL -- JOINING ON CHANGE LOG TABLE TO GET THE LATEST KEYS
		ON COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,CL."AMS / PAYROLL_KEY") = VW.AMS_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) SRC
	WHERE TEMP_C.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY 
	AND NVL(TEMP_C.APPLICANT_EMPLOYEE_KEY,'''') <> NVL(SRC.APPLICANT_EMPLOYEE_KEY,'''')
	;

--UPDATING APPLICANT FROM WORKDAY_PARADOX MAPPING
--UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK TGT
--SET TGT.APPLICANT_EMPLOYEE_KEY = SRC.PARADOX_APPLICANT_KEY,
--    TGT.FIRST_NAME  = SRC.FIRST_NAME,
--    TGT.LAST_NAME = SRC.LAST_NAME,
--    TGT.APPLICANT_EMPLOYEE_ID  = SRC.PARADOX_APPLICANT_ID,
--    TGT.APPLICANT_SOURCE_SYSTEM_ID  = SRC.PARADOX_SOURCE_SYSTEM_ID,
--    TGT.APPLICANT_SYSTEM_CODE = SRC.PARADOX_SYSTEM_CODE  
--FROM (
--	SELECT CW.EMPLOYEE_ENTERPRISE_ID, WP.* 
--	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
--	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_WORKDAY_PARADOX_APPLICANT_MAPPING WP
--		ON CW.WORKDAY_INTERNAL_ID = WP.WORKDAY_ID 
--	WHERE CW.WORKDAY_INTERNAL_ID  IN (
--			SELECT WORKDAY_ID
--			FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_WORKDAY_PARADOX_APPLICANT_MAPPING
--	)
--		AND CW.WORKDAY_INTERNAL_ID IS NOT NULL
--		AND CW.INACTIVE = FALSE AND DUP_FLAG = FALSE
--) AS SRC
--WHERE SRC.EMPLOYEE_ENTERPRISE_ID = TGT.EMPLOYEE_ENTERPRISE_ID
--	AND NVL(TGT.APPLICANT_SOURCE_SYSTEM_ID, 0) = 36;


-- *************************************************************************
-- STEP 6 : MERGE INTO ACTUAL TABLE 


CREATE OR REPLACE TABLE DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK_TBL_MASTER 
AS SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK;


-- Inserting records which are not present currently in the table
INSERT INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
(
    EMPLOYEE_ENTERPRISE_ID,
    FIRST_NAME,
    LAST_NAME,
    BRANCH_STATE_CODE,
    AMS_EMPLOYEE_KEY,
    AMS_SOURCE_SYSTEM_ID,
    AMS_SYSTEM_CODE,
    AMS_EMPLOYEE_ID,
    AMS_METADATA,
    PAYROLL_EMPLOYEE_KEY,
    PAYROLL_SOURCE_SYSTEM_ID,
    PAYROLL_SYSTEM_CODE,
    PAYROLL_EMPLOYEE_ID,
    PAYROLL_METADATA,
    APPLICANT_EMPLOYEE_KEY,
    APPLICANT_SOURCE_SYSTEM_ID,
    APPLICANT_SYSTEM_CODE,
    APPLICANT_EMPLOYEE_ID,
    EXCEPTION_FLAG,
    ETL_TASK_KEY,
    ETL_INSERTED_TASK_KEY,
    ETL_INSERTED_DATE,
    ETL_INSERTED_BY,
    ETL_LAST_UPDATED_DATE,
    ETL_LAST_UPDATED_BY,
    ETL_DELETED_FLAG,
    DUP_FLAG,
    DUP_FLAG_REASON,
    INACTIVE,
    AMS_PAYROLL_ID,
    EMPLOYEE_SSN,
    BROADSPIRE_ID
    )
 -----------
 WITH DUP_FLAG_TRUE_KEYS AS--189,768
    (
    SELECT DISTINCT AMS_EMPLOYEE_KEY KEY
    FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
    WHERE DUP_FLAG = TRUE 
    AND AMS_EMPLOYEE_KEY IS NOT NULL
    UNION 
    SELECT DISTINCT PAYROLL_EMPLOYEE_KEY 
    FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
    WHERE DUP_FLAG = TRUE 
    AND PAYROLL_EMPLOYEE_KEY IS NOT NULL
    )
SELECT -- Newly added
    COALESCE((SELECT MAX(EMPLOYEE_ENTERPRISE_ID) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK WHERE EMPLOYEE_ENTERPRISE_ID < 50000000),10000000)+ROW_NUMBER() OVER(ORDER BY (SELECT 1)), 
    -- Old
--  SRC.EMPLOYEE_ENTERPRISE_ID,
    SRC.FIRST_NAME,
    SRC.LAST_NAME,
    SRC.BRANCH_STATE_CODE,
    SRC.AMS_EMPLOYEE_KEY,
    SRC.AMS_SOURCE_SYSTEM_ID,
    SRC.AMS_SYSTEM_CODE,
    SRC.AMS_EMPLOYEE_ID,
    OBJECT_CONSTRUCT(SRC.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.AMS_METADATA),
    SRC.PAYROLL_EMPLOYEE_KEY,
    SRC.PAYROLL_SOURCE_SYSTEM_ID,
    SRC.PAYROLL_SYSTEM_CODE,
    SRC.PAYROLL_EMPLOYEE_ID,
    OBJECT_CONSTRUCT(SRC.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.PAYROLL_METADATA),
    SRC.APPLICANT_EMPLOYEE_KEY,
    SRC.APPLICANT_SOURCE_SYSTEM_ID,
    SRC.APPLICANT_SYSTEM_CODE,
    SRC.APPLICANT_EMPLOYEE_ID,
    SRC.EXCEPTION_FLAG,
    :STR_ETL_TASK_KEY,
    :STR_ETL_TASK_KEY,
    CURRENT_TIMESTAMP,
    CURRENT_USER,
    CURRENT_TIMESTAMP,
    CURRENT_USER,
    0,0,NULL,FALSE,
    SRC.AMS_PAYROLL_ID,
    SRC.EMPLOYEE_SSN,
    SRC.BROADSPIRE_ID
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK_TBL_MASTER SRC
-- -- Excluding keys which are dups
WHERE NVL(AMS_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS)
AND NVL(PAYROLL_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS)
-- -- Excluding AMS keys which are already present in the table
AND NVL(AMS_EMPLOYEE_KEY,'''') NOT IN 
    (SELECT DISTINCT AMS_EMPLOYEE_KEY
    FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
    WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE
    AND AMS_EMPLOYEE_KEY IS NOT NULL)
-- -- Excluding Payroll keys which are already present in the table
AND NVL(PAYROLL_EMPLOYEE_KEY,'''') NOT IN 
    (SELECT DISTINCT PAYROLL_EMPLOYEE_KEY
    FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
    WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE
    AND PAYROLL_EMPLOYEE_KEY IS NOT NULL)
-- -- Excluding Applicant keys which are already present in the table
AND NVL(APPLICANT_EMPLOYEE_KEY,'''') NOT IN 
    (SELECT DISTINCT APPLICANT_EMPLOYEE_KEY
    FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
    WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE
    AND APPLICANT_EMPLOYEE_KEY IS NOT NULL)
;   


-- Updating Applicant already present
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK  AS cw
SET
	CW.FIRST_NAME = SRC.FIRST_NAME,
	CW.LAST_NAME = SRC.LAST_NAME,
	CW.BRANCH_STATE_CODE = SRC.BRANCH_STATE_CODE,
	CW.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY,
	CW.AMS_SOURCE_SYSTEM_ID = SRC.AMS_SOURCE_SYSTEM_ID,
	CW.AMS_SYSTEM_CODE = SRC.AMS_SYSTEM_CODE,
	CW.AMS_EMPLOYEE_ID = SRC.AMS_EMPLOYEE_ID,
	CW.AMS_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.AMS_METADATA),
	CW.PAYROLL_EMPLOYEE_KEY = SRC.PAYROLL_EMPLOYEE_KEY,
	CW.PAYROLL_SOURCE_SYSTEM_ID = SRC.PAYROLL_SOURCE_SYSTEM_ID,
	CW.PAYROLL_SYSTEM_CODE = SRC.PAYROLL_SYSTEM_CODE,
	CW.PAYROLL_EMPLOYEE_ID = SRC.PAYROLL_EMPLOYEE_ID,
	CW.PAYROLL_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.PAYROLL_METADATA),
	CW.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY,
	CW.APPLICANT_SOURCE_SYSTEM_ID = SRC.APPLICANT_SOURCE_SYSTEM_ID,
	CW.APPLICANT_SYSTEM_CODE = SRC.APPLICANT_SYSTEM_CODE,
	CW.APPLICANT_EMPLOYEE_ID = SRC.APPLICANT_EMPLOYEE_ID,
	CW.EXCEPTION_FLAG = SRC.EXCEPTION_FLAG,
	CW.DUP_FLAG = FALSE,
    CW.DUP_FLAG_REASON = NULL,
	CW.INACTIVE = FALSE,
	CW.ETL_LAST_UPDATED_DATE = CURRENT_TIMESTAMP,
	CW.ETL_LAST_UPDATED_BY = CURRENT_USER,
    CW.AMS_PAYROLL_ID = SRC.AMS_PAYROLL_ID,
	CW.EMPLOYEE_SSN = SRC.EMPLOYEE_SSN,
	CW.BROADSPIRE_ID = SRC.BROADSPIRE_ID
FROM 
	(WITH DUP_FLAG_TRUE_KEYS AS--189,768
		(
		SELECT DISTINCT AMS_EMPLOYEE_KEY KEY
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND AMS_EMPLOYEE_KEY IS NOT NULL
		UNION 
		SELECT DISTINCT PAYROLL_EMPLOYEE_KEY 
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND PAYROLL_EMPLOYEE_KEY IS NOT NULL
		)
	SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK_TBL_MASTER
		WHERE NVL(AMS_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS)
		 AND NVL(PAYROLL_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS) 
	 ) 	 
--	DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK
	 as src
WHERE (CW.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY
        )
        AND CW.DUP_FLAG <> TRUE 
		AND CW.INACTIVE <> TRUE
		--AND AMS_EMPLOYEE_KEY IS NULL AND PAYROLL_EMPLOYEE_KEY IS NULL 
		AND SRC.APPLICANT_EMPLOYEE_KEY NOT IN 
			(SELECT APPLICANT_EMPLOYEE_KEY 
			FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK 
			WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE
			AND APPLICANT_EMPLOYEE_KEY IS NOT NULL
			GROUP BY 1 HAVING COUNT(*)>1)
;



-- Updating AMS already present
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK  AS cw
SET
	CW.FIRST_NAME = SRC.FIRST_NAME,
	CW.LAST_NAME = SRC.LAST_NAME,
	CW.BRANCH_STATE_CODE = SRC.BRANCH_STATE_CODE,
	CW.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY,
	CW.AMS_SOURCE_SYSTEM_ID = SRC.AMS_SOURCE_SYSTEM_ID,
	CW.AMS_SYSTEM_CODE = SRC.AMS_SYSTEM_CODE,
	CW.AMS_EMPLOYEE_ID = SRC.AMS_EMPLOYEE_ID,
	CW.AMS_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.AMS_METADATA),
	CW.PAYROLL_EMPLOYEE_KEY = SRC.PAYROLL_EMPLOYEE_KEY,
	CW.PAYROLL_SOURCE_SYSTEM_ID = SRC.PAYROLL_SOURCE_SYSTEM_ID,
	CW.PAYROLL_SYSTEM_CODE = SRC.PAYROLL_SYSTEM_CODE,
	CW.PAYROLL_EMPLOYEE_ID = SRC.PAYROLL_EMPLOYEE_ID,
	CW.PAYROLL_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.PAYROLL_METADATA),
	CW.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY,
	CW.APPLICANT_SOURCE_SYSTEM_ID = SRC.APPLICANT_SOURCE_SYSTEM_ID,
	CW.APPLICANT_SYSTEM_CODE = SRC.APPLICANT_SYSTEM_CODE,
	CW.APPLICANT_EMPLOYEE_ID = SRC.APPLICANT_EMPLOYEE_ID,
	CW.EXCEPTION_FLAG = SRC.EXCEPTION_FLAG,
	CW.DUP_FLAG = FALSE,
    CW.DUP_FLAG_REASON = NULL,
	CW.INACTIVE = FALSE,
	CW.ETL_LAST_UPDATED_DATE = CURRENT_TIMESTAMP,
	CW.ETL_LAST_UPDATED_BY = CURRENT_USER,
    CW.AMS_PAYROLL_ID = SRC.AMS_PAYROLL_ID,
	CW.EMPLOYEE_SSN = SRC.EMPLOYEE_SSN,
	CW.BROADSPIRE_ID = SRC.BROADSPIRE_ID
FROM 
	(WITH DUP_FLAG_TRUE_KEYS AS--189,768
		(
		SELECT DISTINCT AMS_EMPLOYEE_KEY KEY
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND AMS_EMPLOYEE_KEY IS NOT NULL
		UNION 
		SELECT DISTINCT PAYROLL_EMPLOYEE_KEY 
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND PAYROLL_EMPLOYEE_KEY IS NOT NULL
		)
	SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK_TBL_MASTER
		WHERE NVL(AMS_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS)
		 AND NVL(PAYROLL_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS) 
	 ) 	 
--	DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK
	 as src
WHERE (cw.AMS_EMPLOYEE_KEY = src.AMS_EMPLOYEE_KEY 
       )
        AND CW.DUP_FLAG <> TRUE 
		AND CW.INACTIVE <> TRUE
;



-- Updating Payroll already present
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK AS cw
SET
	CW.FIRST_NAME = SRC.FIRST_NAME,
	CW.LAST_NAME = SRC.LAST_NAME,
	CW.BRANCH_STATE_CODE = SRC.BRANCH_STATE_CODE,
	CW.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY,
	CW.AMS_SOURCE_SYSTEM_ID = SRC.AMS_SOURCE_SYSTEM_ID,
	CW.AMS_SYSTEM_CODE = SRC.AMS_SYSTEM_CODE,
	CW.AMS_EMPLOYEE_ID = SRC.AMS_EMPLOYEE_ID,
	CW.AMS_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.AMS_METADATA),
	CW.PAYROLL_EMPLOYEE_KEY = SRC.PAYROLL_EMPLOYEE_KEY,
	CW.PAYROLL_SOURCE_SYSTEM_ID = SRC.PAYROLL_SOURCE_SYSTEM_ID,
	CW.PAYROLL_SYSTEM_CODE = SRC.PAYROLL_SYSTEM_CODE,
	CW.PAYROLL_EMPLOYEE_ID = SRC.PAYROLL_EMPLOYEE_ID,
	CW.PAYROLL_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.PAYROLL_METADATA),
	CW.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY,
	CW.APPLICANT_SOURCE_SYSTEM_ID = SRC.APPLICANT_SOURCE_SYSTEM_ID,
	CW.APPLICANT_SYSTEM_CODE = SRC.APPLICANT_SYSTEM_CODE,
	CW.APPLICANT_EMPLOYEE_ID = SRC.APPLICANT_EMPLOYEE_ID,
	CW.EXCEPTION_FLAG = SRC.EXCEPTION_FLAG,
	CW.DUP_FLAG = FALSE,
    CW.DUP_FLAG_REASON = NULL,
	CW.INACTIVE = FALSE,
	CW.ETL_LAST_UPDATED_DATE = CURRENT_TIMESTAMP,
	CW.ETL_LAST_UPDATED_BY = CURRENT_USER,
    CW.AMS_PAYROLL_ID = SRC.AMS_PAYROLL_ID,
	CW.EMPLOYEE_SSN = SRC.EMPLOYEE_SSN,
	CW.BROADSPIRE_ID = SRC.BROADSPIRE_ID
FROM 
	(WITH DUP_FLAG_TRUE_KEYS AS--189,768
		(
		SELECT DISTINCT AMS_EMPLOYEE_KEY KEY
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND AMS_EMPLOYEE_KEY IS NOT NULL
		UNION 
		SELECT DISTINCT PAYROLL_EMPLOYEE_KEY 
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND PAYROLL_EMPLOYEE_KEY IS NOT NULL
		)
	SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK_TBL_MASTER
		WHERE NVL(AMS_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS)
		 AND NVL(PAYROLL_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS) 
	 ) 	 
--	DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK
	 as src
WHERE (cw.PAYROLL_EMPLOYEE_KEY = src.PAYROLL_EMPLOYEE_KEY 
    	)
        AND CW.DUP_FLAG <> TRUE 
		AND CW.INACTIVE <> TRUE
--		AND COALESCE(CW.PAYROLL_EMPLOYEE_KEY,'''') NOT IN 
--			(SELECT DISTINCT COALESCE(PAYROLL_EMPLOYEE_KEY,'''')
--			FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
--			WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE
--			AND 
--				(AMS_SOURCE_SYSTEM_ID IS NOT NULL 
--				AND AMS_SYSTEM_CODE IS NOT NULL 
--				AND AMS_EMPLOYEE_ID IS NOT NULL)
--			AND AMS_EMPLOYEE_KEY IS NULL
--			)
;


-- *************************************************************************
-- STEP 7 : UPDATE AMS_IVR_ID AND AMS_PUBLIC_ID

----UPDATE ALAYACRE 
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK T1
SET T1.AMS_PUBLIC_ID = T2.PUBLIC_ID, 
	T1.AMS_IVR_ID = T2.AMS_IVR_ID 
FROM (
SELECT PROFILE_UID AS AMS_IVR_ID ,
		CW.EMPLOYEE_ENTERPRISE_ID,
		CW.AMS_EMPLOYEE_ID, 
		EM.GUID,
		CW.AMS_SYSTEM_CODE,
		CASE WHEN CW.AMS_SYSTEM_CODE = ''ALABAMA (3554)'' THEN CONCAT(''AC'', LPAD(EM.GUID, 9, ''0''))
			 WHEN CW.AMS_SYSTEM_CODE = ''GEORGIA (1002)'' THEN DM.PAYROLL_ID
			 ELSE NULL END AS PUBLIC_ID
	FROM
	DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
	JOIN 
	DISC_DEDUPE_${var.SF_ENVIRONMENT}.ALAYACARE.EMPLOYEE_MASTER_LIST EM 
	ON TRIM(CW.AMS_EMPLOYEE_ID) =TRIM(EM.EMPLOYEE_ID)
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_AMS_MERGED DM 
	ON TRIM(cw.AMS_EMPLOYEE_KEY) =dm.ORIGINAL_EMPLOYEE_KEY 
	WHERE CW.AMS_SYSTEM_CODE IN (''ALABAMA (3554)'',''GEORGIA (1002)'')
	) T2 
WHERE T2.EMPLOYEE_ENTERPRISE_ID = T1.EMPLOYEE_ENTERPRISE_ID;

-----UPDATE OPENSYSTEMS
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK T1
SET T1.AMS_PUBLIC_ID = T2.PUBLIC_ID
FROM (
SELECT
    DISTINCT
    CW.EMPLOYEE_ENTERPRISE_ID,
    CW.AMS_EMPLOYEE_KEY,
    CW.AMS_EMPLOYEE_ID,
    EMP.CAREGIVERID,
    TRIM(EMP.CAREGIVERCODE) AS PUBLIC_ID
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW   
JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.HHAEXCHANGEOPENSYSTEMS.EMPLOYEE_MASTER_LIST EMP ON
    CW.AMS_EMPLOYEE_ID  = EMP.CAREGIVERID
JOIN DISC_${var.SF_ENVIRONMENT}.HHAEXCHANGEOPENSYSTEMS.OFFICE_OFFICES_REPL BR ON
    EMP.OFFICEID = BR.OFFICEID ::VARCHAR AND EMP.AGENCYID  = BR.AGENCYID
WHERE CW.AMS_SYSTEM_CODE ILIKE ''%OPENSYSTEMS%''--6229
) T2
WHERE T1.EMPLOYEE_ENTERPRISE_ID = T2.EMPLOYEE_ENTERPRISE_ID;


-----UPDATE OSHAH
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK T1
SET T1.AMS_PUBLIC_ID = T2.PUBLIC_ID
FROM (
SELECT
    DISTINCT
    CW.EMPLOYEE_ENTERPRISE_ID,
    CW.AMS_EMPLOYEE_KEY,
    CW.AMS_EMPLOYEE_ID,
    EMP.CAREGIVERID,
    TRIM(EMP.CAREGIVERCODE) AS PUBLIC_ID
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW   
JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.HHAEXCHANGEOSHAH.EMPLOYEE_MASTER_LIST EMP ON
    CW.AMS_EMPLOYEE_ID  = EMP.CAREGIVERID
JOIN DISC_${var.SF_ENVIRONMENT}.HHAEXCHANGEOSHAH.OFFICE_OFFICES_REPL BR ON
    EMP.OFFICEID = BR.OFFICEID ::VARCHAR AND EMP.AGENCYID  = BR.AGENCYID
WHERE CW.AMS_SYSTEM_CODE ILIKE ''%OSHAH%''
) T2
WHERE T1.EMPLOYEE_ENTERPRISE_ID = T2.EMPLOYEE_ENTERPRISE_ID;



--UPDATE DATAFLEX
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK SRC
SET SRC.AMS_PUBLIC_ID  = TGT.PUBLIC_ID
FROM (
	SELECT DISTINCT CW.EMPLOYEE_ENTERPRISE_ID,
	       CASE 
		     WHEN M.PAYROLLIDINDEXNO = 0 
		     	THEN NULL
	      	 WHEN LENGTH(M.PAYROLLIDINDEXNO) < 6 
	      	 	THEN CONCAT(REPEAT(''0'', 6 - LENGTH(M.PAYROLLIDINDEXNO)), M.PAYROLLIDINDEXNO)
	       	 ELSE M.PAYROLLIDINDEXNO::VARCHAR	
	       END AS PUBLIC_ID
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
	LEFT JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.EMPLOYEE_MASTER_LIST M
		ON CW.AMS_EMPLOYEE_ID = M."NUMBER" AND CW.AMS_SYSTEM_CODE = M.DBNAME 
	WHERE CW.AMS_SOURCE_SYSTEM_ID = 3
	) AS TGT
WHERE SRC.EMPLOYEE_ENTERPRISE_ID  = TGT.EMPLOYEE_ENTERPRISE_ID;



----UPDATE SANDATA
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK T1
SET T1.AMS_PUBLIC_ID = T2.PUBLIC_ID
FROM (
    SELECT 
        CW.EMPLOYEE_ENTERPRISE_ID, 
        ML.AGENCYID, 
        NULLIF(TRIM(ML.STAFFAGENCYID), '''') AS PUBLIC_ID
    FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
    LEFT JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.SANDATAIMPORT.EMPLOYEE_MASTER_LIST ML 
        ON CW.AMS_EMPLOYEE_ID = ML.STAFFAGENCYID AND CW.AMS_SYSTEM_CODE = ML.AGENCYID
    WHERE CW.AMS_SOURCE_SYSTEM_ID = 4
) T2
WHERE T1.EMPLOYEE_ENTERPRISE_ID = T2.EMPLOYEE_ENTERPRISE_ID;

-- *************************************************************************
-- STEP 8 : UPDATING APPLICANT KEYS FOR THE LATEST UPDATED APPLICANTS FROM HOURLY PROCESS 

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK  CW 
SET	CW.APPLICANT_EMPLOYEE_KEY = VW.PARADOX_APPLICANT_KEY,
	CW.APPLICANT_EMPLOYEE_ID = VW.PARADOX_APPLICANT_ID , 
	CW.APPLICANT_SOURCE_SYSTEM_ID = VW.PARADOX_SOURCE_SYSTEM_ID , 
	CW.APPLICANT_SYSTEM_CODE = VW.PARADOX_SYSTEM_CODE
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_WORKDAY_PARADOX_APPLICANT_MAPPING VW 
WHERE VW.WORKDAY_ID = CW.WORKDAY_INTERNAL_ID 
AND CW.INACTIVE <> TRUE AND CW.DUP_FLAG <> TRUE 
AND (CW.APPLICANT_EMPLOYEE_KEY IS NULL OR CW.APPLICANT_SOURCE_SYSTEM_ID = 36)
AND VW.PARADOX_APPLICANT_KEY NOT IN 
	(SELECT NVL(APPLICANT_EMPLOYEE_KEY,'''') 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE)
; 


-- *************************************************************************
-- STEP 9 : UPDATING SSN FROM WORKDAY

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK TGT
SET TGT.EMPLOYEE_SSN = SRC.SSN 
FROM
	(WITH ALL_REC AS
		(SELECT CROSSWALK_EMPLOYEE_ENTERPRISE_ID, WORKDAY_ID, ''WORKDAY_CROSSWALK_MAPPING'' AS TYPE  
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.WORKDAY_CROSSWALK_MAPPING WCM 
		WHERE ON_HOLD <> TRUE
		QUALIFY ROW_NUMBER() OVER(PARTITION BY CROSSWALK_EMPLOYEE_ENTERPRISE_ID ORDER BY ETL_INSERTED_DATE DESC) = 1
		UNION 
		SELECT CROSSWALK_EMPLOYEE_ENTERPRISE_ID, WORKDAY_ID , ''APPLICANT_CROSSWALK_MAPPING'' AS TYPE   
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.APPLICANT_CROSSWALK_MAPPING WCM 
		WHERE ON_HOLD <> TRUE
		QUALIFY ROW_NUMBER() OVER(PARTITION BY CROSSWALK_EMPLOYEE_ENTERPRISE_ID ORDER BY ETL_INSERTED_DATE DESC) = 1
		)
	, UNQ_REC AS 
		(SELECT *, ROW_NUMBER() OVER(PARTITION BY CROSSWALK_EMPLOYEE_ENTERPRISE_ID ORDER BY TYPE DESC) R
		FROM ALL_REC 
		QUALIFY R = 1
		)--SELECT * FROM UNQ_REC;
	SELECT UR.CROSSWALK_EMPLOYEE_ENTERPRISE_ID, UR.WORKDAY_ID, COALESCE(EM.EMPLOYEE_PID, APP.SSN) AS SSN 
	FROM UNQ_REC UR 
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.HAH.DIM_EMPLOYEE EM 
		ON EM.EMPLOYEE_ID = UR.WORKDAY_ID 
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.HAH.DIM_APPLICANT APP 
		ON EM.APPLICANT_ID = UR.WORKDAY_ID 
	WHERE COALESCE(EM.EMPLOYEE_PID, APP.APPLICANT_ID) IS NOT NULL
	) AS SRC
WHERE TGT.EMPLOYEE_ENTERPRISE_ID = SRC.CROSSWALK_EMPLOYEE_ENTERPRISE_ID
; 


-- *************************************************************************
-- STEP 10 : INSERT CHANGED RECORDS INTO HISTORICAL TABLE 

INSERT INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_HISTORICAL
SELECT * EXCLUDE (ETL_INSERTED_DATE, ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE, ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, AMS_PUBLIC_ID, AMS_PAYROLL_ID, EMPLOYEE_SSN),
		CURRENT_TIMESTAMP, CURRENT_USER, AMS_PUBLIC_ID, AMS_PAYROLL_ID , EMPLOYEE_SSN 
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK AT (OFFSET => -60*60*24)
EXCEPT 
SELECT * EXCLUDE (ETL_INSERTED_DATE, ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE, ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, AMS_PUBLIC_ID, AMS_PAYROLL_ID, EMPLOYEE_SSN),
		CURRENT_TIMESTAMP, CURRENT_USER, AMS_PUBLIC_ID , AMS_PAYROLL_ID , EMPLOYEE_SSN
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK;

------------------------------------------------
return ''SUCCEED'';
end;

 EOT
}

