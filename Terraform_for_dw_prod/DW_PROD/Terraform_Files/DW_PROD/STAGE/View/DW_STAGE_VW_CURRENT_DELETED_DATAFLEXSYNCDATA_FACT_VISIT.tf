resource "snowflake_view" "DW_STAGE_VW_CURRENT_DELETED_DATAFLEXSYNCDATA_FACT_VISIT" {
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "STAGE"
	name = "VW_CURRENT_DELETED_DATAFLEXSYNCDATA_FACT_VISIT"
	statement = <<-SQL
	 
WITH 
CODES_DESC AS (													
													-- GENERAL Note: sandata_schedules have MORE updated DATA than sandata_visits
													-- SD have visits split into more than one sometimes, whose total hours are equal with hours in mapped DF visit
SELECT SV.agencyID,
		CASE WHEN SV.agencyID = '38004' THEN 'IN'
             WHEN SV.agencyID = '8380' THEN 'IL'
             WHEN SV.agencyID = '8463' THEN 'MO'
            ELSE 'UK' END 
    AS DF_SYSTEM_CODE,
		CASE WHEN try_to_numeric(SV.ClientOtherID) is null THEN -1 ELSE SV.ClientOtherID END::INTEGER 
	AS DF_Client_Number,   
    SV.STAFFAGENCYID,
    SV."DATE",
    SCH.SCHEDULEID, --7			 
	SCH.CANCELREASON AS CANCEL_REASON_CODE,	
	SCH.CANCELREASONNOTES AS CANCEL_REASON_NOTES,
	SV.REASONCODEDESCRIPTION AS CANCEL_REASON_DESCRIPTION,
	SCH.RESOLUTIONCODE AS RESOLUTION_CODE, 
	SCH.REJECTIONCODE AS REJECTION_CODE, 
	r.DESCRIPTION as REJECTION_DESCRIPTION,
	sch.EXCEPTIONCODE AS EXCEPTION_CODE,
		CASE WHEN NVL(EXCEPTION_CODE,'0') NOT IN ('','0') THEN 'YES' ELSE 'NO' END						
	AS EXCEPTION_REASON_INDICATOR,
	IFF(sch.STATUS IN ('02','03','04'),sch.STATUS,NULL) AS CF_STATUS,
	IFF(sch.STATUS IN ('01','09','10'),sch.STATUS,NULL) AS CN_STATUS,
	IFF(NVL(SCH.UPDATEDAT,SCH.CREATEDAT) >= NVL(SV.UPDATEDAT,SV.CREATEDAT),sch.STATUS,SV.EVENTSTATUS) AS STATUS_CODE,  								--- TAKING STATUS OF NON CANCELLED SPLIT VISIT
	first_value(sch.VERIFICATIONTYPE)over(PARTITION BY SV.AGENCYID, SV.CLIENTNUMBER, SV.STAFFAGENCYID, SV."DATE" ORDER BY sch.VERIFICATIONTYPE) -- IF ONE SPLIT VISIT IS AUTO THEN CONSIDER WHOLE VISIT AS AUTO
	AS VERIFICATION_TYPE, 
		CASE WHEN STATUS_CODE IN ('02', '03', '04') AND VERIFICATION_TYPE = 'Auto' AND EXCEPTION_REASON_INDICATOR = 'NO' THEN TRUE ELSE FALSE END 
	AS autoconfirm_cnt,
	COALESCE(SCH.COMMENTS, SV.COMMENTS) AS COMMENTS,
---
	ROW_NUMBER()over(PARTITION BY SV.AGENCYID, SV.CLIENTNUMBER, SV.STAFFAGENCYID, SV."DATE" ORDER BY NVL(CF_STATUS,'0') DESC,NVL(CN_STATUS,'0') DESC, SCH.CREATEDAT DESC, nvl(SCH.UPDATEDAT,'0') DESC ) 
	AS RNO 
-- Rno is to take Codes of only one of the non - cancelled split visit (A certain shift might be cancelled doesn't mean the whole visit is cancelled)
---
		FROM DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_SCHEDULES SCH 
		INNER JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_VISITS SV 
			ON SV.SCHEDULEID = SCH.SCHEDULEID 
			AND SV.AGENCYID = SCH.AGENCYID
		LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_REJECTIONCODES r 
			ON sch.REJECTIONCODE = r.code 
			AND sch.agencyid = r.AGENCYID
		WHERE SCH.agencyID IN ('38004','8380','8463') 										--IN,IL,MO
		AND sch.STATUS IN ('02','03','04')
		GROUP BY SV.AGENCYID, SV.CLIENTNUMBER,SV.ClientOtherID, SV.STAFFAGENCYID, SV."DATE", SCH.CREATEDAT,sv.createdat, SCH.UPDATEDAT,sv.updatedat, SCH.SCHEDULEID,
		SCH.CANCELREASON,SCH.CANCELREASONNOTES,SV.REASONCODEDESCRIPTION,SCH.RESOLUTIONCODE,SCH.REJECTIONCODE,r.DESCRIPTION,sch.EXCEPTIONCODE,sch.STATUS,sv.eventstatus, 
		sch.VERIFICATIONTYPE,SCH.COMMENTS,SV.COMMENTS
		QUALIFY RNO = 1
		ORDER BY SV.AGENCYID, SV.CLIENTNUMBER, SV.STAFFAGENCYID, SV."DATE",RNO
		)
, DF_IMPORT_VISITS AS 																-- Using only 1 record from multiple records per scheduleid just for mapping between DF and SD
(
SELECT ROW_NUMBER()OVER(PARTITION BY VISITKEY, TRACKINGID, WEEKENDDATE, STATE, SERVICEDATE ORDER BY IMPORTTASKID DESC, LINEID DESC) RNO,
		VISITKEY,
		split_part(VISITKEY, '_',  3)::NUMBER AS SCHEDULEID,
		split_part(VISITKEY, '_',  2) AS AGENCYID,
		TRACKINGID, WEEKENDDATE, STATE, SERVICEDATE 
FROM DISC_${var.SF_ENVIRONMENT}.SANDATAEXCHANGE.DFIMPORT_IMPORTVISITS 
WHERE ISIMPORTED = TRUE AND NVL(TRACKINGID,0) <> 0
QUALIFY RNO = 1					 
)
,CLIENT_DATA AS
(
	SELECT * FROM
	(
		SELECT TRIM(DBNAME) AS MASTER_DBNAME, "NUMBER" AS MASTER_CLIENT_NUMBER, TRIM(DBNAME) AS DBNAME, "NUMBER" AS CLIENT_NUMBER
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.CLIENT_MASTER_LIST
	)
	UNION
	SELECT * FROM
	(
		SELECT TRIM(MASTER.DBNAME) AS MASTER_DBNAME, MASTER."NUMBER" AS MASTER_CLIENT_NUMBER, TRIM(MATCH.DBNAME) AS DBNAME, MATCH."NUMBER" AS CLIENT_NUMBER
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.CLIENT_MATCH_LIST AS MATCH
        JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.CLIENT_MASTER_LIST AS MASTER 
            ON MASTER.MASTER_ID = MATCH.MASTER_ID
        WHERE MATCH.ID <> MATCH.MASTER_ID
	)
)
, EMPLOYEES AS 
(
	SELECT *,TO_DATE('1900-01-01', 'YYYY-MM-DD') AS EFFECTIVE_FROM_DATE, TO_DATE('9999-12-31', 'YYYY-MM-DD') AS EFFECTIVE_TO_DATE 
	FROM 
	(
		SELECT 
			TRIM(DBNAME) AS MASTER_DBNAME, 
			"NUMBER" AS MASTER_EMPLOYEE_NUMBER,
			TRIM(DBNAME) AS DBNAME, 
			"NUMBER" AS EMPLOYEE_NUMBER 
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.EMPLOYEE_MASTER_LIST
	) 
	UNION
	SELECT *,TO_DATE('1900-01-01', 'YYYY-MM-DD') AS EFFECTIVE_FROM_DATE, TO_DATE('9999-12-31', 'YYYY-MM-DD') AS EFFECTIVE_TO_DATE 
	FROM 
	(
		SELECT 
            TRIM(MASTER.DBNAME) AS MASTER_DBNAME, 
            MASTER."NUMBER" AS MASTER_EMPLOYEE_NUMBER, 
            TRIM(MATCH.DBNAME) AS DBNAME, 
            MATCH."NUMBER" AS EMPLOYEE_NUMBER
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.EMPLOYEE_MATCH_LIST AS MATCH
        JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.EMPLOYEE_MASTER_LIST AS MASTER
            ON MASTER.MASTER_ID = MATCH.MASTER_ID
        WHERE MATCH.ID <> MATCH.MASTER_ID
	)
)
,DS AS (																		-- To create Derived Statuses and status key to join wth Status_mapping table
SELECT 
	    f.DBNAME,F.REFERENCENO,f.SERVICEDATE,F.WEEKENDDATE,
	    CASE WHEN f.PAID = TRUE THEN '05'
		WHEN f.PAID = FALSE AND f.BILLED = TRUE THEN '04'
		ELSE '02'
		END AS STATUS1,
	    IFF(TS.PAIDFLAG = '',NULL,TS.PAIDFLAG) AS DISC_PAYROLL_STATUS,
        CASE WHEN f.SERVICEDATE::DATE <> COALESCE(MIN(SV.ADJUSTEDTIMEIN),f.SERVICEDATE)::DATE 
        	THEN 
        	CASE STATUS1 WHEN '02' THEN 'Rescheduled-Confirmed'
        				WHEN '04' THEN 'Rescheduled-Billed'
        				WHEN '05' THEN 'Rescheduled-Paid'
        				END
        WHEN STATUS1 = '02' THEN 'Confirmed'
        WHEN STATUS1 = '04' THEN 'Billed'
        WHEN STATUS1 = '05' THEN 'Paid'
        ELSE 'Unknown'
        END AS DERIVED_DISCSTATUS,														-- combined dataflex's AND sandata's statuses, taken DF's as preferred
        md5(3 ||'-'||F.DBNAME||'-'||nvl(DERIVED_DISCSTATUS,'Unknown')||'-'||nvl(DISC_PAYROLL_STATUS,'Unknown')) as VISIT_STATUSKEY
FROM DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFTIMESHEETS TS1 
LEFT JOIN DF_IMPORT_VISITS DFI 															-- ONLY IL AND MO CAN COME USING THIS JOIN FROM SANDATA
	ON TS1.TRACKINGID = DFI.TRACKINGID 
	AND TS1.WEEKENDDATE = DFI.WEEKENDDATE 
	AND TS1.DBNAME = DFI.STATE 
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_VISITS SV
	ON DFI.SCHEDULEID = SV.SCHEDULEID  
	AND DFI.AGENCYID = SV.AGENCYID
	AND TS1.clientnumber::varchar=SV.CLIENTOTHERID 
	AND DFI.SERVICEDATE = SV.DATE
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_SCHEDULES SCH 
	ON  DFI.SCHEDULEID = SCH.SCHEDULEID  
	AND DFI.AGENCYID = SCH.AGENCYID
	AND DFI.SERVICEDATE = SCH.SCHEDULEDATE
RIGHT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.HIST_DFTIMESHEETHOURS f
	ON f.DbName = ts1.DbName 
	AND f.ReferenceNo = ts1.ReferenceNo 
	AND f.WeekendDate = ts1.WeekendDate 
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = COALESCE(SV.DATE,SCH.SCHEDULEDATE),COALESCE(SV.DATE,SCH.SCHEDULEDATE),F.SERVICEDATE) -- ONLY JOIN ON servicedate WHEN mapping IS possible, otherwise will GET TS.DATA ONLY FOR visits mapped WITH sd AND rest will have NULL
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = DFI.SERVICEDATE,DFI.SERVICEDATE,NVL(DFI.SERVICEDATE,F.SERVICEDATE))					 --  To avoid getting 1 - many join between TSH and Mapping table DFI
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFTIMESHEETS TS 
ON TS.DBNAME = F.DBNAME 
AND TS.REFERENCENO = F.REFERENCENO 
AND F.WEEKENDDATE = TS.WEEKENDDATE																								 -- This join will only be used to get fields, the previous TS1 join's purpose is to just act as mapping between tables
where  (f.ETL_LAST_UPDATED_DATE >= '1900-01-01'
			OR ts.ETL_LAST_UPDATED_DATE >= '1900-01-01')
		AND f.ETL_DELETED_FLAG = TRUE
	AND CAST(f.ETL_LAST_UPDATED_DATE AS DATE) IN (SELECT CAST(MAX(ETL_LAST_UPDATED_DATE) AS DATE) FROM DISC_${var.SF_ENVIRONMENT}.DataFlexSyncData.HIST_DfTimeSheetHours)						  
GROUP BY F.DBNAME,F.REFERENCENO,F.SERVICEDATE,F.PAID,F.BILLED,TS.PAIDFLAG, F.WEEKENDDATE
	)
, DF AS 
(
	SELECT DISTINCT
	    MD5(f.DBNAME || '-' || f.REFERENCENO || '-' || f.WEEKENDDATE || '-' || f.SERVICEDATE || '-' || 'DATAFLEXSYNCDATA') AS VISIT_KEY,
	    f.SERVICEDATE AS REPORT_DATE,
		NULL AS INVOICE_KEY,
		NULL AS PAYROLL_KEY,
		NULL AS INVOICE_ID,
		NULL AS CHEQUE_NUMBER,
	    nvl(b2.BRANCH_KEY, md5(f.DBNAME || '-' || COALESCE(ts.OffceNo, -1) || '-' ||  'DATAFLEXSYNCDATA')) AS BRANCH_KEY,
	    md5(COALESCE(c2.MASTER_DBNAME, f.DBNAME) || '-' || COALESCE(c2.MASTER_CLIENT_NUMBER, ts.CLIENTNUMBER,-1) || '-'  ||  'DATAFLEXSYNCDATA' ) AS CLIENT_KEY,
	    nvl(n2.CONTRACT_KEY, md5(f.DBNAME || '-' || nvl(ts.CONTRACTCODE,'Unknown') || '-'  ||  'DATAFLEXSYNCDATA')) AS CONTRACT_KEY,
	    md5(COALESCE(e.MASTER_DBNAME, f.DBNAME) || '-' || UPPER(COALESCE(e.MASTER_EMPLOYEE_NUMBER, ts.EMPLOYEENUMBER, -1)) || '-'  ||  '1900-01-01' || '-' || 'DATAFLEXSYNCDATA') AS EMPLOYEE_KEY,
		EMPLOYEE_KEY AS SCHEDULED_EMPLOYEE_KEY,
	    3 AS SOURCE_SYSTEM_ID,
	    nvl(s2.SUPERVISOR_KEY, md5(f.DBNAME || '-'  || nvl(ts.SUPERVISORCODE,'Unknown-' || f.DBNAME) || '-'  || 'DATAFLEXSYNCDATA')) AS SUPERVISOR_KEY,
	    f.SERVICEDATE AS SERVICE_DATE,
		ts.payrolldate AS PAYROLL_DATE,
	    COALESCE(b.OfficeName, 'Unknown') AS BRANCH_NAME,
	    COALESCE(c2.MASTER_CLIENT_NUMBER,ts.CLIENTNUMBER, -1) AS CLIENT_NUMBER,
	    ts.CONTRACTCODE AS CONTRACT_CODE,
	    UPPER(COALESCE(e.MASTER_EMPLOYEE_NUMBER,ts.EMPLOYEENUMBER, -1)) as EMPLOYEE_ID,
		EMPLOYEE_ID AS SCHEDULED_EMPLOYEE_ID,
	    f.DBNAME AS SYSTEM_CODE, --BK
	    nvl(ts.SUPERVISORCODE,'-1') AS SUPERVISOR_CODE,
		COALESCE(MAX(ILMO.autoconfirm_cnt), MAX(IND.autoconfirm_cnt),IFF(TS.ISEVV = 'Y',TRUE,FALSE)) AS CLEAN_SHIFT_FLAG,
--=============================================================================================================================
STATUS_MAPPING.INVOICE_STATUS_NAME,
STATUS_MAPPING.INVOICE_STATUS_CODE,
STATUS_MAPPING.INVOICE_STATUS_DESCRIPTION,
--=============================================================================================================================
STATUS_MAPPING.VISIT_STATUS_NAME,
STATUS_MAPPING.VISIT_STATUS_CODE,
STATUS_MAPPING.VISIT_STATUS_DESCRIPTION,
--=============================================================================================================================
STATUS_MAPPING.SCHEDULE_STATUS_NAME,
STATUS_MAPPING.SCHEDULE_STATUS_CODE,
STATUS_MAPPING.SCHEDULE_STATUS_DESCRIPTION,
--=============================================================================================================================
STATUS_MAPPING.PAYROLL_STATUS_CODE,
STATUS_MAPPING.PAYROLL_STATUS_NAME,
STATUS_MAPPING.PAYROLL_STATUS_DESCRIPTION,
-------------------------------------------------------------------------------------------------------------------------------
	    MAX(COALESCE(ILMO.CANCEL_REASON_CODE, IND.CANCEL_REASON_CODE)) as CANCEL_REASON_CODE ,     												-- COMMENT 'Reason code for schedule cancellation', 	-- comes from Sandata
		MAX(COALESCE(ILMO.CANCEL_REASON_DESCRIPTION, IND.CANCEL_REASON_DESCRIPTION)) as CANCEL_REASON_DESCRIPTION ,
		MAX(COALESCE(ILMO.CANCEL_REASON_NOTES, IND.CANCEL_REASON_NOTES)) AS CANCEL_REASON_NOTES,
		MAX(COALESCE(ILMO.EXCEPTION_REASON_INDICATOR, IND.EXCEPTION_REASON_INDICATOR,'NO')) AS EXCEPTION_REASON_INDICATOR, 
		MAX(COALESCE(ILMO.RESOLUTION_CODE, IND.RESOLUTION_CODE)) AS RESOLUTION_CODE,
	    NULL AS RESOLUTION_DESCRIPTION,
		MAX(COALESCE(ILMO.REJECTION_CODE, IND.REJECTION_CODE)) AS REJECTION_CODE,							-- comes from Sandata
		MAX(COALESCE(ILMO.REJECTION_DESCRIPTION, IND.REJECTION_DESCRIPTION)) as REJECTION_DESCRIPTION,		-- Grouping by SD's fields would cause same visit key being repeated due to 1-many mapping for few visits, So aggregating it which won't affect data as only RNO = 1(1 RECORD) is being taken from code desc cte
		TS.BILLCODE as BILL_CODE,										
		COALESCE(Billrate_Contract.BILL_RATE,Billrate_Contract_Client.BILL_RATE,Billrate_Contract_billcode.BILL_RATE) AS BILL_RATE,
		NULL AS BILL_UNITS_SERVED, 
		--BC."TYPE"  AS BILL_UNIT_TYPE, 	-- ChecK DF BILL CODES - Not verified
		NULL AS BILL_UNIT_TYPE,
		SUM(Billrate_Contract_overheadrate.BILL_RATE)/COUNT(1) OVER 
			(PARTITION BY f.DBNAME,COALESCE(c2.MASTER_CLIENT_NUMBER,ts.CLIENTNUMBER, -1),ts.CONTRACTCODE,DATE_TRUNC('DAY',f.SERVICEDATE))
	   		AS Overhead_Rate,
	    --IFF(max(COALESCE(SV.AGENCYID,sch.agencyid,IND.DF_SYSTEM_CODE)) IS NOT null,f.SERVICEHOURS,SUM(F.SERVICEHOURS)) AS HOURS_SERVED,			-- DF already has summed hours when SD has >1 mapped visit
		f.SERVICEHOURS AS HOURS_SERVED,								  
	   MIN(COALESCE(SV.PROPOSEDSTART, SCH.PROPOSEDTIMEIN ))::TIME AS SCHEDULE_TIMEIN,					-- Few schedules not in sd_visits but they are there in sd_schedules
	    MAX(COALESCE(SV.PROPOSEDEND, SCH.PROPOSEDTIMEOUT ))::TIME AS SCHEDULE_TIMEOUT,
	    SUM(COALESCE(SV.PROPOSEDDURATION, SCH.PROPOSEDDURATION)) AS SCHEDULE_DURATION,
	    MIN(COALESCE(SV.TIMEIN, SCH.EVVTIMEIN, F.STARTTIME))::TIME AS ACTUAL_TIMEIN,
	    MAX(COALESCE(SV.TIMEOUT, SCH.EVVTIMEOUT,  F.ENDTIME))::TIME AS ACTUAL_TIMEOUT,
	    COALESCE(SUM(SV.ACTUALDURATION), SUM(SCH.EVVDURATION),  F.SERVICEHOURS) AS ACTUAL_DURATION,
	    MIN(COALESCE(SV.ADJUSTEDTIMEIN, F.STARTTIME))::TIME  AS ADJUSTED_TIMEIN,							-- Adjusted NOT available IN sandata_schedules table
	    MAX(COALESCE(SV.ADJUSTEDTIMEOUT, F.ENDTIME))::TIME  AS ADJUSTED_TIMEOUT,
	    COALESCE(SUM(SV.ADJUSTEDDURATION), F.SERVICEHOURS) AS ADJUSTED_DURATION,
		MAX(COALESCE(ILMO.COMMENTS, IND.COMMENTS)) AS COMMENTS,                     				-- comes from Sandata
		TS.ISEVV as IS_EVV_FLAG,                  													-- COMMENT 'Record came from EVV feed',	-- comes from DFTimeSheets
		TS.TIMESHEETTYPE as TIMESHEET_TYPE, 
		TS.TRACKINGID as TRACKING_ID ,
		STATUS_MAPPING.CONFIRMED_FLAG,
		-1 AS ETL_TASK_KEY,
		-1 AS ETL_INSERTED_TASK_KEY,
		convert_timezone('UTC', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_INSERTED_DATE,
	    CURRENT_USER as ETL_INSERTED_BY ,
	    convert_timezone('UTC', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_LAST_UPDATED_DATE,
	    CURRENT_USER as ETL_LAST_UPDATED_BY,
	    FALSE as ETL_DELETED_FLAG
FROM 
DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFTIMESHEETS TS1 
LEFT JOIN DF_IMPORT_VISITS DFI 																		-- ONLY IL AND MO CAN COME USING THIS JOIN FROM SANDATA
	ON TS1.TRACKINGID = DFI.TRACKINGID 
	AND TS1.WEEKENDDATE = DFI.WEEKENDDATE 
	AND TS1.DBNAME = DFI.STATE 
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_VISITS SV
	ON DFI.SCHEDULEID = SV.SCHEDULEID  
	AND DFI.AGENCYID = SV.AGENCYID
	AND TS1.clientnumber::varchar=SV.CLIENTOTHERID 
	AND DFI.SERVICEDATE = SV.DATE
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_SCHEDULES SCH 
	ON  DFI.SCHEDULEID = SCH.SCHEDULEID  
	AND DFI.AGENCYID = SCH.AGENCYID
	AND DFI.SERVICEDATE = SCH.SCHEDULEDATE
RIGHT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.HIST_DFTIMESHEETHOURS f
	ON f.DbName = ts1.DbName 
	AND f.ReferenceNo = ts1.ReferenceNo 
	AND f.WeekendDate = ts1.WeekendDate 
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = COALESCE(SV.DATE,SCH.SCHEDULEDATE),COALESCE(SV.DATE,SCH.SCHEDULEDATE),F.SERVICEDATE) -- ONLY JOIN ON servicedate WHEN mapping IS possible, otherwise will GET TS.DATA ONLY FOR visits mapped WITH sd AND rest will have NULL
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = DFI.SERVICEDATE,DFI.SERVICEDATE,NVL(DFI.SERVICEDATE,F.SERVICEDATE))					--  To avoid getting 1 - many join between TSH and Mapping table DFI
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFTIMESHEETS TS 															-- This join will only be used to get fields, the previous TS1 join's purpose is to just act as mapping between TABLES, using same TS table for both causes issues 
	ON TS.DBNAME = F.DBNAME AND TS.REFERENCENO = F.REFERENCENO AND F.WEEKENDDATE = TS.WEEKENDDATE
LEFT JOIN CODES_DESC ILMO ON
	ILMO.SCHEDULEID = SV.SCHEDULEID 
	AND ILMO.AGENCYID = SV.AGENCYID 
	AND ILMO.AGENCYID IN ('8380','8463')				-- IL and MO can be mapped so, joining by schid for more accuracy and in case of split visit in SD, will take latest non cancelled split visit's codes
LEFT JOIN CODES_DESC IND ON
	f.DBNAME = IND.DF_SYSTEM_CODE 
	AND F.DBNAME = 'IN'									-- IN cannot be mapped BY visit directly so joined BY client separately,
	AND ts.CLIENTNUMBER = IND.DF_Client_Number 
	AND f.SERVICEDATE::date = IND.DATE
LEFT JOIN DS ON 
	DS.DBNAME = F.DBNAME AND 
	DS.REFERENCENO = F.REFERENCENO AND 
	DS.SERVICEDATE = F.SERVICEDATE AND 
	DS.WEEKENDDATE = F.WEEKENDDATE	 
LEFT JOIN HAH.DIM_VISIT_STATUS_MAPPING STATUS_MAPPING ON 
	STATUS_MAPPING.VISIT_STATUS_KEY = DS.VISIT_STATUSKEY								  
LEFT JOIN EMPLOYEES e 
	ON TRIM(ts.EMPLOYEENUMBER) = e.EMPLOYEE_NUMBER 
	AND ts.DBNAME = e.DBNAME 
	AND f.SERVICEDATE >= e.EFFECTIVE_FROM_DATE 
	AND f.SERVICEDATE < e.EFFECTIVE_TO_DATE
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DataFlexSyncData.DfOffices b 
	ON ts.OFFCENO = b.OfficeNumber 
	AND ts.DBNAME = b.DBNAME
LEFT JOIN HAH.DIM_BRANCH b2 
	ON b2.BRANCH_NAME = COALESCE(b.OfficeName, 'Unknown') 
	AND b2.SYSTEM_CODE = b.DBNAME
LEFT JOIN CLIENT_DATA c2 
	ON c2.CLIENT_NUMBER = ts.CLIENTNUMBER 
	AND c2.DBNAME = ts.DBNAME
LEFT JOIN HAH.DIM_CONTRACT n2 
	ON n2.CONTRACT_CODE = ts.CONTRACTCODE 
	AND n2.SYSTEM_CODE = ts.DBNAME
LEFT JOIN HAH.DIM_SUPERVISOR s2 
	ON s2.SUPERVISOR_CODE = ts.SUPERVISORCODE 
	AND s2.SYSTEM_CODE = ts.DBNAME
	--LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFBILLCODES BC ON TS.BILLCODE = BC.BILLCODE AND BC.DBNAME = TS.DBNAME
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract 
	on Billrate_Contract.dbname = f.dbname 
	and ts.CONTRACTCODE = Billrate_Contract.CONTRACT_CODE 
	and f.SERVICEDATE between Billrate_Contract.EFFECTIVE_FROM_DATE and NVL(Billrate_Contract.EFFECTIVE_TO_DATE,CURRENT_DATE) 
	and Billrate_Contract.BILL_RATE_LEVEL = 'contract'
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_Client 
	on Billrate_Contract_Client.dbname = f.dbname
	and ts.CONTRACTCODE = Billrate_Contract_Client.CONTRACT_CODE
	and ts.CLIENTNUMBER = Billrate_Contract_Client.CLIENT_NUMBER
	and ts.BILLCODE = Billrate_Contract_Client.Bill_Code
	and f.SERVICEDATE  between Billrate_Contract_Client.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_Client.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_Client.BILL_RATE_LEVEL = 'clientnumber'
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_billcode 
	on Billrate_Contract_billcode.dbname = f.dbname
	and ts.CONTRACTCODE = Billrate_Contract_billcode.CONTRACT_CODE
	and ts.BILLCODE  = Billrate_Contract_billcode.Bill_Code
	and f.SERVICEDATE between Billrate_Contract_billcode.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_billcode.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_billcode.BILL_RATE_LEVEL = 'BILLCODE'
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_overheadrate 
	on Billrate_Contract_overheadrate.dbname = f.dbname
	and ts.CONTRACTCODE = Billrate_Contract_overheadrate.CONTRACT_CODE
	and f.SERVICEDATE between Billrate_Contract_overheadrate.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_overheadrate.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_overheadrate.BILL_RATE_LEVEL = 'OVERHEADRATE'
where  (f.ETL_LAST_UPDATED_DATE >= '1900-01-01'::timestamp_ntz
			OR ts.ETL_LAST_UPDATED_DATE >= '1900-01-01'::timestamp_ntz)
		AND f.ETL_DELETED_FLAG = TRUE
	AND CAST(f.ETL_LAST_UPDATED_DATE AS DATE) IN (SELECT CAST(MAX(ETL_LAST_UPDATED_DATE) AS DATE) FROM DISC_${var.SF_ENVIRONMENT}.DataFlexSyncData.HIST_DfTimeSheetHours)	
GROUP BY VISIT_KEY,F.PAID,F.BILLED,TS.PAIDFLAG,REPORT_DATE,BRANCH_KEY,CLIENT_KEY,CONTRACT_KEY,EMPLOYEE_KEY,SCHEDULED_EMPLOYEE_KEY,SUPERVISOR_KEY,SERVICE_DATE,
	PAYROLL_DATE, BRANCH_NAME, B.OFFICENAME, TS.OFFCENO, c2.MASTER_CLIENT_NUMBER, ts.CLIENTNUMBER, TS.CONTRACTCODE, e.MASTER_EMPLOYEE_NUMBER, ts.EMPLOYEENUMBER
	, f.DBNAME, TS.SUPERVISORCODE, TS.BILLCODE, Billrate_Contract.BILL_RATE, Billrate_Contract_Client.BILL_RATE
	, Billrate_Contract_billcode.BILL_RATE, IS_EVV_FLAG, TIMESHEET_TYPE	, TS.TRACKINGID , f.SERVICEHOURS ,DS.STATUS1,STATUS_MAPPING.INVOICE_STATUS_NAME,
STATUS_MAPPING.INVOICE_STATUS_CODE, STATUS_MAPPING.INVOICE_STATUS_DESCRIPTION, STATUS_MAPPING.VISIT_STATUS_NAME, STATUS_MAPPING.VISIT_STATUS_CODE,
STATUS_MAPPING.VISIT_STATUS_DESCRIPTION,STATUS_MAPPING.SCHEDULE_STATUS_NAME,STATUS_MAPPING.SCHEDULE_STATUS_CODE,STATUS_MAPPING.SCHEDULE_STATUS_DESCRIPTION,
STATUS_MAPPING.PAYROLL_STATUS_CODE,STATUS_MAPPING.PAYROLL_STATUS_NAME,STATUS_MAPPING.PAYROLL_STATUS_DESCRIPTION, STATUS_MAPPING.CONFIRMED_FLAG 
)
,SD AS
(SELECT * FROM HAH.FACT_VISIT WHERE SOURCE_SYSTEM_ID = 3 AND SYSTEM_CODE IN ('IL - 8380','MO - 8463') 
AND VISIT_KEY NOT IN (SELECT VISIT_KEY FROM DISC_${var.SF_ENVIRONMENT}.PUBLIC.VW_DATAFLEX_SANDATA_PENDING_VISITS))
, FINAL AS 
(
	SELECT L.*
	FROM (
		SELECT VISIT_KEY,	REPORT_DATE, BRANCH_KEY, CLIENT_KEY, CONTRACT_KEY, SCHEDULED_EMPLOYEE_KEY, EMPLOYEE_KEY, 
SOURCE_SYSTEM_ID, SUPERVISOR_KEY, INVOICE_KEY, PAYROLL_KEY,	SERVICE_DATE, PAYROLL_DATE,	BRANCH_NAME, CLIENT_NUMBER, CONTRACT_CODE, SCHEDULED_EMPLOYEE_ID, EMPLOYEE_ID, 
SYSTEM_CODE, SUPERVISOR_CODE, INVOICE_ID, CHEQUE_NUMBER, CLEAN_SHIFT_FLAG, SCHEDULE_STATUS_NAME, SCHEDULE_STATUS_CODE, SCHEDULE_STATUS_DESCRIPTION,	VISIT_STATUS_NAME, 
VISIT_STATUS_CODE, VISIT_STATUS_DESCRIPTION, INVOICE_STATUS_NAME, INVOICE_STATUS_CODE, INVOICE_STATUS_DESCRIPTION, PAYROLL_STATUS_NAME,	PAYROLL_STATUS_CODE, 
PAYROLL_STATUS_DESCRIPTION,	CANCEL_REASON_CODE,	CANCEL_REASON_DESCRIPTION, CANCEL_REASON_NOTES,	EXCEPTION_REASON_INDICATOR,	RESOLUTION_CODE, RESOLUTION_DESCRIPTION, 
REJECTION_CODE,	REJECTION_DESCRIPTION, BILL_CODE, BILL_RATE, BILL_UNITS_SERVED, BILL_UNIT_TYPE,	OVERHEAD_RATE, SCHEDULE_TIMEIN,	SCHEDULE_TIMEOUT, SCHEDULE_DURATION, 
ACTUAL_TIMEIN, ACTUAL_TIMEOUT, ACTUAL_DURATION,	ADJUSTED_TIMEIN, ADJUSTED_TIMEOUT, ADJUSTED_DURATION, HOURS_SERVED,	COMMENTS, IS_EVV_FLAG, TIMESHEET_TYPE, TRACKING_ID, 
ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_DATE,	ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE,	ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, CONFIRMED_FLAG FROM DF
		UNION ALL 
		SELECT VISIT_KEY,	REPORT_DATE, BRANCH_KEY, CLIENT_KEY, CONTRACT_KEY, SCHEDULED_EMPLOYEE_KEY, EMPLOYEE_KEY, 
SOURCE_SYSTEM_ID, SUPERVISOR_KEY, INVOICE_KEY, PAYROLL_KEY,	SERVICE_DATE, PAYROLL_DATE,	BRANCH_NAME, CLIENT_NUMBER, CONTRACT_CODE, SCHEDULED_EMPLOYEE_ID, EMPLOYEE_ID, 
SYSTEM_CODE, SUPERVISOR_CODE, INVOICE_ID, CHEQUE_NUMBER, CLEAN_SHIFT_FLAG, SCHEDULE_STATUS_NAME, SCHEDULE_STATUS_CODE, SCHEDULE_STATUS_DESCRIPTION,	VISIT_STATUS_NAME, 
VISIT_STATUS_CODE, VISIT_STATUS_DESCRIPTION, INVOICE_STATUS_NAME, INVOICE_STATUS_CODE, INVOICE_STATUS_DESCRIPTION, PAYROLL_STATUS_NAME,	PAYROLL_STATUS_CODE, 
PAYROLL_STATUS_DESCRIPTION,	CANCEL_REASON_CODE,	CANCEL_REASON_DESCRIPTION, CANCEL_REASON_NOTES,	EXCEPTION_REASON_INDICATOR,	RESOLUTION_CODE, RESOLUTION_DESCRIPTION, 
REJECTION_CODE,	REJECTION_DESCRIPTION, BILL_CODE, BILL_RATE, BILL_UNITS_SERVED, BILL_UNIT_TYPE,	OVERHEAD_RATE, SCHEDULE_TIMEIN,	SCHEDULE_TIMEOUT, SCHEDULE_DURATION, 
ACTUAL_TIMEIN, ACTUAL_TIMEOUT, ACTUAL_DURATION,	ADJUSTED_TIMEIN, ADJUSTED_TIMEOUT, ADJUSTED_DURATION, HOURS_SERVED,	COMMENTS, IS_EVV_FLAG, TIMESHEET_TYPE, TRACKING_ID, 
ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_DATE,	ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE,	ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, CONFIRMED_FLAG FROM SD ) L
LEFT JOIN HAH.FACT_SYSTEM_CUTOVER_DATE AS CUTOVER ON CUTOVER.SOURCE_SYSTEM_ID = L.SOURCE_SYSTEM_ID 
	AND CUTOVER.SYSTEM_CODE = L.SYSTEM_CODE
	AND NVL(CUTOVER.BRANCH_KEY, L.BRANCH_KEY) = L.BRANCH_KEY
	AND NVL(CUTOVER.CONTRACT_KEY, L.CONTRACT_KEY) = L.CONTRACT_KEY
WHERE L.SERVICE_DATE BETWEEN NVL(CUTOVER.START_DATE, L.SERVICE_DATE) AND NVL(CUTOVER.END_DATE, L.SERVICE_DATE)
)
SELECT VISIT_KEY FROM FINAL;
SQL
	or_replace = true 
	is_secure = false 
}

