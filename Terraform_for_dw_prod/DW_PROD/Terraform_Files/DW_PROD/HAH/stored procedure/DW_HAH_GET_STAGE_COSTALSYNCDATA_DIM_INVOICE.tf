resource "snowflake_procedure" "DW_HAH_GET_STAGE_COSTALSYNCDATA_DIM_INVOICE" {
	name ="GET_STAGE_COSTALSYNCDATA_DIM_INVOICE"
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "HAH"
	language  = "SQL"

	arguments {
		name = "STR_ETL_TASK_KEY"
		type = "VARCHAR(16777216)"
}	

	arguments {
		name = "STR_CDC_START"
		type = "VARCHAR(16777216)"
}	

	arguments {
		name = "STR_CDC_END"
		type = "VARCHAR(16777216)"
}	
	return_type = "VARCHAR(16777216)"
	execute_as = "OWNER"
	statement = <<-EOT

DECLARE
    return_result VARCHAR;
BEGIN
    --*****************************************************************************************************************************
-- NAME:  CostalSyncData_DIM_INVOICE
--
-- PURPOSE: Creates one row per INVOICE according to CostalSyncData
--
-- NOTE:
--
-- DEVELOPMENT LOG:
-- DATE        AUTHOR                NOTES:
-- --------    -------------------   -----------------------------------------------------------------------------------------------
-- 02/24/20    Mohd Kamaludin        Initial development
-- 03/18/20    Frank Noordover       Updated for Production rollout
-- 04/01/20		Mohd Kamaludin		 Updated CDC logic
-- 21/04/2023 	PINKAL PANCHAL 		 ADDED INVOICE_STATUS_MAPPING FOR RCM
--*****************************************************************************************************************************
--
INSERT OVERWRITE INTO STAGE.CostalSyncData_DIM_INVOICE
WITH inv_list AS (
	SELECT DISTINCT db, bill_number
	FROM DISC_${var.SF_ENVIRONMENT}.COSTALSYNCDATA.CV_BILLINGDATA bil
	WHERE bil.ETL_LAST_UPDATED_DATE >= :STR_CDC_START::timestamp_ntz
),
INVOICE_STATUS_MAPPING AS 
(
SELECT  DISTINCT
	inv.BILL_NUMBER
    ,CASE inv.DB WHEN ''SHC_ALTRUS'' THEN 1 WHEN ''SHC_SAVANNAH'' THEN 2 ELSE -1 END  AS SOURCE_SYSTEM_ID
	,inv.DB as SYSTEM_CODE 
    , CASE WHEN MAX(BILL_AMOUNT) /* AMOUNT_BILLED */ = SUM( CASE WHEN LEFT(PAYMENT_CODE, 1) NOT IN (''9'', ''8'') THEN PAID_AMOUNT ELSE 0 END ) /* AMOUNT_COLLECTED */
    		THEN ''PAID''
    	WHEN SUM( CASE WHEN LEFT(PAYMENT_CODE, 1) NOT IN (''9'', ''8'') THEN PAID_AMOUNT ELSE 0 END ) > 0 THEN ''PARTIAL PAY'' 
    	WHEN COUNT(CASE WHEN CLAIM_STATUS = 0 THEN 1 END) > 0 AND COUNT(CASE WHEN CLAIM_STATUS = 1 THEN 1 END) > 0 THEN ''UNKNOWN''
    	WHEN COUNT(CASE WHEN CLAIM_STATUS = 0 THEN 1 END) > 0 AND COUNT(CASE WHEN CLAIM_STATUS = 1 THEN 1 END) = 0 THEN ''BILLED''
    	WHEN COUNT(CASE WHEN CLAIM_STATUS = 0 THEN 1 END) = 0 AND COUNT(CASE WHEN CLAIM_STATUS = 1 THEN 1 END) > 0 THEN ''UNBILLED''
    	ELSE ''UNKNOWN'' END AS DERIVED_INVOICE_STATUS
   ,MD5(SOURCE_SYSTEM_ID || ''-'' || DERIVED_INVOICE_STATUS || ''-'' || SYSTEM_CODE ) AS INVOICE_STATUS_KEY
FROM DISC_${var.SF_ENVIRONMENT}.COSTALSYNCDATA.CV_BILLINGDATA inv
GROUP BY inv.BILL_NUMBER,inv.DB
)
SELECT --TOP 100
      md5(inv.db ||''-''|| inv.BILL_NUMBER ||''-''|| ''COSTALSYNCDATA'') AS INVOICE_KEY --PK
    , MD5(inv.DB || ''-'' || TRIM(INV.PATIENT_NUMBER) || ''-'' || ''COSTALSYNCDATA'') AS CLIENT_KEY
    , inv.BILL_NUMBER AS INVOICE_NUMBER --BK
    , NULL AS PERIOD
    , ''Regular'' AS INVOICE_TYPE
    , 1 AS NUMBER_OF_CLIENTS
    , inv.DB as SYSTEM_CODE --BI
    , CASE inv.DB WHEN ''SHC_ALTRUS'' THEN 1 WHEN ''SHC_SAVANNAH'' THEN 2 ELSE -1 END AS SOURCE_SYSTEM_ID --BK
    , MD5(INV.DB || ''-'' || TRIM(INV.LOCATION_CODE) || ''-'' || ''COSTALSYNCDATA'') AS BRANCH_KEY
    , NULL AS PAYOR_CODE
    , NULL AS PAYOR_NAME
    , CASE WHEN MAX(BILL_AMOUNT) - MAX(PAYMENT_AMOUNT) - MAX(ADJUSTMENT_AMOUNT) > 0 THEN TRUE ELSE FALSE END AS INVOICE_OPEN_FLAG
    , MIN(inv.BILL_DATE) AS FIRST_INVOICE_DATE
    , IFF(MAX(BILL_AMOUNT) - MAX(PAYMENT_AMOUNT) - MAX(ADJUSTMENT_AMOUNT) = 0, MAX(inv.PAYMENT_DATE), NULL) AS FINAL_PAYMENT_DATE
    , inv.BILL_NUMBER AS FIRST_INVOICE_NUMBER
    , 1 AS BILL_ITERATION
    , NULL AS BILL_REPRESENTATIVE
    , NULL AS BILL_SUPERVISOR
    , NULL AS BILL_MANAGER
--    , ''Unknown'' AS INVOICE_STATUS
--    , CASE WHEN MAX(BILL_AMOUNT) /* AMOUNT_BILLED */ = SUM( CASE WHEN LEFT(PAYMENT_CODE, 1) NOT IN (''9'', ''8'') THEN PAID_AMOUNT ELSE 0 END ) /* AMOUNT_COLLECTED */
--    		THEN ''Fully Paid''
--    	WHEN SUM( CASE WHEN LEFT(PAYMENT_CODE, 1) NOT IN (''9'', ''8'') THEN PAID_AMOUNT ELSE 0 END ) > 0 THEN ''Partially paid'' 
--    	WHEN COUNT(CASE WHEN CLAIM_STATUS = 0 THEN 1 END) > 0 AND COUNT(CASE WHEN CLAIM_STATUS = 1 THEN 1 END) > 0 THEN ''Partially billed''
--    	WHEN COUNT(CASE WHEN CLAIM_STATUS = 0 THEN 1 END) > 0 AND COUNT(CASE WHEN CLAIM_STATUS = 1 THEN 1 END) = 0 THEN ''Billed''
--    	WHEN COUNT(CASE WHEN CLAIM_STATUS = 0 THEN 1 END) = 0 AND COUNT(CASE WHEN CLAIM_STATUS = 1 THEN 1 END) > 0 THEN ''Unbilled''
--    	ELSE ''Unknown'' END AS INVOICE_STATUS
--	CHANGES MADE ON 30/03/23 FOR INVOICE_STATUS_MAPPING BY PINKAL
	, DISM.DERIVED_INVOICE_STATUS AS INVOICE_STATUS
    , IFF(SUM(APPROVED_WRITEOFF_AMOUNT) > 0, TRUE, FALSE) AS WRITEOFF_FLAG
    , NULL AS WRITEOFF_REASON
    , MAX(BILL_AMOUNT) AS AMOUNT_BILLED
    , SUM( CASE WHEN LEFT(PAYMENT_CODE, 1) NOT IN (''9'', ''8'') THEN PAID_AMOUNT ELSE 0 END ) AS AMOUNT_COLLECTED
    , MAX(BILL_AMOUNT) - MAX(PAYMENT_AMOUNT) - MAX(ADJUSTMENT_AMOUNT) AS AMOUNT_OUTSTANDING
    , MIN(inv.SERVICE_DATE) AS EFFECTIVE_FROM_DATE
    , MAX(inv.SERVICE_DATE) AS EFFECTIVE_TO_DATE
    ,
        ---- ETL FIELDS ___
    :STR_ETL_TASK_KEY AS ETL_TASK_KEY,
    :STR_ETL_TASK_KEY AS ETL_INSERTED_TASK_KEY,
    convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_INSERTED_DATE,
    CURRENT_USER as ETL_INSERTED_BY,
    convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_LAST_UPDATED_DATE,
    CURRENT_USER as ETL_LAST_UPDATED_BY,
    0 as ETL_DELETED_FLAG,
    0 AS ETL_INFERRED_MEMBER_FLAG
FROM DISC_${var.SF_ENVIRONMENT}.COSTALSYNCDATA.CV_BILLINGDATA inv
JOIN inv_list lis ON inv.db = lis.db AND inv.bill_number = lis.bill_number
LEFT JOIN INVOICE_STATUS_MAPPING ISM ON ISM.BILL_NUMBER = inv.BILL_NUMBER AND ISM.SYSTEM_CODE = INV.DB
LEFT JOIN HAH.DIM_INVOICE_STATUS_MAPPING DISM ON DISM.INVOICE_STATUS_KEY = ISM.INVOICE_STATUS_KEY
GROUP BY inv.DB, inv.BILL_NUMBER, DISM.DERIVED_INVOICE_STATUS, inv.PATIENT_NUMBER, inv.LOCATION_CODE;

    SELECT CONCAT(''Message : '',"number of rows inserted",'' Rows Inserted.'') into :return_result FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
    return return_result;
END;
    
 EOT
}

