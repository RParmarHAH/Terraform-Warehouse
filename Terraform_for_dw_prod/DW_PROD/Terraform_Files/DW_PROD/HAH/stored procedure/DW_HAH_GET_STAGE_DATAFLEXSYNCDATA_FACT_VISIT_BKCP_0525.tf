resource "snowflake_procedure" "DW_HAH_GET_STAGE_DATAFLEXSYNCDATA_FACT_VISIT_BKCP_0525" {
	name ="GET_STAGE_DATAFLEXSYNCDATA_FACT_VISIT_BKCP_0525"
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "HAH"
	language  = "SQL"

	arguments {
		name = "STR_ETL_TASK_KEY"
		type = "VARCHAR(16777216)"
}	

	arguments {
		name = "STR_CDC_START"
		type = "VARCHAR(16777216)"
}	

	arguments {
		name = "STR_CDC_END"
		type = "VARCHAR(16777216)"
}	
	return_type = "VARCHAR(16777216)"
	execute_as = "OWNER"
	statement = <<-EOT

DECLARE
    return_result VARCHAR;
BEGIN
--*****************************************************************************************************************************
-- NAME:  DataFlexSyncData_FACT_VISIT
--
-- PURPOSE: Creates one row per VISIT according to Dataflexsync
-- 02/04/20    Greg Marsh           Initial development
-- 03/03/20    Rachel Stewart       Removed duplicates by adding additional keys and group by function
-- 03/03/20    Mohd Kamaludin       Updated Clean Shift logic to pull from Sandata Schedules
-- 03/11/20    Rachel Stewart       Restored 3/10 version
-- 03/12/20    Rachel Stewart       Added CDC check
-- 04/01/20    Mohd Kamaludin       Added CDC
-- 04/30/20    Mohd Kamaludin       Updated Visit Key definition and Added Status Code and Status Description
-- 05/09/20    Frank Noordover      Fixed dfoffices join logic to join to visit versus to client
-- 09/27/20    Prachi Shah	    	Added logic of OVERHEADRATE
-- 06/10/20    Prachi Shah	    	Added Payroll Date
-- 01/05/20    Mir Ali              Changed Branch_Key to consist of Office_Code not OfficeName
-- 02/24/21    Devansh Patel	    Added exception, rejection and cancel fields; added bill code
-- 04/04/22		Mir Ali				Added cutover logic for Alayacare
-- 09/06/22    Devansh Patel/		Schedule Information/Re-work exception, rejection, cancel fields
--			   Saurav Purohit       Added join with Sandata using dfimport table, Updated Status fields
-- 10/03/22		Abhishek Sunil		Leveraged History tables to display (2013-2017) deleted timesheets data
-- 04/21/23		Saurav Purohit		Added logic to pull Non - Confirmed Visits/Future Schedules from Sandata - (For detailed note, refer code on Github)
--*****************************************************************************************************************************
INSERT OVERWRITE INTO STAGE.DATAFLEXSYNCDATA_FACT_VISIT_KBCP_0525 (VISIT_KEY,	REPORT_DATE, BRANCH_KEY, CLIENT_KEY, CONTRACT_KEY, SCHEDULED_EMPLOYEE_KEY, EMPLOYEE_KEY, 
SOURCE_SYSTEM_ID, SUPERVISOR_KEY, INVOICE_KEY, PAYROLL_KEY,	SERVICE_DATE, PAYROLL_DATE,	BRANCH_NAME, CLIENT_NUMBER, CONTRACT_CODE, SCHEDULED_EMPLOYEE_ID, EMPLOYEE_ID, 
SYSTEM_CODE, SUPERVISOR_CODE, INVOICE_ID, CHEQUE_NUMBER, CLEAN_SHIFT_FLAG, SCHEDULE_STATUS_NAME, SCHEDULE_STATUS_CODE, SCHEDULE_STATUS_DESCRIPTION,	VISIT_STATUS_NAME, 
VISIT_STATUS_CODE, VISIT_STATUS_DESCRIPTION, INVOICE_STATUS_NAME, INVOICE_STATUS_CODE, INVOICE_STATUS_DESCRIPTION, PAYROLL_STATUS_NAME,	PAYROLL_STATUS_CODE, 
PAYROLL_STATUS_DESCRIPTION,	CANCEL_REASON_CODE,	CANCEL_REASON_DESCRIPTION, CANCEL_REASON_NOTES,	EXCEPTION_REASON_INDICATOR,	RESOLUTION_CODE, RESOLUTION_DESCRIPTION, 
REJECTION_CODE,	REJECTION_DESCRIPTION, BILL_CODE, BILL_RATE, BILL_UNITS_SERVED, BILL_UNIT_TYPE,	OVERHEAD_RATE, SCHEDULE_TIMEIN,	SCHEDULE_TIMEOUT, SCHEDULE_DURATION, 
ACTUAL_TIMEIN, ACTUAL_TIMEOUT, ACTUAL_DURATION,	ADJUSTED_TIMEIN, ADJUSTED_TIMEOUT, ADJUSTED_DURATION, HOURS_SERVED,	COMMENTS, IS_EVV_FLAG, TIMESHEET_TYPE, TRACKING_ID, 
ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_DATE,	ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE,	ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, CONFIRMED_FLAG )
WITH 
CODES_DESC AS (													
																	-- GENERAL Note: sandata_schedules have MORE updated DATA than sandata_visits
																	-- SD have visits split into more than one sometimes, whose total hours are equal with hours in mapped DF visit
SELECT SV.agencyID,
		CASE WHEN SV.agencyID = ''38004'' THEN ''IN''
             WHEN SV.agencyID = ''8380'' THEN ''IL''
             WHEN SV.agencyID = ''8463'' THEN ''MO''
            ELSE ''UK'' END 
    AS DF_SYSTEM_CODE,
		CASE WHEN try_to_numeric(SV.ClientOtherID) is null THEN -1 ELSE SV.ClientOtherID END::INTEGER 
	AS DF_Client_Number,   
    SV.STAFFAGENCYID,
    SV."DATE",
    SCH.SCHEDULEID, --7
	SCH.CANCELREASON AS CANCEL_REASON_CODE,	
	SCH.CANCELREASONNOTES AS CANCEL_REASON_NOTES,
	SV.REASONCODEDESCRIPTION AS CANCEL_REASON_DESCRIPTION,
	SCH.RESOLUTIONCODE AS RESOLUTION_CODE, 
	SCH.REJECTIONCODE AS REJECTION_CODE, 
	r.DESCRIPTION as REJECTION_DESCRIPTION,
	sch.EXCEPTIONCODE AS EXCEPTION_CODE,
		CASE WHEN NVL(EXCEPTION_CODE,''0'') NOT IN ('''',''0'') THEN ''YES'' ELSE ''NO'' END 
	AS EXCEPTION_REASON_INDICATOR,
	IFF(sch.STATUS IN (''02'',''03'',''04''),sch.STATUS,NULL) AS CF_STATUS,
	IFF(sch.STATUS IN (''01'',''09'',''10''),sch.STATUS,NULL) AS CN_STATUS,
	IFF(NVL(SCH.UPDATEDAT,SCH.CREATEDAT) >= NVL(SV.UPDATEDAT,SV.CREATEDAT),sch.STATUS,SV.EVENTSTATUS) AS STATUS_CODE,  								--- TAKING STATUS OF NON CANCELLED SPLIT VISIT
		first_value(sch.VERIFICATIONTYPE)over(PARTITION BY SV.AGENCYID, SV.CLIENTNUMBER, SV.STAFFAGENCYID, SV."DATE" ORDER BY sch.VERIFICATIONTYPE) -- IF ONE SPLIT VISIT IS AUTO THEN CONSIDER WHOLE VISIT AS AUTO
	AS VERIFICATION_TYPE, 
		CASE WHEN STATUS_CODE IN (''02'', ''03'', ''04'') AND VERIFICATION_TYPE = ''Auto'' AND EXCEPTION_REASON_INDICATOR = ''NO'' THEN TRUE ELSE FALSE END 
	AS autoconfirm_cnt,
	COALESCE(SCH.COMMENTS, SV.COMMENTS) AS COMMENTS,
---
	ROW_NUMBER()over(PARTITION BY SV.AGENCYID, SV.CLIENTNUMBER, SV.STAFFAGENCYID, SV."DATE" ORDER BY NVL(CF_STATUS,''0'') DESC,NVL(CN_STATUS,''0'') DESC, SCH.CREATEDAT DESC, nvl(SCH.UPDATEDAT,''0'') DESC ) 
	AS RNO 
-- Rno is to take Codes of only one of the non - cancelled split visit (A certain shift might be cancelled doesn''t mean the whole visit is cancelled)
---
		FROM DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_SCHEDULES SCH 
		INNER JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_VISITS SV 
			ON SV.SCHEDULEID = SCH.SCHEDULEID 
			AND SV.AGENCYID = SCH.AGENCYID
		LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_REJECTIONCODES r 
			ON sch.REJECTIONCODE = r.code 
			AND sch.agencyid = r.AGENCYID
		WHERE SCH.agencyID IN (''38004'',''8380'',''8463'') 								--IN,IL,MO
		AND sch.STATUS IN (''02'',''03'',''04'')
		GROUP BY SV.AGENCYID, SV.CLIENTNUMBER,SV.ClientOtherID, SV.STAFFAGENCYID, SV."DATE", SCH.CREATEDAT,sv.createdat, SCH.UPDATEDAT,sv.updatedat, SCH.SCHEDULEID,
		SCH.CANCELREASON,SCH.CANCELREASONNOTES,SV.REASONCODEDESCRIPTION,SCH.RESOLUTIONCODE,SCH.REJECTIONCODE,r.DESCRIPTION,sch.EXCEPTIONCODE,sch.STATUS,sv.eventstatus, 
		sch.VERIFICATIONTYPE,SCH.COMMENTS,SV.COMMENTS
		QUALIFY RNO = 1
		ORDER BY SV.AGENCYID, SV.CLIENTNUMBER, SV.STAFFAGENCYID, SV."DATE",RNO
		)
, DF_IMPORT_VISITS AS 												-- Using only 1 record from multiple records per scheduleid just for mapping between DF and SD
(
SELECT ROW_NUMBER()OVER(PARTITION BY VISITKEY, TRACKINGID, WEEKENDDATE, STATE, SERVICEDATE ORDER BY IMPORTTASKID DESC, LINEID DESC) RNO,
		VISITKEY,
		split_part(VISITKEY, ''_'',  3)::NUMBER AS SCHEDULEID,
		split_part(VISITKEY, ''_'',  2) AS AGENCYID,
		TRACKINGID, WEEKENDDATE, STATE, SERVICEDATE 
FROM DISC_${var.SF_ENVIRONMENT}.SANDATAEXCHANGE.DFIMPORT_IMPORTVISITS 
WHERE ISIMPORTED = TRUE AND NVL(TRACKINGID,0) <> 0
QUALIFY RNO = 1			   
)
,CLIENT_DATA AS
(
	SELECT * FROM
	(
		SELECT TRIM(DBNAME) AS MASTER_DBNAME, "NUMBER" AS MASTER_CLIENT_NUMBER, TRIM(DBNAME) AS DBNAME, "NUMBER" AS CLIENT_NUMBER
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.CLIENT_MASTER_LIST
	)
	UNION
	SELECT * FROM
	(
		SELECT TRIM(MASTER.DBNAME) AS MASTER_DBNAME, MASTER."NUMBER" AS MASTER_CLIENT_NUMBER, TRIM(MATCH.DBNAME) AS DBNAME, MATCH."NUMBER" AS CLIENT_NUMBER
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.CLIENT_MATCH_LIST AS MATCH
        JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.CLIENT_MASTER_LIST AS MASTER 
            ON MASTER.MASTER_ID = MATCH.MASTER_ID
        WHERE MATCH.ID <> MATCH.MASTER_ID
	)
)
, EMPLOYEES AS 
(
	SELECT *,TO_DATE(''1900-01-01'', ''YYYY-MM-DD'') AS EFFECTIVE_FROM_DATE, TO_DATE(''9999-12-31'', ''YYYY-MM-DD'') AS EFFECTIVE_TO_DATE 
	FROM 
	(
		SELECT 
			TRIM(DBNAME) AS MASTER_DBNAME, 
			"NUMBER" AS MASTER_EMPLOYEE_NUMBER,
			TRIM(DBNAME) AS DBNAME, 
			"NUMBER" AS EMPLOYEE_NUMBER 
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.EMPLOYEE_MASTER_LIST
	) 
	UNION
	SELECT *,TO_DATE(''1900-01-01'', ''YYYY-MM-DD'') AS EFFECTIVE_FROM_DATE, TO_DATE(''9999-12-31'', ''YYYY-MM-DD'') AS EFFECTIVE_TO_DATE 
	FROM 
	(
		SELECT 
            TRIM(MASTER.DBNAME) AS MASTER_DBNAME, 
            MASTER."NUMBER" AS MASTER_EMPLOYEE_NUMBER, 
            TRIM(MATCH.DBNAME) AS DBNAME, 
            MATCH."NUMBER" AS EMPLOYEE_NUMBER
		FROM DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.EMPLOYEE_MATCH_LIST AS MATCH
        JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.EMPLOYEE_MASTER_LIST AS MASTER
            ON MASTER.MASTER_ID = MATCH.MASTER_ID
        WHERE MATCH.ID <> MATCH.MASTER_ID
	)
)
,DS AS (														-- To create Derived Statuses and status key to join wth Status_mapping table
SELECT 
	    f.DBNAME,F.REFERENCENO,f.SERVICEDATE,F.WEEKENDDATE,
	    CASE WHEN f.PAID = TRUE THEN ''05''
			 WHEN f.PAID = FALSE AND f.BILLED = TRUE THEN ''04''
			 ELSE ''02''
		END AS STATUS1,
	    IFF(TS.PAIDFLAG = '''',NULL,TS.PAIDFLAG) AS DISC_PAYROLL_STATUS,
        CASE WHEN f.SERVICEDATE::DATE <> COALESCE(MIN(SV.ADJUSTEDTIMEIN),f.SERVICEDATE)::DATE 
        	THEN 
        	CASE STATUS1 WHEN ''02'' THEN ''Rescheduled-Confirmed''
        				WHEN ''04'' THEN ''Rescheduled-Billed''
        				WHEN ''05'' THEN ''Rescheduled-Paid''
        				END
        WHEN STATUS1 = ''02'' THEN ''Confirmed''
        WHEN STATUS1 = ''04'' THEN ''Billed''
        WHEN STATUS1 = ''05'' THEN ''Paid''
        ELSE ''Unknown''
        END AS DERIVED_DISCSTATUS,										-- Taking dataflex''s statuses only
        md5(3 ||''-''||f.DBNAME||''-''||nvl(DERIVED_DISCSTATUS,''Unknown'')||''-''||nvl(DISC_PAYROLL_STATUS,''Unknown'')) as VISIT_STATUSKEY
FROM DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.ALL_DFTIMESHEETS TS1 
LEFT JOIN DF_IMPORT_VISITS DFI 											-- ONLY IL AND MO CAN COME USING THIS JOIN FROM SANDATA
	ON TS1.TRACKINGID = DFI.TRACKINGID 
	AND TS1.WEEKENDDATE = DFI.WEEKENDDATE 
	AND TS1.DBNAME = DFI.STATE 
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_VISITS SV
	ON DFI.SCHEDULEID = SV.SCHEDULEID  
	AND DFI.AGENCYID = SV.AGENCYID
	AND TS1.clientnumber::varchar=SV.CLIENTOTHERID 
	AND DFI.SERVICEDATE = SV.DATE
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_SCHEDULES SCH 
	ON  DFI.SCHEDULEID = SCH.SCHEDULEID  
	AND DFI.AGENCYID = SCH.AGENCYID
	AND DFI.SERVICEDATE = SCH.SCHEDULEDATE
RIGHT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.All_TIMESHEETSHOURS f
	ON f.DbName = ts1.DbName 
	AND f.ReferenceNo = ts1.ReferenceNo 
	AND f.WeekendDate = ts1.WeekendDate 
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = COALESCE(SV.DATE,SCH.SCHEDULEDATE),COALESCE(SV.DATE,SCH.SCHEDULEDATE),F.SERVICEDATE) -- ONLY JOIN ON servicedate WHEN mapping IS possible, otherwise will GET TS.DATA ONLY FOR visits mapped WITH sd AND rest will have NULL
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = DFI.SERVICEDATE,DFI.SERVICEDATE,NVL(DFI.SERVICEDATE,F.SERVICEDATE))			--  To avoid getting 1 - many join between TSH and Mapping table DFI
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.ALL_DFTIMESHEETS TS 
ON TS.DBNAME = F.DBNAME 
AND TS.REFERENCENO = F.REFERENCENO 
AND F.WEEKENDDATE = TS.WEEKENDDATE																								 -- This join will only be used to get fields, the previous TS1 join''s purpose is to just act as mapping between tables
GROUP BY F.DBNAME,F.REFERENCENO,F.SERVICEDATE,F.PAID,F.BILLED,TS.PAIDFLAG, F.WEEKENDDATE
	)
--
,DF AS														-- Existing logic for DF timesheets (All Confirmed)
(
	SELECT DISTINCT
	    MD5(f.DBNAME || ''-'' || f.REFERENCENO || ''-'' || f.WEEKENDDATE || ''-'' || f.SERVICEDATE || ''-'' || ''DATAFLEXSYNCDATA'') AS VISIT_KEY,
	    f.SERVICEDATE AS REPORT_DATE,
		NULL AS INVOICE_KEY,
		NULL AS PAYROLL_KEY,
		NULL AS INVOICE_ID,
		NULL AS CHEQUE_NUMBER,
	    nvl(b2.BRANCH_KEY, md5(f.DBNAME || ''-'' || COALESCE(ts.OffceNo, -1) || ''-'' ||  ''DATAFLEXSYNCDATA'')) AS BRANCH_KEY,
	    md5(COALESCE(c2.MASTER_DBNAME, f.DBNAME) || ''-'' || COALESCE(c2.MASTER_CLIENT_NUMBER, ts.CLIENTNUMBER,-1) || ''-''  ||  ''DATAFLEXSYNCDATA'' ) AS CLIENT_KEY,
	    nvl(n2.CONTRACT_KEY, md5(f.DBNAME || ''-'' || nvl(ts.CONTRACTCODE,''Unknown'') || ''-''  ||  ''DATAFLEXSYNCDATA'')) AS CONTRACT_KEY,
	    md5(COALESCE(e.MASTER_DBNAME, f.DBNAME) || ''-'' || UPPER(COALESCE(e.MASTER_EMPLOYEE_NUMBER, ts.EMPLOYEENUMBER, -1)) || ''-''  ||  ''1900-01-01'' || ''-'' || ''DATAFLEXSYNCDATA'') AS EMPLOYEE_KEY,
		EMPLOYEE_KEY AS SCHEDULED_EMPLOYEE_KEY,
	    3 AS SOURCE_SYSTEM_ID,
	    nvl(s2.SUPERVISOR_KEY, md5(f.DBNAME || ''-''  || nvl(ts.SUPERVISORCODE,''Unknown-'' || f.DBNAME) || ''-''  || ''DATAFLEXSYNCDATA'')) AS SUPERVISOR_KEY,
	    f.SERVICEDATE AS SERVICE_DATE,
		ts.payrolldate AS PAYROLL_DATE,
	    COALESCE(b.OfficeName, ''Unknown'') AS BRANCH_NAME,
	    COALESCE(c2.MASTER_CLIENT_NUMBER,ts.CLIENTNUMBER, -1) AS CLIENT_NUMBER,
	    ts.CONTRACTCODE AS CONTRACT_CODE,
	    UPPER(COALESCE(e.MASTER_EMPLOYEE_NUMBER,ts.EMPLOYEENUMBER, -1)) as EMPLOYEE_ID,
		EMPLOYEE_ID AS SCHEDULED_EMPLOYEE_ID,
	    f.DBNAME AS SYSTEM_CODE, --BK
	    nvl(ts.SUPERVISORCODE,''-1'') AS SUPERVISOR_CODE,
		--COALESCE(MAX(ILMO.autoconfirm_cnt), MAX(IND.autoconfirm_cnt),IFF(DS.STATUS1 IN (''02'',''04'',''05'') AND TS.ISEVV = ''Y'',TRUE,FALSE)) AS CLEAN_SHIFT_FLAG,
		COALESCE(MAX(ILMO.autoconfirm_cnt), MAX(IND.autoconfirm_cnt),IFF(TS.ISEVV = ''Y'',TRUE,FALSE)) AS CLEAN_SHIFT_FLAG,
--=============================================================================================================================
STATUS_MAPPING.INVOICE_STATUS_NAME,
STATUS_MAPPING.INVOICE_STATUS_CODE,
STATUS_MAPPING.INVOICE_STATUS_DESCRIPTION,
--=============================================================================================================================
STATUS_MAPPING.VISIT_STATUS_NAME,
STATUS_MAPPING.VISIT_STATUS_CODE,
STATUS_MAPPING.VISIT_STATUS_DESCRIPTION,
--=============================================================================================================================
STATUS_MAPPING.SCHEDULE_STATUS_NAME,
STATUS_MAPPING.SCHEDULE_STATUS_CODE,
STATUS_MAPPING.SCHEDULE_STATUS_DESCRIPTION,
--=============================================================================================================================
STATUS_MAPPING.PAYROLL_STATUS_CODE,
STATUS_MAPPING.PAYROLL_STATUS_NAME,
STATUS_MAPPING.PAYROLL_STATUS_DESCRIPTION,
-------------------------------------------------------------------------------------------------------------------------------
	    MAX(COALESCE(ILMO.CANCEL_REASON_CODE, IND.CANCEL_REASON_CODE)) as CANCEL_REASON_CODE ,     							-- COMMENT ''Reason code for schedule cancellation'', 	-- comes from Sandata
		MAX(COALESCE(ILMO.CANCEL_REASON_DESCRIPTION, IND.CANCEL_REASON_DESCRIPTION)) as CANCEL_REASON_DESCRIPTION ,
		MAX(COALESCE(ILMO.CANCEL_REASON_NOTES, IND.CANCEL_REASON_NOTES)) AS CANCEL_REASON_NOTES,
		MAX(COALESCE(ILMO.EXCEPTION_REASON_INDICATOR, IND.EXCEPTION_REASON_INDICATOR,''NO'')) AS EXCEPTION_REASON_INDICATOR, 
		MAX(COALESCE(ILMO.RESOLUTION_CODE, IND.RESOLUTION_CODE)) AS RESOLUTION_CODE,
	    NULL AS RESOLUTION_DESCRIPTION,
		MAX(COALESCE(ILMO.REJECTION_CODE, IND.REJECTION_CODE)) AS REJECTION_CODE,							-- comes from Sandata
		MAX(COALESCE(ILMO.REJECTION_DESCRIPTION, IND.REJECTION_DESCRIPTION)) as REJECTION_DESCRIPTION,		-- Grouping by SD''s fields would cause same visit key being repeated due to 1-many mapping for few visits, So aggregating it which won''t affect data as only RNO = 1(1 RECORD) is being taken from code desc cte
		TS.BILLCODE as BILL_CODE,										
		COALESCE(Billrate_Contract.BILL_RATE,Billrate_Contract_Client.BILL_RATE,Billrate_Contract_billcode.BILL_RATE) AS BILL_RATE,
		NULL AS BILL_UNITS_SERVED, 
		--BC."TYPE"  AS BILL_UNIT_TYPE, 	-- ChecK DF BILL CODES - Not verified
		NULL AS BILL_UNIT_TYPE,
		SUM(Billrate_Contract_overheadrate.BILL_RATE)/COUNT(1) OVER 
			(PARTITION BY f.DBNAME,COALESCE(c2.MASTER_CLIENT_NUMBER,ts.CLIENTNUMBER, -1),ts.CONTRACTCODE,DATE_TRUNC(''DAY'',f.SERVICEDATE))
	   		AS Overhead_Rate,
	    --IFF(max(COALESCE(SV.AGENCYID,sch.agencyid,IND.DF_SYSTEM_CODE)) IS NOT null,f.SERVICEHOURS,SUM(F.SERVICEHOURS)) AS HOURS_SERVED,			-- DF already has summed hours when SD has >1 mapped visit
	    f.SERVICEHOURS AS HOURS_SERVED,
		MIN(COALESCE(SV.PROPOSEDSTART, SCH.PROPOSEDTIMEIN )) AS SCHEDULE_TIMEIN,					-- Few schedules not in sd_visits but they are there in sd_schedules
	    MAX(COALESCE(SV.PROPOSEDEND, SCH.PROPOSEDTIMEOUT )) AS SCHEDULE_TIMEOUT,
	    SUM(COALESCE(SV.PROPOSEDDURATION, SCH.PROPOSEDDURATION)) AS SCHEDULE_DURATION,
	    MIN(COALESCE(SV.TIMEIN, SCH.EVVTIMEIN, F.STARTTIME)) AS ACTUAL_TIMEIN,
	    MAX(COALESCE(SV.TIMEOUT, SCH.EVVTIMEOUT,  F.ENDTIME)) AS ACTUAL_TIMEOUT,
	    COALESCE(SUM(SV.ACTUALDURATION), SUM(SCH.EVVDURATION),  F.SERVICEHOURS) AS ACTUAL_DURATION,
	    MIN(COALESCE(SV.ADJUSTEDTIMEIN, F.STARTTIME))  AS ADJUSTED_TIMEIN,							-- Adjusted NOT available IN sandata_schedules table
	    MAX(COALESCE(SV.ADJUSTEDTIMEOUT, F.ENDTIME))  AS ADJUSTED_TIMEOUT,
	    COALESCE(SUM(SV.ADJUSTEDDURATION), F.SERVICEHOURS) AS ADJUSTED_DURATION,
		MAX(COALESCE(ILMO.COMMENTS, IND.COMMENTS)) AS COMMENTS,                     				-- comes from Sandata
		TS.ISEVV as IS_EVV_FLAG,                  													-- COMMENT ''Record came from EVV feed'',	-- comes from DFTimeSheets
		TS.TIMESHEETTYPE as TIMESHEET_TYPE, 
		TS.TRACKINGID as TRACKING_ID,
		STATUS_MAPPING.CONFIRMED_FLAG,
    :STR_ETL_TASK_KEY AS ETL_TASK_KEY,
        :STR_ETL_TASK_KEY AS ETL_INSERTED_TASK_KEY,
                        
	    convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_INSERTED_DATE,
	    CURRENT_USER as ETL_INSERTED_BY ,
	    convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_LAST_UPDATED_DATE,
	    CURRENT_USER as ETL_LAST_UPDATED_BY,
	    0 as ETL_DELETED_FLAG					  
FROM 
DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.ALL_DFTIMESHEETS TS1 
LEFT JOIN DF_IMPORT_VISITS DFI 																		-- ONLY IL AND MO CAN COME USING THIS JOIN FROM SANDATA
	ON TS1.TRACKINGID = DFI.TRACKINGID 
	AND TS1.WEEKENDDATE = DFI.WEEKENDDATE 
	AND TS1.DBNAME = DFI.STATE 
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_VISITS SV
	ON DFI.SCHEDULEID = SV.SCHEDULEID  
	AND DFI.AGENCYID = SV.AGENCYID
	AND TS1.clientnumber::varchar=SV.CLIENTOTHERID 
	AND DFI.SERVICEDATE = SV.DATE
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.SANDATAIMPORT.SANDATA_SCHEDULES SCH 
	ON  DFI.SCHEDULEID = SCH.SCHEDULEID  
	AND DFI.AGENCYID  = SCH.AGENCYID
	AND DFI.SERVICEDATE = SCH.SCHEDULEDATE
RIGHT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.ALL_TIMESHEETSHOURS f
	ON f.DbName = ts1.DbName 
	AND f.ReferenceNo = ts1.ReferenceNo 
	AND f.WeekendDate = ts1.WeekendDate 
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = COALESCE(SV.DATE,SCH.SCHEDULEDATE),COALESCE(SV.DATE,SCH.SCHEDULEDATE),F.SERVICEDATE) -- ONLY JOIN ON servicedate WHEN mapping IS possible, otherwise will GET TS.DATA ONLY FOR visits mapped WITH sd AND rest will have NULL
	AND F.SERVICEDATE = IFF(F.SERVICEDATE = DFI.SERVICEDATE,DFI.SERVICEDATE,NVL(DFI.SERVICEDATE,F.SERVICEDATE))					--  To avoid getting 1 - many join between TSH and Mapping table DFI
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.ALL_DFTIMESHEETS TS 															-- This join will only be used to get fields, the previous TS1 join''s purpose is to just act as mapping between TABLES, using same TS table for both causes issues 
	ON TS.DBNAME = F.DBNAME AND TS.REFERENCENO = F.REFERENCENO AND F.WEEKENDDATE = TS.WEEKENDDATE
LEFT JOIN CODES_DESC ILMO ON
	ILMO.SCHEDULEID = SV.SCHEDULEID 
	AND ILMO.AGENCYID = SV.AGENCYID 
	AND ILMO.AGENCYID IN (''8380'',''8463'')				-- IL and MO can be mapped so, joining by schid for more accuracy and in case of split visit in SD, will take latest non cancelled split visit''s codes
LEFT JOIN CODES_DESC IND ON
	f.DBNAME = IND.DF_SYSTEM_CODE 
	AND F.DBNAME = ''IN''									-- IN cannot be mapped BY visit directly so joined BY client separately,
	AND ts.CLIENTNUMBER = IND.DF_Client_Number 
	AND f.SERVICEDATE::date = IND.DATE
LEFT JOIN DS ON 
	DS.DBNAME = F.DBNAME AND 
	DS.REFERENCENO = F.REFERENCENO AND 
	DS.SERVICEDATE = F.SERVICEDATE AND 
	DS.WEEKENDDATE = F.WEEKENDDATE	 
LEFT JOIN HAH.DIM_VISIT_STATUS_MAPPING STATUS_MAPPING ON 
	STATUS_MAPPING.VISIT_STATUS_KEY = DS.VISIT_STATUSKEY								  
LEFT JOIN EMPLOYEES e 
	ON TRIM(ts.EMPLOYEENUMBER) = e.EMPLOYEE_NUMBER 
	AND ts.DBNAME = e.DBNAME 
	AND f.SERVICEDATE >= e.EFFECTIVE_FROM_DATE 
	AND f.SERVICEDATE < e.EFFECTIVE_TO_DATE
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DataFlexSyncData.DfOffices b 
	ON ts.OFFCENO = b.OfficeNumber 
	AND ts.DBNAME = b.DBNAME
LEFT JOIN HAH.DIM_BRANCH b2 
	ON b2.BRANCH_NAME = COALESCE(b.OfficeName, ''Unknown'') 
	AND b2.SYSTEM_CODE = b.DBNAME
LEFT JOIN CLIENT_DATA c2 
	ON c2.CLIENT_NUMBER = ts.CLIENTNUMBER 
	AND c2.DBNAME = ts.DBNAME
LEFT JOIN HAH.DIM_CONTRACT n2 
	ON n2.CONTRACT_CODE = ts.CONTRACTCODE 
	AND n2.SYSTEM_CODE = ts.DBNAME
LEFT JOIN HAH.DIM_SUPERVISOR s2 
	ON s2.SUPERVISOR_CODE = ts.SUPERVISORCODE 
	AND s2.SYSTEM_CODE = ts.DBNAME
	--LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFBILLCODES BC ON TS.BILLCODE = BC.BILLCODE AND BC.DBNAME = TS.DBNAME
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract 
	on Billrate_Contract.dbname = f.dbname 
	and ts.CONTRACTCODE = Billrate_Contract.CONTRACT_CODE 
	and f.SERVICEDATE between Billrate_Contract.EFFECTIVE_FROM_DATE and NVL(Billrate_Contract.EFFECTIVE_TO_DATE,CURRENT_DATE) 
	and Billrate_Contract.BILL_RATE_LEVEL = ''contract''
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_Client 
	on Billrate_Contract_Client.dbname = f.dbname
	and ts.CONTRACTCODE = Billrate_Contract_Client.CONTRACT_CODE
	and ts.CLIENTNUMBER = Billrate_Contract_Client.CLIENT_NUMBER
	and ts.BILLCODE = Billrate_Contract_Client.Bill_Code
	and f.SERVICEDATE  between Billrate_Contract_Client.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_Client.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_Client.BILL_RATE_LEVEL = ''clientnumber''
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_billcode 
	on Billrate_Contract_billcode.dbname = f.dbname
	and ts.CONTRACTCODE = Billrate_Contract_billcode.CONTRACT_CODE
	and ts.BILLCODE  = Billrate_Contract_billcode.Bill_Code
	and f.SERVICEDATE between Billrate_Contract_billcode.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_billcode.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_billcode.BILL_RATE_LEVEL = ''BILLCODE''
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_overheadrate 
	on Billrate_Contract_overheadrate.dbname = f.dbname
	and ts.CONTRACTCODE = Billrate_Contract_overheadrate.CONTRACT_CODE
	and f.SERVICEDATE between Billrate_Contract_overheadrate.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_overheadrate.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_overheadrate.BILL_RATE_LEVEL = ''OVERHEADRATE''
where (f.ETL_LAST_UPDATED_DATE >= :STR_CDC_START::timestamp_ntz
OR ts.ETL_LAST_UPDATED_DATE >= :STR_CDC_START::timestamp_ntz)
	GROUP BY VISIT_KEY,F.PAID,F.BILLED,TS.PAIDFLAG,REPORT_DATE,BRANCH_KEY,CLIENT_KEY,CONTRACT_KEY,EMPLOYEE_KEY,SCHEDULED_EMPLOYEE_KEY,SUPERVISOR_KEY,SERVICE_DATE,
	PAYROLL_DATE, BRANCH_NAME, B.OFFICENAME, TS.OFFCENO, c2.MASTER_CLIENT_NUMBER, ts.CLIENTNUMBER, TS.CONTRACTCODE, e.MASTER_EMPLOYEE_NUMBER, ts.EMPLOYEENUMBER
	, f.DBNAME, TS.SUPERVISORCODE, TS.BILLCODE, Billrate_Contract.BILL_RATE, Billrate_Contract_Client.BILL_RATE
	, Billrate_Contract_billcode.BILL_RATE, IS_EVV_FLAG, TIMESHEET_TYPE	, TS.TRACKINGID , f.SERVICEHOURS ,DS.STATUS1,STATUS_MAPPING.INVOICE_STATUS_NAME,
STATUS_MAPPING.INVOICE_STATUS_CODE, STATUS_MAPPING.INVOICE_STATUS_DESCRIPTION, STATUS_MAPPING.VISIT_STATUS_NAME, STATUS_MAPPING.VISIT_STATUS_CODE,
STATUS_MAPPING.VISIT_STATUS_DESCRIPTION,STATUS_MAPPING.SCHEDULE_STATUS_NAME,STATUS_MAPPING.SCHEDULE_STATUS_CODE,STATUS_MAPPING.SCHEDULE_STATUS_DESCRIPTION,
STATUS_MAPPING.PAYROLL_STATUS_CODE,STATUS_MAPPING.PAYROLL_STATUS_NAME,STATUS_MAPPING.PAYROLL_STATUS_DESCRIPTION, STATUS_MAPPING.CONFIRMED_FLAG 
)
--------------------------- New logic for non confirmed -------------------------------------------------------
,
SUPERVISORS AS 													-- Same Supervisors with different codes but same payemp_number are there so picked latest code to be able to join with Sandata
(SELECT NAME, CODE, PAYEMP_NUMBER, DBNAME, OFFICE
, row_number()OVER (PARTITION BY  iFF(NVL(PAYEMP_NUMBER,'''') <> '''',PAYEMP_NUMBER,CODE), dbname ORDER BY updatedtime desc) rno 
FROM DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFSUPERVISORS QUALIFY rno = 1
)
, SD_STATUS AS (
 SELECT SCHEDULEID, AGENCYID,
 CASE SD.STATUS
        WHEN ''01'' THEN ''Pending''
        WHEN ''09'' THEN ''Hold''
        WHEN ''10'' THEN ''Cancelled''
        END AS DISC_VISIT_STATUS1,
        CASE WHEN SD.STATUS =''01'' AND SD.STAFFAGENCYID IS NULL AND SD.SCHEDULEDATE > CURRENT_DATE() THEN ''01OPENFUTURE'' 
		WHEN SD.STATUS =''01'' AND SD.STAFFAGENCYID IS NOT NULL AND SD.SCHEDULEDATE > CURRENT_DATE() THEN ''01FUTURE''
		WHEN SD.STATUS =''01'' AND SD.STAFFAGENCYID IS NULL AND SD.SCHEDULEDATE <= CURRENT_DATE() THEN ''01OPEN'' 
		WHEN SD.STATUS =''01'' AND SD.STAFFAGENCYID IS NOT NULL AND SD.SCHEDULEDATE <= CURRENT_DATE() THEN ''01'' 
		ELSE SD.STATUS END
		AS DERIVED_DISC_STATUS1,	
md5(3 ||''-''||SD.DFDBNAME||''-''||nvl(DISC_VISIT_STATUS1,''Unknown'')||''-''||DERIVED_DISC_STATUS1) as VISIT_STATUS_KEY		-- for dim_visit_status_mapping
	FROM DISC_${var.SF_ENVIRONMENT}.PUBLIC.VW_DATAFLEX_SANDATA_PENDING_VISITS SD
)
,SD AS (SELECT DISTINCT												-- New logic (All Non-Confirmed. Includes Future Schedules)
		MD5(SD.DFDBNAME || ''-'' || SD.SCHEDULEID || ''-'' || ''DATAFLEXSYNCDATA'') AS VISIT_KEY,
	    SD.SCHEDULEDATE AS REPORT_DATE,
		NULL AS INVOICE_KEY,
		NULL AS PAYROLL_KEY,
		NULL AS INVOICE_ID,
		NULL AS CHEQUE_NUMBER,
		nvl(b2.BRANCH_KEY, md5(SD.DFDBNAME || ''-'' || COALESCE(SD.INTID, -1) || ''-'' ||  ''DATAFLEXSYNCDATA'')) AS BRANCH_KEY,
	    md5(COALESCE(c2.MASTER_DBNAME, SD.DFDBNAME) || ''-'' || COALESCE(c2.MASTER_CLIENT_NUMBER, SD.CLIENTOTHERID,-1) || ''-''  ||  ''DATAFLEXSYNCDATA'' ) AS CLIENT_KEY,
	    nvl(n2.CONTRACT_KEY, md5(SD.DFDBNAME || ''-'' || nvl(SD.CONTRACTCODE,''Unknown'') || ''-''  ||  ''DATAFLEXSYNCDATA'')) AS CONTRACT_KEY,
		md5(COALESCE(e.MASTER_DBNAME, SD.DFDBNAME) || ''-'' || UPPER(COALESCE(e.MASTER_EMPLOYEE_NUMBER, DE1.NUMBER, -1)) || ''-''  ||  ''1900-01-01'' || ''-'' || ''DATAFLEXSYNCDATA'') AS SCHEDULED_EMPLOYEE_KEY,
	    md5(COALESCE(e.MASTER_DBNAME, SD.DFDBNAME) || ''-'' || UPPER(COALESCE(e.MASTER_EMPLOYEE_NUMBER, DE1.NUMBER, -1)) || ''-''  ||  ''1900-01-01'' || ''-'' || ''DATAFLEXSYNCDATA'') AS EMPLOYEE_KEY,
		3 AS SOURCE_SYSTEM_ID,
		nvl(s2.SUPERVISOR_KEY, md5(SD.DFDBNAME || ''-''  || COALESCE(SP.CODE, SP2.CODE, ''Unknown-'' || SD.DFDBNAME) || ''-''  || ''DATAFLEXSYNCDATA'')) AS SUPERVISOR_KEY,
		SD.SCHEDULEDATE AS SERVICE_DATE,
		dateadd(''day'',11,date_trunc(''week'',CAST(SD.SCHEDULEDATE as date))) AS PAYROLL_DATE,		-- Based to timesheets'' data, Payroll date majority of times is next week''s Friday. Can be kept null as well in this case.
	    COALESCE(b.OfficeName, ''Unknown'') AS BRANCH_NAME,
	    COALESCE(c2.MASTER_CLIENT_NUMBER,SD.CLIENTOTHERID, -1) AS CLIENT_NUMBER,
	    SD.CONTRACTCODE AS CONTRACT_CODE,
	    --
	    UPPER(COALESCE(e.MASTER_EMPLOYEE_NUMBER,DE1.NUMBER, -1)) as EMPLOYEE_ID,
		EMPLOYEE_ID AS SCHEDULED_EMPLOYEE_ID,
	    --
		CASE SD.DFDBNAME WHEN ''IL'' THEN ''IL - 8380'' WHEN ''MO'' THEN ''MO - 8463'' END AS SYSTEM_CODE,
	    COALESCE(SP.CODE, SP2.CODE, ''-1'') AS SUPERVISOR_CODE,
		FALSE AS CLEAN_SHIFT_FLAG,
--=============================================================================================================================
NULL AS INVOICE_STATUS_NAME,
NULL AS INVOICE_STATUS_CODE,
NULL AS INVOICE_STATUS_DESCRIPTION,
--=============================================================================================================================
SM.VISIT_STATUS_NAME,
SM.VISIT_STATUS_CODE,
SM.VISIT_STATUS_DESCRIPTION,
--=============================================================================================================================
SM.SCHEDULE_STATUS_NAME,
SM.SCHEDULE_STATUS_CODE,
SM.SCHEDULE_STATUS_DESCRIPTION,
--=============================================================================================================================
NULL AS PAYROLL_STATUS_CODE,
NULL AS PAYROLL_STATUS_NAME,
NULL AS PAYROLL_STATUS_DESCRIPTION,
-------------------------------------------------------------------------------------------------------------------------------
	    MAX(SD.CANCEL_REASON_CODE) as CANCEL_REASON_CODE ,     								-- COMMENT ''Reason code for schedule cancellation'', 	-- comes from Sandata
		MAX(SD.CANCEL_REASON_DESCRIPTION) as CANCEL_REASON_DESCRIPTION ,
		MAX(SD.CANCEL_REASON_NOTES) AS CANCEL_REASON_NOTES,
		COALESCE(MAX(SD.EXCEPTION_REASON_INDICATOR),''NO'') AS EXCEPTION_REASON_INDICATOR, 
		MAX(SD.RESOLUTION_CODE) AS RESOLUTION_CODE,
	    NULL AS RESOLUTION_DESCRIPTION,
		MAX(SD.REJECTION_CODE) AS REJECTION_CODE,							
		MAX(SD.REJECTION_DESCRIPTION) as REJECTION_DESCRIPTION,	
		--
		SD.BILLCODE as BILL_CODE,	
		--
		COALESCE(Billrate_Contract.BILL_RATE,Billrate_Contract_Client.BILL_RATE,Billrate_Contract_billcode.BILL_RATE) AS BILL_RATE,
		--
		NULL AS BILL_UNITS_SERVED, 
		NULL AS BILL_UNIT_TYPE,
		--
		SUM(Billrate_Contract_overheadrate.BILL_RATE)/COUNT(1) OVER 
			(PARTITION BY SD.DFDBNAME,COALESCE(c2.MASTER_CLIENT_NUMBER,SD.CLIENTOTHERID, -1),SD.CONTRACTCODE,DATE_TRUNC(''DAY'',SD.SCHEDULEDATE))
	   		AS Overhead_Rate,
		NULL AS HOURS_SERVED,
		nvl(SD.SCHEDULE_TIMEIN,	SD.ACTUAL_TIMEIN) AS SCHEDULE_TIMEIN,					--to Fill data quality gaps as sometimes schedule time is missing while evv fields have time, even though its a cancelled or pending visit
	    nvl(SD.SCHEDULE_TIMEOUT, SD.ACTUAL_TIMEOUT) AS SCHEDULE_TIMEOUT,
	    nvl(SD.SCHEDULE_DURATION, SD.ACTUAL_DURATION) AS SCHEDULE_DURATION,
	    NULL AS ACTUAL_TIMEIN,
	    NULL AS ACTUAL_TIMEOUT,
	    NULL AS ACTUAL_DURATION,
	    NULL AS ADJUSTED_TIMEIN,							
	    NULL AS ADJUSTED_TIMEOUT,
	    NULL AS ADJUSTED_DURATION,
		SD.COMMENTS AS COMMENTS,                     				
		''Y'' as IS_EVV_FLAG,                  												
		NULL as TIMESHEET_TYPE, 
		NULL as TRACKING_ID,
		''NO'' AS CONFIRMED_FLAG,
		:STR_ETL_TASK_KEY AS ETL_TASK_KEY,
        :STR_ETL_TASK_KEY AS ETL_INSERTED_TASK_KEY,
	    convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_INSERTED_DATE,
	    CURRENT_USER as ETL_INSERTED_BY ,
	    convert_timezone(''UTC'', CURRENT_TIMESTAMP)::timestamp_ntz as ETL_LAST_UPDATED_DATE,
	    CURRENT_USER as ETL_LAST_UPDATED_BY,
	    0 as ETL_DELETED_FLAG					  
FROM DISC_${var.SF_ENVIRONMENT}.PUBLIC.VW_DATAFLEX_SANDATA_PENDING_VISITS SD
LEFT JOIN DF_IMPORT_VISITS DFI
	ON 	DFI.SCHEDULEID = SD.SCHEDULEID  
	AND DFI.AGENCYID = SD.AGENCYID
LEFT JOIN SD_STATUS SDS 
	ON SDS.SCHEDULEID = SD.SCHEDULEID 
	AND SDS.AGENCYID = SD.AGENCYID
LEFT JOIN HAH.DIM_VISIT_STATUS_MAPPING SM 
	ON SM.VISIT_STATUS_KEY = SDS.VISIT_STATUS_KEY
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFEMPLOYEES DE1
	ON SD.STAFFAGENCYID = DE1.PAYROLLIDINDEXNO						
	AND SD.DFDBNAME = DE1.DBNAME
LEFT JOIN EMPLOYEES e 
	ON DE1.NUMBER = e.EMPLOYEE_NUMBER 
	AND DE1.DBNAME = e.DBNAME 
	AND SD.SCHEDULEDATE >= e.EFFECTIVE_FROM_DATE 
	AND SD.SCHEDULEDATE < e.EFFECTIVE_TO_DATE
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DataFlexSyncData.DfOffices b 
	ON SD.INTID = b.OfficeNumber 
	AND SD.DFDBNAME = b.DBNAME
LEFT JOIN HAH.DIM_BRANCH b2 
	ON b2.BRANCH_NAME = COALESCE(b.OfficeName, ''Unknown'') 
	AND b2.SYSTEM_CODE = b.DBNAME
LEFT JOIN CLIENT_DATA c2 
	ON c2.CLIENT_NUMBER = SD.CLIENTOTHERID 
	AND c2.DBNAME = SD.DFDBNAME
LEFT JOIN HAH.DIM_CONTRACT n2 
	ON n2.CONTRACT_CODE = SD.CONTRACTCODE 
	AND n2.SYSTEM_CODE = SD.DFDBNAME
	--
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DFEMPLOYEES DE 							--  FOR Supervisor, 1st JOIN IS FROM Sandata visit TO client admission, 
	ON SD.SUPERVISORID = DE.PAYROLLIDINDEXNO								--  THEN Coordinator FROM Client admission TO sandata staff, THEN staff TO dfemployee 
	AND SD.DFDBNAME = DE.DBNAME
LEFT JOIN SUPERVISORS SP 											-- AND finally dfemployee TO dfsupervisor
	ON DE.PAYROLLID = SP.PAYEMP_NUMBER AND DE.DBNAME = SP.DBNAME AND SP.OFFICE = DE.OFFICENUMBER
LEFT JOIN SUPERVISORS SP2 											-- Another way TO JOIN which gives few MORE supervisors:-- otherid1 FROM sandata staffs TO payemp_no IN dfsupervisors
	ON SD.PAYEMP_NO = SP2.PAYEMP_NUMBER 
	AND SD.DFDBNAME = SP2.DBNAME
LEFT JOIN HAH.DIM_SUPERVISOR s2 
	ON s2.SUPERVISOR_CODE = COALESCE(SP.CODE,SP2.CODE)
	AND s2.SYSTEM_CODE = COALESCE(SP.DBNAME, SP2.DBNAME)
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract 
	on Billrate_Contract.dbname = SD.DFDBNAME 
	and SD.CONTRACTCODE = Billrate_Contract.CONTRACT_CODE 
	and SD.SCHEDULEDATE between Billrate_Contract.EFFECTIVE_FROM_DATE and NVL(Billrate_Contract.EFFECTIVE_TO_DATE,CURRENT_DATE) 
	and Billrate_Contract.BILL_RATE_LEVEL = ''contract''
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_Client 
	on Billrate_Contract_Client.dbname = SD.DFDBNAME
	and SD.CONTRACTCODE = Billrate_Contract_Client.CONTRACT_CODE
	and SD.CLIENTOTHERID = Billrate_Contract_Client.CLIENT_NUMBER
	and SD.BILLCODE = Billrate_Contract_Client.Bill_Code
	and SD.SCHEDULEDATE  between Billrate_Contract_Client.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_Client.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_Client.BILL_RATE_LEVEL = ''clientnumber''
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_billcode 
	on Billrate_Contract_billcode.dbname = SD.DFDBNAME
	and SD.CONTRACTCODE = Billrate_Contract_billcode.CONTRACT_CODE
	and SD.BILLCODE  = Billrate_Contract_billcode.Bill_Code
	and SD.SCHEDULEDATE between Billrate_Contract_billcode.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_billcode.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_billcode.BILL_RATE_LEVEL = ''BILLCODE''
LEFT JOIN DISC_${var.SF_ENVIRONMENT}.DATAFLEXSYNCDATA.DERIVED_BILLRATE Billrate_Contract_overheadrate 
	on Billrate_Contract_overheadrate.dbname = SD.DFDBNAME
	and SD.CONTRACTCODE = Billrate_Contract_overheadrate.CONTRACT_CODE
	and SD.SCHEDULEDATE between Billrate_Contract_overheadrate.EFFECTIVE_FROM_DATE 
	and NVL(Billrate_Contract_overheadrate.EFFECTIVE_TO_DATE,CURRENT_DATE)
	and Billrate_Contract_overheadrate.BILL_RATE_LEVEL = ''OVERHEADRATE''
where (SD.ETL_LAST_UPDATED_DATE >= :STR_CDC_START::timestamp_ntz
AND SD.CLIENTOTHERID IS NOT NULL --AND NULLIF(SD.ADMISSIONID,0) IS NOT NULL						-- 850k visits from source do not have Client, location, supervisors & contract. Can bring incase there''s any value to those
AND DFI.SCHEDULEID IS NULL)										-- making sure that already imported visits are not there in new logic
	GROUP BY SD.DFDBNAME, c2.MASTER_CLIENT_NUMBER, SD.CLIENTOTHERID,SD.CONTRACTCODE,SD.SCHEDULEDATE, SD.SCHEDULEID, B2.BRANCH_KEY, SD.INTID, B.OFFICENAME
	,C2.MASTER_DBNAME, N2.CONTRACT_KEY, E.MASTER_DBNAME, e.MASTER_EMPLOYEE_NUMBER,DE1.NUMBER, SD.COMMENTS ,S2.SUPERVISOR_KEY, SP.CODE, SP2.CODE, SD.BILLCODE
	, Billrate_Contract.BILL_RATE, Billrate_Contract_Client.BILL_RATE, Billrate_Contract_billcode.BILL_RATE, SD.SCHEDULE_TIMEIN, SD.SCHEDULE_TIMEOUT,
	    SD.SCHEDULE_DURATION, SD.ACTUAL_TIMEIN, SD.ACTUAL_TIMEOUT, SD.ACTUAL_DURATION, SD.ADJUSTED_TIMEIN, SD.ADJUSTED_TIMEOUT, SD.ADJUSTED_DURATION
	    ,SD.HOURS_SERVED, SM.VISIT_STATUS_CODE, SM.VISIT_STATUS_NAME, SM.VISIT_STATUS_DESCRIPTION, SM.SCHEDULE_STATUS_NAME, SM.SCHEDULE_STATUS_CODE, SM.SCHEDULE_STATUS_DESCRIPTION
	) 
, FINAL AS 
(
	SELECT L.*
	FROM (
		SELECT * FROM DF
		UNION ALL 
		SELECT * FROM SD ) L
LEFT JOIN HAH.FACT_SYSTEM_CUTOVER_DATE AS CUTOVER ON CUTOVER.SOURCE_SYSTEM_ID = L.SOURCE_SYSTEM_ID 
	AND CUTOVER.SYSTEM_CODE = L.SYSTEM_CODE
	AND NVL(CUTOVER.BRANCH_KEY, L.BRANCH_KEY) = L.BRANCH_KEY
	AND NVL(CUTOVER.CONTRACT_KEY, L.CONTRACT_KEY) = L.CONTRACT_KEY
WHERE L.SERVICE_DATE BETWEEN NVL(CUTOVER.START_DATE, L.SERVICE_DATE) AND NVL(CUTOVER.END_DATE, L.SERVICE_DATE)
)
SELECT VISIT_KEY,	REPORT_DATE, BRANCH_KEY, CLIENT_KEY, CONTRACT_KEY, SCHEDULED_EMPLOYEE_KEY, EMPLOYEE_KEY, 
SOURCE_SYSTEM_ID, SUPERVISOR_KEY, INVOICE_KEY, PAYROLL_KEY,	SERVICE_DATE, PAYROLL_DATE,	BRANCH_NAME, CLIENT_NUMBER, CONTRACT_CODE, SCHEDULED_EMPLOYEE_ID, EMPLOYEE_ID, 
SYSTEM_CODE, SUPERVISOR_CODE, INVOICE_ID, CHEQUE_NUMBER, CLEAN_SHIFT_FLAG, SCHEDULE_STATUS_NAME, SCHEDULE_STATUS_CODE, SCHEDULE_STATUS_DESCRIPTION,	VISIT_STATUS_NAME, 
VISIT_STATUS_CODE, VISIT_STATUS_DESCRIPTION, INVOICE_STATUS_NAME, INVOICE_STATUS_CODE, INVOICE_STATUS_DESCRIPTION, PAYROLL_STATUS_NAME,	PAYROLL_STATUS_CODE, 
PAYROLL_STATUS_DESCRIPTION,	CANCEL_REASON_CODE,	CANCEL_REASON_DESCRIPTION, CANCEL_REASON_NOTES,	EXCEPTION_REASON_INDICATOR,	RESOLUTION_CODE, RESOLUTION_DESCRIPTION, 
REJECTION_CODE,	REJECTION_DESCRIPTION, BILL_CODE, BILL_RATE, BILL_UNITS_SERVED, BILL_UNIT_TYPE,	OVERHEAD_RATE, SCHEDULE_TIMEIN,	SCHEDULE_TIMEOUT, SCHEDULE_DURATION, 
ACTUAL_TIMEIN, ACTUAL_TIMEOUT, ACTUAL_DURATION,	ADJUSTED_TIMEIN, ADJUSTED_TIMEOUT, ADJUSTED_DURATION, HOURS_SERVED,	COMMENTS, IS_EVV_FLAG, TIMESHEET_TYPE, TRACKING_ID, 
ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_DATE,	ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE,	ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, CONFIRMED_FLAG 
FROM FINAL
 ;
;
    SELECT CONCAT(''Message : '',"number of rows inserted",'' Rows Inserted.'') into :return_result FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    return return_result;
END;
    
 EOT
}

