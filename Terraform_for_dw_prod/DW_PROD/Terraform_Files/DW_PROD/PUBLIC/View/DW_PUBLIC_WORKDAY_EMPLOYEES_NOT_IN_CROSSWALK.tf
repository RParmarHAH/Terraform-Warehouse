resource "snowflake_view" "DW_PUBLIC_WORKDAY_EMPLOYEES_NOT_IN_CROSSWALK" {
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "PUBLIC"
	name = "WORKDAY_EMPLOYEES_NOT_IN_CROSSWALK"
	statement = <<-SQL
	 
-- Matched with employee on the basis of following FIELDS
---
-- First_name and SSN 
-- Last_name and SSN 
-- First_name and Last_name and DOB
WITH DISC AS 
	(
	WITH NO_POS AS 
		(-- FOR employees who haven'T been assigned a POSITION AS OF now (last known position is fetched)
	    SELECT NP.EMPLOYEE_ID, NP.WORKER_TYPE
	    FROM DISC_${var.SF_ENVIRONMENT}.WORKDAY.HIST_WORKER_POSITION_DATA NP
	    QUALIFY ROW_NUMBER() OVER (PARTITION BY NP.EMPLOYEE_ID ORDER BY NP.ETL_INSERTED_DATE DESC, NP.PROCESSED_TIMESTAMP DESC, NP.LANDING_INSERTED_DATE DESC ) =1
		)
	,ORG AS 
		(
	    SELECT EMPLOYEE_ID, ORGANIZATION_NAME
	    FROM DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_ORGANIZATION_DATA
	    WHERE ORGANIZATION_TYPE = 'Location_Hierarchy'
	        AND ORGANIZATION_SUBTYPE = 'Geographic_Division'
		)
	,NO_ORG AS 
		( -- FOR employees who haven'T been assigned a POSITION AS OF now (last known position is fetched)
	    SELECT EMPLOYEE_ID, ORGANIZATION_NAME
	    FROM DISC_${var.SF_ENVIRONMENT}.WORKDAY.HIST_WORKER_ORGANIZATION_DATA
	    WHERE ORGANIZATION_TYPE = 'Location_Hierarchy'
	        AND ORGANIZATION_SUBTYPE = 'Geographic_Division'
	    QUALIFY ROW_NUMBER() OVER (PARTITION BY EMPLOYEE_ID ORDER BY ETL_INSERTED_DATE DESC, PROCESSED_TIMESTAMP DESC, LANDING_INSERTED_DATE DESC ) =1
		)
	SELECT
	    S.EMPLOYEE_ID,
	    NM.FIRST_NAME,
	    NM.MIDDLE_NAME,
	    NM.LAST_NAME,
	    A.ADDRESS_LINE_DATA,
	    A.MUNICIPALITY,
	    A.REGION,
	    AD.AMS_COST_CENTER_HIERARCHY,
	    COALESCE(ORG.ORGANIZATION_NAME, NO_ORG.ORGANIZATION_NAME) AS LOCATION_HIERARCHY,
	    COALESCE(P.WORKER_TYPE, NO_POS.WORKER_TYPE) AS WORKER_TYPE,
	    ST.ACTIVE, --AS "Active in Workday?",
	    AD.PRE_BOARDING_COMPLETION,
	    AD.SEND_TO_AMS,
	    TRIM(ST.PRIMARY_TERMINATION_REASON) AS PRIMARY_TERMINATION_REASON,
	    "CFI INT005 Worker ID LRV" AS ON_EXCLUDE_LIST
	FROM DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_SUMMARY S
	INNER JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_ADDITIONAL_INFORMATION AD
	    ON AD.EMPLOYEE_ID = S.EMPLOYEE_ID
	LEFT JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_POSITION_DATA P
	    ON P.EMPLOYEE_ID = S.EMPLOYEE_ID
	LEFT JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_NAME_DATA NM
	    ON NM.EMPLOYEE_ID = S.EMPLOYEE_ID AND Nm.NAME_TYPE = 'Legal'
	LEFT JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_ADDRESS_DATA A
	    ON A.EMPLOYEE_ID = S.EMPLOYEE_ID AND A.ADDRESS_TYPE = 'HOME'
	LEFT JOIN NO_POS
	    ON NO_POS.EMPLOYEE_ID = S.EMPLOYEE_ID AND P.EMPLOYEE_ID IS NULL
	LEFT JOIN ORG
	    ON ORG.EMPLOYEE_ID = S.EMPLOYEE_ID
	LEFT JOIN NO_ORG
	    ON NO_ORG.EMPLOYEE_ID = S.EMPLOYEE_ID
	LEFT JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_STATUS ST
	    ON ST.EMPLOYEE_ID = S.EMPLOYEE_ID
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CROS
	    ON CROS.WORKDAY_INTERNAL_ID = S.EMPLOYEE_ID
	LEFT JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_EXCLUDE_LIST EX
	    ON EX."CFI INT005 Worker ID LRV" = S.EMPLOYEE_ID    
	WHERE AD.SEND_TO_AMS = '1'
	)
,CTE AS 
    (SELECT  
	    W.EMPLOYEE_ID,
	    C.EMPLOYEE_ENTERPRISE_ID ,
	    C.FIRST_NAME AS CROSSWALK_FIRST_NAME,
	    C.LAST_NAME  AS CROSSWALK_LAST_NAME,
	    C.AMS_EMPLOYEE_ID  ,
	    C.AMS_EMPLOYEE_KEY,
	    C.AMS_SOURCE_SYSTEM_ID ,
	    C.AMS_SYSTEM_CODE  ,
	    C.WORKDAY_INTERNAL_ID ,
	    C.DUP_FLAG AS CROSSWALK_DUP_FLAG,
	    C.INACTIVE AS CROSSWALK_INACTIVE,
	    HEX_ENCODE(ID) AS SSN,
	    P.BIRTH_DATE ,
	    W.FIRST_NAME ,
	    W.MIDDLE_NAME ,
	    W.LAST_NAME ,
	    ACTIVE, 
	    IFF(C.WORKDAY_INTERNAL_ID IS NULL, 'NOT_IN_CROSSWALK','IN_CROSSWALK') AS CROSSWALK_STATUS,
	    IFF(C.AMS_EMPLOYEE_KEY IS NULL , 'NO_AMS_RELATIONSHIP', SS.SYSTEM_CODE) AS CROSSWALK_AMS_SYSTEM,
	    CASE 
	        WHEN AMS_COST_CENTER_HIERARCHY = 'DataFlex/Sandata' THEN 'DataFlexSyncData' 
	        WHEN AMS_COST_CENTER_HIERARCHY = 'HHAX' THEN 'HHAExchange' 
	        WHEN AMS_COST_CENTER_HIERARCHY IS NULL THEN 'NO_AMS_RELATIONSHIP'
	        ELSE AMS_COST_CENTER_HIERARCHY END AS WORKDAY_AMS_SYSTEM,
	    IFF(CROSSWALK_AMS_SYSTEM = WORKDAY_AMS_SYSTEM,'MATCH','MISMATCH' ) AS AMS_SYSTEM_MATCH,
	    ACTIVE AS WORKDAY_ACTIVE,
	    ACTIVE_EMPLOYEE_FLAG AS AMS_ACTIVE,
	    IFF(WORKDAY_ACTIVE = AMS_ACTIVE,'MATCH','MISMATCH' ) AS ACTIVE_MATCH,
	    SEND_TO_AMS,
	    PRE_BOARDING_COMPLETION,
	    WORKER_TYPE AS WORKDAY_WORKER_TYPE,
	    EMPLOYEE_CATEGORY AS AMS_WORKER_TYPE,
	    ON_EXCLUDE_LIST,
	    C.PAYROLL_EMPLOYEE_KEY,
	    E.EMPLOYEE_HIRE_DATE 
    FROM DISC W
    LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK C 
    	ON C.WORKDAY_INTERNAL_ID = W.EMPLOYEE_ID 
    	AND c.DUP_FLAG = FALSE AND C.INACTIVE = FALSE
    LEFT JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_IDENTIFICATION_DATA I 
    	ON I.EMPLOYEE_ID = W.EMPLOYEE_ID AND I.ID_TYPE = 'USA-SSN'
    LEFT JOIN DISC_${var.SF_ENVIRONMENT}.WORKDAY.WORKER_PERSONAL P 
    	ON P.EMPLOYEE_ID = W.EMPLOYEE_ID 
    LEFT JOIN DW_${var.SF_ENVIRONMENT}.HAH.DIM_SOURCE_SYSTEM SS 
    	ON C.AMS_SOURCE_SYSTEM_ID = SS.SOURCE_SYSTEM_ID 
    LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_AMS_MERGED E 
    	ON C.AMS_EMPLOYEE_KEY = E.EMPLOYEE_KEY AND E.EMPLOYEE_KEY = E.ORIGINAL_EMPLOYEE_KEY
    WHERE CROSSWALK_AMS_SYSTEM = 'NO_AMS_RELATIONSHIP' 
    and WORKDAY_ACTIVE = TRUE AND CROSSWALK_STATUS = 'IN_CROSSWALK' AND SEND_TO_AMS = 1 
--    AND PRE_BOARDING_COMPLETION = 1
    AND ON_EXCLUDE_LIST IS NULL
    )
,cte_2 AS
    (
    SELECT
    CW.EMPLOYEE_ENTERPRISE_ID,
    UPPER(CTE.FIRST_NAME) AS crosswalk_first_name,
    UPPER(CTE.LAST_NAME) AS crosswalk_last_name,
    COALESCE (CW.AMS_EMPLOYEE_KEY,DE.EMPLOYEE_KEY ) AS AMS_EMPLOYEE_KEY,
    COALESCE(CW.AMS_SOURCE_SYSTEM_ID,DE.SOURCE_SYSTEM_ID ) AS AMS_SOURCE_SYSTEM_ID,
    COALESCE (CW.AMS_SYSTEM_CODE,DE.SYSTEM_CODE) AS AMS_SYSTEM_CODE,
    COALESCE (CW.AMS_EMPLOYEE_ID,DE.EMPLOYEE_ID ) AS AMS_EMPLOYEE_ID,
    CW.WORKDAY_INTERNAL_ID,
    CW.INACTIVE  AS CROSSWALK_INACTIVE,
    CW.DUP_FLAG AS CROSSWALK_DUP_FLAG,
    CTE.EMPLOYEE_ID AS EXPECTED_WORKDAY_ID,IFF(CW.AMS_EMPLOYEE_KEY IS NULL,'NOT IN AMS','POTENTIALLY_IN_AMS') AS REMARK,'MEET' AS cte,
    CW.PAYROLL_EMPLOYEE_KEY,
    DE.EMPLOYEE_HIRE_DATE 
	FROM CTE
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_AMS_MERGED DE 
	ON (CTE.SSN = DE.EMPLOYEE_PID 
		AND (SPLIT_PART(UPPER(DE.EMPLOYEE_FIRST_NAME),' ', 1)= UPPER(CTE.FIRST_NAME)) 
    	)
    	OR 
    	(UPPER(DE.EMPLOYEE_FIRST_NAME)= UPPER(CTE.FIRST_NAME)
        AND UPPER(DE.EMPLOYEE_LAST_NAME) = UPPER(CTE.LAST_NAME)
        AND CTE.BIRTH_DATE = DE.EMPLOYEE_DOB
        )      
        OR 
        (CTE.SSN = DE.EMPLOYEE_PID 
		AND UPPER(DE.EMPLOYEE_LAST_NAME) = UPPER(CTE.LAST_NAME))
    LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW 
    	ON CW.AMS_EMPLOYEE_KEY  = DE.EMPLOYEE_KEY 
    	AND CW.DUP_FLAG = FALSE AND CW.INACTIVE = FALSE
    WHERE DE.SYSTEM_CODE <> 'WORKDAY'
	UNION 
	SELECT 
		EMPLOYEE_ENTERPRISE_ID , UPPER(CROSSWALK_FIRST_NAME),UPPER(CROSSWALK_LAST_NAME),CTE.AMS_EMPLOYEE_KEY,CTE.AMS_SOURCE_SYSTEM_ID,
	    CTE.AMS_SYSTEM_CODE,
	    CTE.AMS_EMPLOYEE_ID,
	    CTE.WORKDAY_INTERNAL_ID,
	    CTE.CROSSWALK_INACTIVE,
	    CTE.CROSSWALK_DUP_FLAG,
	    CTE.EMPLOYEE_ID AS EXPECTED_WORKDAY_ID,IFF(CTE.AMS_EMPLOYEE_KEY IS NULL,'NOT IN AMS','POTENTIALLY_IN_AMS') AS REMARK,'MZ' AS cte,
	    CTE.PAYROLL_EMPLOYEE_KEY,
	    CTE.EMPLOYEE_HIRE_DATE
	    FROM CTE
    )
, APPLICANT AS 
	(SELECT APPLICANT_KEY , HIRED_DATETIME , APPLICANT_STATUS, REJECTED_DATETIME, REJECTION_REASON
		FROM DW_${var.SF_ENVIRONMENT}.HAH.FACT_APPLICANT_STATUS 
	QUALIFY ROW_NUMBER() OVER(PARTITION BY APPLICANT_KEY  ORDER BY ETL_INSERTED_DATE) =1
	)
, DUPS_APPLICANT AS 
	(SELECT DISTINCT 
				APP.LINKED_ID AS LINKED_ID,
				APP.APPLICANT_KEY AS WORKDAY_APPLICANT_KEY,
				APP.APPLICANT_ID AS WORKDAY_ID,
				APP2.FIRST_NAME, APP2.LAST_NAME ,
				APP2.APPLICANT_KEY AS PARADOX_APPLICANT_KEY,
				APP2.APPLICANT_ID AS PARADOX_APPLICANT_ID,
				APP2.SOURCE_SYSTEM_ID AS PARADOX_SOURCE_SYSTEM_ID,
				APP2.SYSTEM_CODE AS PARADOX_SYSTEM_CODE
		FROM DW_${var.SF_ENVIRONMENT}.HAH.DIM_APPLICANT AS APP 
		JOIN DW_${var.SF_ENVIRONMENT}.HAH.FACT_APPLICANT_STATUS AS S 
			ON APP.LINKED_ID = S.CANDIDATE_ID 
			AND APP.SOURCE_SYSTEM_ID = 36 
			AND APP.LINKED_ID IS NOT NULL
		JOIN DW_${var.SF_ENVIRONMENT}.HAH.DIM_APPLICANT AS APP2 
			ON S.APPLICANT_KEY = APP2.APPLICANT_KEY 
	)
, DUP_WORKDAY_ID AS
	(SELECT WORKDAY_ID
	FROM DUPS_APPLICANT 
	GROUP BY 1 HAVING COUNT(DISTINCT PARADOX_APPLICANT_KEY)>1)
, DUP_PARADOX_KEY AS
	(SELECT DISTINCT WORKDAY_ID
	FROM DUPS_APPLICANT 
	WHERE PARADOX_APPLICANT_KEY IN 
		(SELECT PARADOX_APPLICANT_KEY
		FROM DUPS_APPLICANT 
		GROUP BY 1 HAVING COUNT(DISTINCT WORKDAY_ID)>1)
	)
, FINAL_DATA AS
	(SELECT DISTINCT 
	C.* EXCLUDE (CTE, PAYROLL_EMPLOYEE_KEY)
	, FA.HIRED_DATETIME, 
	CASE WHEN FA.APPLICANT_KEY IS NOT NULL
		THEN TRUE 
		ELSE FALSE 
		END AS IN_APPLICANT,
	FA.APPLICANT_STATUS	AS PARADOX_STATUS,
	COALESCE(
			CASE 
				WHEN HIRED_DATETIME IS NULL
				AND IN_APPLICANT = TRUE
				THEN  'NULL HIREDATE IN APPLICANT'
				ELSE NULL 
			END, 
			CASE 
				WHEN IN_APPLICANT = FALSE 
				AND REMARK = 'NOT IN AMS'
				AND C.PAYROLL_EMPLOYEE_KEY IS NOT NULL 
				THEN  'MAPPED WITH PAYROLL RECORD'
				ELSE NULL 
			END, 
			CASE 
				WHEN HIRED_DATETIME IS NOT NULL 
				AND C.EMPLOYEE_HIRE_DATE IS NULL 
				AND REMARK = 'POTENTIALLY_IN_AMS'
				THEN 'DATA QUALITY ISSUE'
				ELSE NULL 
			END,
			CASE 
				WHEN C.WORKDAY_INTERNAL_ID <> C.EXPECTED_WORKDAY_ID
				AND C.WORKDAY_INTERNAL_ID IS NOT NULL
				THEN 'AMS MAPPED WITH ANOTHER ID'
				ELSE NULL 
			END,
			CASE 
				WHEN HIRED_DATETIME IS NOT NULL 
				AND C.EMPLOYEE_HIRE_DATE IS NOT NULL 
				AND C.EMPLOYEE_HIRE_DATE::DATE < '2019-11-21'::DATE
				THEN 'NOT CONSIDERED IN MAPPING: HIREDATE BEFORE ''2019-11-21'''
			ELSE NULL
			END
			,
			CASE 
				WHEN HIRED_DATETIME IS NOT NULL 
				AND C.EMPLOYEE_HIRE_DATE IS NOT NULL 
				AND HEX_DECODE_STRING(AP.SSN)::INT = VW_AEM.SSN 
				THEN 'DATA QUALITY ISSUE'
			ELSE NULL
			END
			,
			CASE WHEN C.EXPECTED_WORKDAY_ID IN 
				(SELECT *
				FROM DUP_WORKDAY_ID)
				THEN 'WORKDAY ID IS LINKING WITH TWO PARADOX KEYS'
			ELSE NULL
			END
			,
			CASE WHEN C.EXPECTED_WORKDAY_ID IN 
				(SELECT *
				FROM DUP_PARADOX_KEY)
				AND C.EMPLOYEE_HIRE_DATE IS NOT NULL 
				THEN 'ONE PARADOX KEY IS LINKING WITH TWO WORKDAY IDs'
			ELSE NULL 
			END 
			,
			CASE 
				WHEN HIRED_DATETIME IS NOT NULL 
				AND C.EMPLOYEE_HIRE_DATE IS NOT NULL 
				AND REMARK = 'POTENTIALLY_IN_AMS'
			THEN 'DATA QUALITY ISSUE'
			ELSE NULL
			END
		)
	AS REASON_FOR_NOT_MAPPING
FROM cte_2 C
LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_WORKDAY_PARADOX_APPLICANT_MAPPING VW 
	ON VW.WORKDAY_ID = C.EXPECTED_WORKDAY_ID
LEFT JOIN APPLICANT FA 
	ON FA.APPLICANT_KEY = VW.PARADOX_APPLICANT_KEY
LEFT JOIN DW_${var.SF_ENVIRONMENT}.HAH.DIM_APPLICANT AP 
	ON VW.PARADOX_APPLICANT_KEY = AP.APPLICANT_KEY 
LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_APPLICANT_EMPLOYEE_INPUT_QUERY VW_AEM 
	ON VW_AEM.EMPLOYEE_KEY = AP.APPLICANT_KEY 
--WHERE HIRED_DATETIME IS NOT NULL
--ORDER BY EXPECTED_WORKDAY_ID, REMARK;
)
SELECT DISTINCT 
		VW1.EMPLOYEE_ENTERPRISE_ID,  
		VW1.CROSSWALK_FIRST_NAME,
		VW1.CROSSWALK_LAST_NAME,
		VW1.WORKDAY_INTERNAL_ID, 
		VW2.AMS_EMPLOYEE_KEY AS POTENIAL_AMS_KEY, 
		VW2.EMPLOYEE_ENTERPRISE_ID AS POTENTIAL_AMS_ENTERPRISE_ID,
		VW2.WORKDAY_INTERNAL_ID AS POTENTIAL_AMS_WORKDAY_INTERNAL_ID, 
		VW2.EMPLOYEE_HIRE_DATE AS EMPLOYEE_HIRE_DATE,
		VW1.HIRED_DATETIME AS APPLICANT_HIRED_DATETIME,
		VW1.PARADOX_STATUS,
		COALESCE(CASE WHEN POTENIAL_AMS_KEY IS NULL 
				THEN 'NOT IN AMS' 
				ELSE NULL 
				END 
				,VW2.REASON_FOR_NOT_MAPPING, VW1.REASON_FOR_NOT_MAPPING)
			AS REMARK
FROM FINAL_DATA VW1 
LEFT JOIN FINAL_DATA VW2 
	ON VW1.EXPECTED_WORKDAY_ID = VW2.EXPECTED_WORKDAY_ID 
	AND VW2.REMARK = 'POTENTIALLY_IN_AMS'
WHERE VW1.REMARK = 'NOT IN AMS';
SQL
	or_replace = true 
	is_secure = false 
}

