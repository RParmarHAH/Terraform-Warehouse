resource "snowflake_procedure" "DW_PUBLIC_GET_MASTER_FACT_EMPLOYEE_CROSS_WALK" {
	name ="GET_MASTER_FACT_EMPLOYEE_CROSS_WALK"
	database = "DW_${var.SF_ENVIRONMENT}"
	schema = "PUBLIC"
	language  = "SQL"

	arguments {
		name = "STR_ETL_TASK_KEY"
		type = "VARCHAR(16777216)"
}	
	return_type = "VARCHAR(16777216)"
	execute_as = "OWNER"
	statement = <<-EOT

DECLARE
    return_result VARCHAR;

BEGIN
--*****************************************************************************************************************************
-- NAME:  GET_MASTER_FACT_EMPLOYEE_CROSS_WALK
-- 
-- PURPOSE: MASTER PROC TO UPDATE CROSSWALK AND MAINTAIN LOG FOR ANY CHANGES
--		
-- DEVELOPMENT LOG:
-- DATE        AUTHOR                NOTES:
-- --------    -------------------   -----------------------------------------------------------------------------------------------
-- 09/13/2023	Gaurav/ leo / Moin          Initial development 
--*****************************************************************************************************************************


------------------------------------------------------------------------------
-- ********************** FLOW TO REFRESH CROSSWALK ************************

-- STEP 1 : CREATE CLONE TABLE FOR DUPS BY CLONNING CURRENT CROSSWALK  
-- STEP 2 : RUN UPDATE STATEMENTS ON CLONE DUPS TABLE 
-- STEP 3 : INSERT MAPPING CHANGED AND KEYS CHANGED INTO LOG TABLE
-- STEP 4 : INSERT MERGED KEYS INTO THE MERGED TABLE
-- STEP 5 : SETTING INACTIVE FLAG TRUE FOR INACTIVE EMPLOYEES
-- STEP 6 : MERGE INTO ACTUAL TABLE 
-- STEP 7 : INSERT CHANGED RECORDS INTO HISTORICAL TABLE
-- STEP 8 : UPDATE AMS PUBLIC AND IVR ID




---------------------------------------------------------------------------
-- STEP 1 : CREATE CLONE TABLE FOR DUPS BY CLONNING CURRENT CROSSWALK 


-- Purpose of this table is to find any duplicates, will be cloned from main table
CREATE OR REPLACE TABLE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
CLONE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK;



-- *************************************************************************
--- STEP 2 : RUN UPDATE STATEMENTS ON CLONE DUPS TABLE 


-- 1) AMS EMPLOYEE KEY UPDATION BASED ON INTERNAL DEDUPE
-- UPDATING THE LATEST KEYS FROM DISCOVERY LAYER WHICH ARE CHANGED DUE TO DATA REASONS 

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.AMS_EMPLOYEE_KEY=EM.MASTER_EMPLOYEE_KEY
FROM  DISC_DEDUPE_${var.SF_ENVIRONMENT}.PUBLIC.VW_EMPLOYEE_MATCH_LIST EM 
WHERE EM.EMPLOYEE_KEY =CW_D.AMS_EMPLOYEE_KEY
AND CW_D.AMS_EMPLOYEE_KEY <>EM.MASTER_EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND EM.MASTER_EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT AMS_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY''); 



-- 2) AMS EMPLOYEE KEY UPDATION BASED ON INTEGRATION DEDUPE
-- UPDATING THE LATEST EMPLOYEE KEY FROM INTEGRATION LAYER CORRESPONDING TO ORIGINAL_EMPLOYEE_KEY

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.AMS_EMPLOYEE_KEY=DM.EMPLOYEE_KEY
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_MERGED DM
WHERE CW_D.AMS_EMPLOYEE_KEY =DM.ORIGINAL_EMPLOYEE_KEY 
AND CW_D.AMS_EMPLOYEE_KEY<>DM.EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND DM.EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT AMS_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY'');


-- 3) PAYROLL EMPLOYEE KEY UPDATION BASED ON INTERNAL DEDUPE
-- UPDATING THE LATEST KEYS FROM DISCOVERY LAYER WHICH ARE CHANGED DUE TO DATA REASONS 

UPDATE  DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.PAYROLL_EMPLOYEE_KEY = PM.MASTER_EMPLOYEE_KEY
FROM  DISC_DEDUPE_${var.SF_ENVIRONMENT}."PUBLIC".VW_PAYROLL_EMPLOYEE_MATCH_LIST PM 
WHERE PM.EMPLOYEE_KEY =CW_D.PAYROLL_EMPLOYEE_KEY
AND CW_D.PAYROLL_EMPLOYEE_KEY <> PM.MASTER_EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND PM.MASTER_EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY''); 


-- 4) PAYROLL EMPLOYEE KEY UPDATION BASED ON INTEGRATION DEDUPE
-- UPDATING THE LATEST EMPLOYEE KEY FROM INTEGRATION LAYER CORRESPONDING TO ORIGINAL_EMPLOYEE_KEY

UPDATE  DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.PAYROLL_EMPLOYEE_KEY=PM.EMPLOYEE_KEY
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_PAYROLL_MERGE_DEDUPE PM 
WHERE  CW_D.PAYROLL_EMPLOYEE_KEY =PM.ORIGINAL_EMPLOYEE_KEY 
AND CW_D.PAYROLL_EMPLOYEE_KEY<>PM.EMPLOYEE_KEY
AND CW_D.INACTIVE<> TRUE AND CW_D.DUP_FLAG <> TRUE
-- Added on 09/09/23
-- To exclude NY data
AND PM.EMPLOYEE_KEY NOT IN 
	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING 
	WHERE PAYROLL_STATE_CODE = ''NY''); 


-- 5) UPDATING DUP FLAG TRUE IN "EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS" FOR DUPLICATES 
-- UPDATING DUP FLAG TRUE FOR KEYS MAPPING GOT CHANGED ON AMS AND PAYROLL AND BOTH KEYS ARE PRESENT IN CROSSWALK TABLE, THIS WILL CREATE ISSUE IN MERGE STATEMENT

--BELOW CODE IS FOR NOT VALID SCENARIOS: WE ARE NOT GOING TO UPDATE INVALID SCENARIOS DATA

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW
SET DUP_FLAG = TRUE ,DUP_FLAG_REASON = ''MAPPING_INTERCHANGED''
FROM (SELECT  AMS_EMPLOYEE_KEY||''-''||PAYROLL_EMPLOYEE_KEY A_P
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS D
		WHERE EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING M 
			WHERE M.AMS_EMPLOYEE_KEY = D.AMS_EMPLOYEE_KEY )
		AND EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING M 
			WHERE M.PAYROLL_EMPLOYEE_KEY = D.PAYROLL_EMPLOYEE_KEY )
	EXCEPT 
	SELECT  AMS_EMPLOYEE_KEY||''-''||PAYROLL_EMPLOYEE_KEY A_P
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING D
		WHERE EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS M 
			WHERE M.AMS_EMPLOYEE_KEY = D.AMS_EMPLOYEE_KEY )
		AND EXISTS  
			(SELECT DISTINCT 1 FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS M 
			WHERE M.PAYROLL_EMPLOYEE_KEY = D.PAYROLL_EMPLOYEE_KEY )
	) 
	AS SRC 
WHERE SRC.A_P = CW.AMS_EMPLOYEE_KEY||''-''||CW.PAYROLL_EMPLOYEE_KEY
;


-- *************************************************************************
-- STEP 3 : INSERT MAPPING CHANGED AND KEYS CHANGED INTO LOG TABLE 
--- Scenario  1 IS CONSIDERED AS "NEWLY_MAPPED" AND 
--- Scenario  2,3,5 ARE CONSIDERED AS ''MAPPING REMOVED''& "MAPPING CHANGED" 



INSERT INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG
-----------------------------------
-- LOOKING FOR KEY GOT CHANGED
WITH KEYS_CHANGED AS 
	(SELECT CW.EMPLOYEE_ENTERPRISE_ID,
		''KEY_CHANGE'' AS CHANGE_TYPE,
		''AMS'' AS KEY_TYPE,
		CW.AMS_EMPLOYEE_KEY AS "AMS / PAYROLL_KEY", --OLD_KEY
		VW.MASTER_EMPLOYEE_KEY AS LATEST_DISC_LAYER_KEY, --LATEST_DISC_KEY
		EM.EMPLOYEE_KEY AS LATEST_INTEGRATION_LAYER_KEY, --LATEST_INTEGRATION_KEY
		NULL AS "PREVIOUSLY MAPPED PAYROLL / AMS",
		NULL AS OLD_MAPPED_APPLICANT
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS  D1
		ON CW.EMPLOYEE_ENTERPRISE_ID = D1.EMPLOYEE_ENTERPRISE_ID
		AND CW.AMS_EMPLOYEE_KEY <> D1.AMS_EMPLOYEE_KEY
		AND CW.INACTIVE <> TRUE 
		AND CW.DUP_FLAG <> TRUE
	LEFT JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}."PUBLIC".VW_EMPLOYEE_MATCH_LIST VW 
		ON VW.EMPLOYEE_KEY = CW.AMS_EMPLOYEE_KEY
		AND VW.MASTER_EMPLOYEE_KEY <> CW.AMS_EMPLOYEE_KEY 
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_MERGED EM 
		ON EM.ORIGINAL_EMPLOYEE_KEY = D1.AMS_EMPLOYEE_KEY 
		---------
		UNION 
		--------
	SELECT CW.EMPLOYEE_ENTERPRISE_ID,
			''KEY_CHANGE'' AS CHANGE_TYPE,
			''PAYROLL'' AS KEY_TYPE,
			CW.PAYROLL_EMPLOYEE_KEY AS "AMS / PAYROLL_KEY", --OLD_KEY
			VW.MASTER_EMPLOYEE_KEY AS LATEST_DISC_LAYER_KEY, --LATEST_DISC_KEY
			EMP.EMPLOYEE_KEY AS LATEST_INTEGRATION_LAYER_KEY, --LATEST_INTEGRATION_KEY
			NULL AS "PREVIOUSLY MAPPED PAYROLL / AMS",
			NULL AS OLD_MAPPED_APPLICANT
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS  D1
		ON CW.EMPLOYEE_ENTERPRISE_ID = D1.EMPLOYEE_ENTERPRISE_ID
		AND CW.PAYROLL_EMPLOYEE_KEY <> D1.PAYROLL_EMPLOYEE_KEY
		AND CW.INACTIVE <> TRUE 
		AND CW.DUP_FLAG <> TRUE
	LEFT JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}."PUBLIC".VW_PAYROLL_EMPLOYEE_MATCH_LIST VW 
		ON VW.EMPLOYEE_KEY = CW.PAYROLL_EMPLOYEE_KEY
		AND VW.MASTER_EMPLOYEE_KEY <> CW.PAYROLL_EMPLOYEE_KEY 
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_PAYROLL_MERGE_DEDUPE EMP 
		ON EMP.ORIGINAL_EMPLOYEE_KEY = D1.PAYROLL_EMPLOYEE_KEY
	)
-- TEMP CTE DURING TESTING
, KEY_CHANGED_FINAL AS 
	(SELECT * FROM KEYS_CHANGED 
	WHERE EMPLOYEE_ENTERPRISE_ID||''--''||NVL(KEY_TYPE,'''')||''--''||NVL("AMS / PAYROLL_KEY",'''')
	NOT IN 
		(SELECT  ENTERPRISE_ID||''--''||NVL(KEY_TYPE,'''')||''--''||NVL("AMS / PAYROLL_KEY",'''')
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG WHERE CHANGE_TYPE = ''KEY_CHANGE'')
	)
----------------------------------
-- LOOKING FOR MAPPING CHANGED
,AMS_MAPP AS
	(SELECT CW.EMPLOYEE_ENTERPRISE_ID,
			''AMS'' "KEY_TYPE",
			CW.AMS_EMPLOYEE_KEY AS EMPLOYEE_KEY,
			CW.PAYROLL_EMPLOYEE_KEY AS OLD_MAPPED,
			NULL AS OLD_MAPPED_APPLICANT,
			VW.PAYROLL_EMPLOYEE_KEY AS NEW_MAPPING
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
		ON CW.AMS_EMPLOYEE_KEY = VW.AMS_EMPLOYEE_KEY 
		AND  NVL(CW.PAYROLL_EMPLOYEE_KEY,'''') <> NVL(VW.PAYROLL_EMPLOYEE_KEY,'''') 	
	UNION
	SELECT CW.EMPLOYEE_ENTERPRISE_ID,
			''AMS'' "KEY_TYPE",
			CW.AMS_EMPLOYEE_KEY AS EMPLOYEE_KEY,
			NULL AS OLD_MAPPED,
			CW.APPLICANT_EMPLOYEE_KEY AS OLD_MAPPED_APPLICANT,
			NULL AS NEW_MAPPING
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
		ON CW.AMS_EMPLOYEE_KEY = VW.AMS_EMPLOYEE_KEY 
		AND NVL(CW.APPLICANT_EMPLOYEE_KEY,'''') <> NVL(VW.APPLICANT_EMPLOYEE_KEY,'''')
	)
,PAYROLL_MAPP AS
(SELECT CW.EMPLOYEE_ENTERPRISE_ID,
		''PAYROLL'' "KEY_TYPE",
		CW.PAYROLL_EMPLOYEE_KEY AS EMPLOYEE_KEY,
		CW.AMS_EMPLOYEE_KEY AS OLD_MAPPED,
		NULL AS OLD_MAPPED_APPLICANT,
		VW.AMS_EMPLOYEE_KEY AS NEW_MAPPING
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
	ON CW.PAYROLL_EMPLOYEE_KEY = VW.PAYROLL_EMPLOYEE_KEY 
	AND NVL(CW.AMS_EMPLOYEE_KEY,'''') <> NVL(VW.AMS_EMPLOYEE_KEY,'''') 
)
,MAPPING_FINAL AS 
( SELECT EMPLOYEE_ENTERPRISE_ID,
		CASE WHEN (OLD_MAPPED IS NULL AND NEW_MAPPING IS NOT NULL)
			THEN ''NEWLY_MAPPED''
			WHEN (NEW_MAPPING IS NULL AND OLD_MAPPED IS NOT NULL)
			THEN ''MAPPING REMOVED''
			WHEN (OLD_MAPPED IS NOT NULL AND NEW_MAPPING IS NOT NULL)
			THEN ''MAPPING CHANGED''
			ELSE ''APPLICANT_MAPPING_CHANGED''
			END AS CHANGE_TYPE,
			KEY_TYPE,
			EMPLOYEE_KEY AS "AMS / PAYROLL_KEY",
			NULL AS LATEST_DISC_LAYER_KEY,
			NULL AS LATEST_INTEGRATION_LAYER_KEY,
			OLD_MAPPED AS "PREVIOUSLY MAPPED PAYROLL / AMS",
			OLD_MAPPED_APPLICANT
	FROM (SELECT * FROM AMS_MAPP
			UNION 
			SELECT * FROM PAYROLL_MAPP)
	------------------------
	-- TEMPORARY CONDITION
	WHERE EMPLOYEE_ENTERPRISE_ID||''-''||NVL(KEY_TYPE,'''')||''-''||NVL("AMS / PAYROLL_KEY",'''')||''-''||NVL("PREVIOUSLY MAPPED PAYROLL / AMS",'''')||''-''||NVL(OLD_MAPPED_APPLICANT,'''')
	NOT IN 
		(SELECT ENTERPRISE_ID||''-''||NVL(KEY_TYPE,'''')||''-''||NVL("AMS / PAYROLL_KEY",'''')||''-''||NVL("PREVIOUSLY MAPPED PAYROLL / AMS",'''')||''-''||NVL(OLD_MAPPED_APPLICANT,'''')
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
)
SELECT *,:STR_ETL_TASK_KEY AS ETL_INSERTED_TASK_KEY
		,:STR_ETL_TASK_KEY AS ETL_INSERTED_TASK_KEY
		,CURRENT_TIMESTAMP
		,CURRENT_USER
		,CURRENT_TIMESTAMP
		,CURRENT_USER
FROM (SELECT * FROM KEY_CHANGED_FINAL
		UNION SELECT * FROM MAPPING_FINAL);



-------------------------------------------------------------
-- NEED TO RUN THIS BEFORE MAPPING TABLE AND AFTER CHANGE LOG
-- UPDATING APPLICANT KEYS 
-- (DOING THIS BECAUSE MAPPING GOT CHANGED FOR APPLICANT KEYS)

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK TEMP_C
SET TEMP_C.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY 
FROM
	( SELECT COALESCE(CL."AMS / PAYROLL_KEY",VW.AMS_EMPLOYEE_KEY) AS AMS_EMPLOYEE_KEY, VW.APPLICANT_EMPLOYEE_KEY 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL -- JOINING ON CHANGE LOG TABLE TO GET THE LATEST KEYS
		ON COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,CL."AMS / PAYROLL_KEY") = VW.AMS_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) SRC
	WHERE TEMP_C.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY 
	AND NVL(TEMP_C.APPLICANT_EMPLOYEE_KEY,'''') <> NVL(SRC.APPLICANT_EMPLOYEE_KEY,'''')
	;

	
	
-- *************************************************************************
-- STEP 4 : INSERT MERGED KEYS INTO THE MERGED TABLE 
-- SOME KEYS ARE MERGED INTO ONE DUE TO SOME DATA CHANGES


--SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED;

--CREATE OR REPLACE TABLE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED
--CLONE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED;


INSERT INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED
-- Logic
-------------------------------------------
-- ************* CASE 1 ********************
-- SCENARIO 4 - FOR VIEW AND INTEGRATION CHANGES
-- MERGING BECAUSE OF KEY CHANGE
---------------------------------------------
WITH CROSSWALK AS
	(
	-- AMS AND PAYROLL KEYS FROM EMPLOYEE_CROSS_WALK TABLE
	SELECT DISTINCT AMS_EMPLOYEE_KEY,PAYROLL_EMPLOYEE_KEY,EMPLOYEE_ENTERPRISE_ID  
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE )
------------------
,AMS_KEY_CHANGED AS
		(SELECT 
		CWD.AMS_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
		CWM.AMS_EMPLOYEE_KEY AS EMPLOYEE_KEY,
		CWD.PAYROLL_EMPLOYEE_KEY AS PAYROLL_EMPLOYEE_KEY 
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CWD
JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CWM -- NEED TO JOIN TO GET OLDER KEY 
	ON CWD.EMPLOYEE_ENTERPRISE_ID = CWM.EMPLOYEE_ENTERPRISE_ID 
WHERE CWD.AMS_EMPLOYEE_KEY IN 
	(
	SELECT AMS_EMPLOYEE_KEY
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE 
	-- FILTERING THOSE KEYS WHICH 
	AND AMS_EMPLOYEE_KEY IN 
		(SELECT COALESCE(LATEST_INTEGRATION_LAYER_KEY,LATEST_DISC_LAYER_KEY)
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG 
		WHERE CHANGE_TYPE =''KEY_CHANGE''
		AND KEY_TYPE= ''AMS'' 
		AND ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		)
	GROUP BY 1 HAVING COUNT(*)>1
	)
	)
,PAYROLL_KEY_CHANGED AS
		(
		SELECT 
		CWD.PAYROLL_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
		CWM.PAYROLL_EMPLOYEE_KEY AS EMPLOYEE_KEY,
		CWD.AMS_EMPLOYEE_KEY AS PAYROLL_EMPLOYEE_KEY 
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CWD
JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CWM -- NEED TO JOIN TO GET OLDER KEY 
	ON CWD.EMPLOYEE_ENTERPRISE_ID = CWM.EMPLOYEE_ENTERPRISE_ID 
WHERE CWD.PAYROLL_EMPLOYEE_KEY IN 
	(
	SELECT PAYROLL_EMPLOYEE_KEY
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
	WHERE INACTIVE <> TRUE AND DUP_FLAG <> TRUE 
	-- FILTERING THOSE KEYS WHICH 
	AND PAYROLL_EMPLOYEE_KEY IN 
		(SELECT COALESCE(LATEST_INTEGRATION_LAYER_KEY,LATEST_DISC_LAYER_KEY)
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG 
		WHERE CHANGE_TYPE =''KEY_CHANGE''
		AND KEY_TYPE = ''PAYROLL''
		AND ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		)
	GROUP BY 1 HAVING COUNT(*)>1
	)
	)
,AMS_RANKED AS 
	(
	-- PROVIDING RANK TO MASTER_KEY AND EMPLOYEE_KEY ON THE BASIS OF PAYROLL_EMPLOYEE_KEY,ENTERPRISE_ID
	SELECT CW.AMS_EMPLOYEE_KEY AS CURRENT_KEY,
			AMS_ML.MASTER_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
			CW.EMPLOYEE_ENTERPRISE_ID,
			CW.PAYROLL_EMPLOYEE_KEY,   
			RANK() OVER(PARTITION BY MASTER_EMPLOYEE_KEY ORDER BY CW.PAYROLL_EMPLOYEE_KEY,EMPLOYEE_ENTERPRISE_ID) AS RANK
	FROM  CROSSWALK CW
	JOIN  AMS_KEY_CHANGED AMS_ML
		ON AMS_ML.EMPLOYEE_KEY  = CW.AMS_EMPLOYEE_KEY 
	WHERE CW.AMS_EMPLOYEE_KEY IN 
		(SELECT MASTER_EMPLOYEE_KEY FROM AMS_KEY_CHANGED
		UNION 
		SELECT EMPLOYEE_KEY FROM AMS_KEY_CHANGED)
	)
,PAYROLL_RANKED AS	 
	(
	-- PROVIDING RANK TO MASTER_KEY AND EMPLOYEE_KEY ON THE BASIS OF AMS_EMPLOYEE_KEY,ENTERPRISE_ID
	SELECT CW.PAYROLL_EMPLOYEE_KEY AS CURRENT_KEY,
			P_ML.MASTER_EMPLOYEE_KEY AS MASTER_EMPLOYEE_KEY,
			CW.EMPLOYEE_ENTERPRISE_ID,
			CW.AMS_EMPLOYEE_KEY,
			RANK() OVER(PARTITION BY MASTER_EMPLOYEE_KEY ORDER BY CW.AMS_EMPLOYEE_KEY,EMPLOYEE_ENTERPRISE_ID) AS RANK
	FROM  CROSSWALK CW
	JOIN  PAYROLL_KEY_CHANGED P_ML
		ON P_ML.EMPLOYEE_KEY  = CW.PAYROLL_EMPLOYEE_KEY 
	WHERE CW.PAYROLL_EMPLOYEE_KEY IN 
		(SELECT MASTER_EMPLOYEE_KEY FROM PAYROLL_KEY_CHANGED
		UNION 
		SELECT EMPLOYEE_KEY FROM PAYROLL_KEY_CHANGED)
	)
, AMS_FINAL AS 
	(
	-- ASSIGNING LATEST ENTERPRISE_ID TO OLDER RECORD, AND MERGED ENTERPRISE_ID TO NEWER RECORD
	SELECT A1.EMPLOYEE_ENTERPRISE_ID AS LATEST_EMPLOYEE_ENTERPRISE_ID,
			A2.EMPLOYEE_ENTERPRISE_ID AS OLD_EMPLOYEE_ENTERPRISE_ID,
			''KEYS_MERGED'' AS MERGE_REASON
	FROM AMS_RANKED A1  
	JOIN AMS_RANKED A2
	ON A1.MASTER_EMPLOYEE_KEY = A2.MASTER_EMPLOYEE_KEY
	WHERE A1.RANK = 1 AND A2.RANK >= 2
	AND NOT (A1.PAYROLL_EMPLOYEE_KEY IS NOT NULL AND A2.PAYROLL_EMPLOYEE_KEY IS NOT NULL)
	)
, PAYROLL_FINAL AS 
	(
	-- ASSIGNING LATEST ENTERPRISE_ID TO OLDER RECORD, AND MERGED ENTERPRISE_ID TO NEWER RECORD
	SELECT P1.EMPLOYEE_ENTERPRISE_ID AS LATEST_EMPLOYEE_ENTERPRISE_ID,
			P2.EMPLOYEE_ENTERPRISE_ID AS OLD_EMPLOYEE_ENTERPRISE_ID,
			''KEYS_MERGED'' AS MERGE_REASON
	FROM PAYROLL_RANKED P1  
	JOIN PAYROLL_RANKED P2
	ON P1.MASTER_EMPLOYEE_KEY = P2.MASTER_EMPLOYEE_KEY
	WHERE P1.RANK = 1 AND P2.RANK >=2
	)
-------------------------------------------
-- ************* CASE 2 ********************
-- SCENARIO 1 - FOR MAPPING CHANGE
-- MERGING BECAUSE OF MAPPED WITH EACH OTHER
-- MAKING AMS RECORD AS OLDER AND PAYROLL AS LATEST (FOR NOW)
---------------------------------------------
,CROSSWALK_NOT_MAPPED_KEYS  AS 
	(
	-- AMS keys not mapped with any payroll
	SELECT DISTINCT 
	COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY, CW.AMS_EMPLOYEE_KEY) AS KEY
	FROM CROSSWALK CW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL -- JOINING ON CHANGE LOG TABLE TO GET THE LATEST KEYS WHICH GOT CHANGED IN PREVIOUS STEP
		ON CL."AMS / PAYROLL_KEY" = CW.AMS_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		WHERE PAYROLL_EMPLOYEE_KEY IS NULL 
		AND AMS_EMPLOYEE_KEY IS NOT NULL
		-- Putting this condition for enterprise IDs which are going to be inactive
		AND CW.EMPLOYEE_ENTERPRISE_ID NOT IN 
			(SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM AMS_FINAL)
	UNION
	-- Payroll keys not mapped with any AMS
	SELECT DISTINCT COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY, CW.PAYROLL_EMPLOYEE_KEY)  
	FROM CROSSWALK CW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL 
		ON CL."AMS / PAYROLL_KEY" = CW.PAYROLL_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
		WHERE AMS_EMPLOYEE_KEY IS NULL 
		AND PAYROLL_EMPLOYEE_KEY IS NOT NULL
		-- Putting this condition for enterprise IDs which are going to be inactive
		AND CW.EMPLOYEE_ENTERPRISE_ID NOT IN 
			(SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM PAYROLL_FINAL)
	)
,RECENTLY_MAPPED AS 
	(
	SELECT *
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING --table contains only mapped keys 
	WHERE PAYROLL_EMPLOYEE_KEY IN (SELECT * FROM CROSSWALK_NOT_MAPPED_KEYS)
		OR AMS_EMPLOYEE_KEY IN (SELECT * FROM CROSSWALK_NOT_MAPPED_KEYS)
	)
,MAPPING_FINAL AS 
	(SELECT 
		CW_P.EMPLOYEE_ENTERPRISE_ID AS LATEST_EMPLOYEE_ENTERPRISE_ID, -- Payroll Enterprise ID
			CW_A.EMPLOYEE_ENTERPRISE_ID AS OLD_EMPLOYEE_ENTERPRISE_ID, -- AMS Enterprise ID
			''MAPPING_CHANGED'' AS MERGE_REASON
	FROM RECENTLY_MAPPED REC_MAP
	JOIN 
	(SELECT DISTINCT COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,C.PAYROLL_EMPLOYEE_KEY) AS PAYROLL_EMPLOYEE_KEY,C.EMPLOYEE_ENTERPRISE_ID
	FROM CROSSWALK C
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL 
		ON CL."AMS / PAYROLL_KEY" = C.PAYROLL_EMPLOYEE_KEY 
		AND CL.CHANGE_TYPE = ''KEY_CHANGE''
		AND CL."KEY_TYPE" = ''PAYROLL''
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) AS CW_P
		ON REC_MAP.PAYROLL_EMPLOYEE_KEY = CW_P.PAYROLL_EMPLOYEE_KEY 
	--
	JOIN 
	(SELECT DISTINCT COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,C.AMS_EMPLOYEE_KEY) AS AMS_EMPLOYEE_KEY, C.EMPLOYEE_ENTERPRISE_ID
	,C.PAYROLL_EMPLOYEE_KEY
	FROM CROSSWALK  C
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL 
		ON CL."AMS / PAYROLL_KEY" = C.AMS_EMPLOYEE_KEY 
		AND CL.CHANGE_TYPE = ''KEY_CHANGE''
		AND CL."KEY_TYPE" = ''AMS''
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) AS CW_A
		ON REC_MAP.AMS_EMPLOYEE_KEY = CW_A.AMS_EMPLOYEE_KEY
	WHERE NOT (CW_P.PAYROLL_EMPLOYEE_KEY IS NOT NULL AND CW_A.PAYROLL_EMPLOYEE_KEY IS NOT NULL)
	)
-------------------------------------------
-- ************* CASE 3 ********************
-- MERGING BECAUSE OF UNMAPPED APPLICANT KEYS MAPPED GOT MAPPED WITH AMS KEY
-- MAKING UNMAPPED RECORD AS OLDER AND MAPPED AS LATEST (FOR NOW)
---------------------------------------------
, APPLICANT_DUPS AS 
		(SELECT EMPLOYEE_ENTERPRISE_ID ,APPLICANT_EMPLOYEE_KEY ,AMS_EMPLOYEE_KEY ,
				RANK() OVER(PARTITION BY APPLICANT_EMPLOYEE_KEY ORDER BY AMS_EMPLOYEE_KEY) RANK 
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
			WHERE APPLICANT_EMPLOYEE_KEY IN
				(SELECT APPLICANT_EMPLOYEE_KEY 
				FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK
				WHERE INACTIVE <> TRUE
				-- TEMPORARY EXCLUDING
				AND APPLICANT_EMPLOYEE_KEY <> ''87c0f006ae72b8114940595763b1d068''
				GROUP BY 1 HAVING COUNT(*)>1) -- DUPLICATE APPLICANT KEYS
		)
,APPLICANT_DUPS_FINAL AS
	(SELECT  
			A1.EMPLOYEE_ENTERPRISE_ID AS LATEST_ENTERPRISE_ID,
			A2.EMPLOYEE_ENTERPRISE_ID AS OLD_ENTERPRISE_ID,
			''APPLICANT_KEYS_MERGED'' AS MERGE_REASON
		FROM APPLICANT_DUPS A1 
		JOIN APPLICANT_DUPS A2 
			ON A1.APPLICANT_EMPLOYEE_KEY = A2.APPLICANT_EMPLOYEE_KEY
		WHERE A1.RANK = 1 AND A2.RANK = 2
		-- Not considering enterprise IDs which are going to get inactive through previous CTEs i.e Keys_Change and Mapping_change  
		AND A1.EMPLOYEE_ENTERPRISE_ID NOT IN 
				(SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM AMS_FINAL 
				UNION 
				SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM PAYROLL_FINAL 
				UNION 
				SELECT OLD_EMPLOYEE_ENTERPRISE_ID FROM MAPPING_FINAL)
	)
,FINAL AS 
	(SELECT * FROM AMS_FINAL 
	UNION 
	SELECT * FROM PAYROLL_FINAL 
	UNION 
	SELECT * FROM MAPPING_FINAL
	UNION 
	SELECT * FROM APPLICANT_DUPS_FINAL)
-----------------------------------
SELECT COALESCE((SELECT MAX(ID) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED),0)+ROW_NUMBER() OVER(ORDER BY (SELECT 1)) AS ID,
		LATEST_EMPLOYEE_ENTERPRISE_ID,
		OLD_EMPLOYEE_ENTERPRISE_ID,
		MERGE_REASON,
		TRUE AS ACTIVE_FLAG,
		CURRENT_TIMESTAMP AS INSERTED_DATE,
		CURRENT_USER AS INSERTED_BY
FROM FINAL
-- TEMPORARY CONDITION
WHERE LATEST_EMPLOYEE_ENTERPRISE_ID||''--''||OLD_EMPLOYEE_ENTERPRISE_ID||''--''||MERGE_REASON
NOT IN 
	(SELECT LATEST_ENTERPRISE_ID||''--''||OLD_ENTERPRISE_ID||''--''||MERGE_REASON
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED)
AND LATEST_EMPLOYEE_ENTERPRISE_ID <> OLD_EMPLOYEE_ENTERPRISE_ID
;




-- *************************************************************************
-- STEP 5 : SETTING INACTIVE FLAG TRUE FOR INACTIVE EMPLOYEES
-- AND DUPLICATE APPLICANT KEYS WHICH ARE NEWLY MAPPED WITH ANOTHER EMPLOYEE KEYS


UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
SET INACTIVE = TRUE 
WHERE EMPLOYEE_ENTERPRISE_ID IN 
	(SELECT OLD_ENTERPRISE_ID FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED
	WHERE INSERTED_DATE = (SELECT MAX(INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_MERGED)
	);

-- SETTING INACTIVE TRUE FOR THE APPLICANT KEYS WHICH ARE NEWLY MAPPED WITH AN AMS WHICH IS NOT CURRENTLY PRESENT IN CROSSWALK
-- BUT THE PAYROLL CORRESPONDING TO THAT AMS IS ALREADY PRESENT IN CROSSWALK
-- MAKING THE ENTERPRISE ID INACTIVE WHICH CONTAINS ONLY APPLICANT, AND MAPPING THE AMS AND APPLICANT TO THAT PAYROLL
 
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
SET INACTIVE = TRUE
WHERE EMPLOYEE_ENTERPRISE_ID IN 
	(SELECT CW.EMPLOYEE_ENTERPRISE_ID 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW 
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW 
		ON VW.APPLICANT_EMPLOYEE_KEY = CW.APPLICANT_EMPLOYEE_KEY 
	WHERE CW.INACTIVE <> TRUE 
		AND CW.AMS_EMPLOYEE_KEY IS NULL 
		AND VW.AMS_EMPLOYEE_KEY IS NOT NULL);


-- Updating AMS key Null for the records where the records were previously mapped but later got Unmapped
-- Doing this to keep the older Enterprise ID for Payroll record and the newer record will get created for AMS

--UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
--SET	 AMS_EMPLOYEE_KEY = NULL,
--	AMS_SOURCE_SYSTEM_ID = NULL,
--	AMS_SYSTEM_CODE = NULL,
--	AMS_EMPLOYEE_ID = NULL,
--	AMS_METADATA = NULL,
--	APPLICANT_EMPLOYEE_KEY = NULL
--WHERE PAYROLL_EMPLOYEE_KEY IN 
--	(
--	(SELECT NVL(PAYROLL_EMPLOYEE_KEY,'''') AS PAYROLL_EMPLOYEE_KEY
--	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
--	WHERE (AMS_EMPLOYEE_KEY IS NOT NULL AND PAYROLL_EMPLOYEE_KEY IS NOT NULL)
--	AND INACTIVE <> TRUE AND DUP_FLAG <> TRUE)
--	---------
--	EXCEPT  
--	--------
--	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY 
--	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING)
--	);

-- Updated logic on 09/09/2023 for new case 6 founded

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS 
SET AMS_EMPLOYEE_KEY = NULL, 
	AMS_SOURCE_SYSTEM_ID = NULL, 
	AMS_SYSTEM_CODE = NULL, 
	AMS_EMPLOYEE_ID = NULL, 
	AMS_METADATA = NULL,
	APPLICANT_EMPLOYEE_KEY = NULL,
    APPLICANT_SOURCE_SYSTEM_ID = NULL,
    APPLICANT_SYSTEM_CODE = NULL
WHERE NVL(PAYROLL_EMPLOYEE_KEY,'''')||''-''||NVL(AMS_EMPLOYEE_KEY,'''') NOT IN 
	(SELECT DISTINCT PAYROLL_EMPLOYEE_KEY||''-''||AMS_EMPLOYEE_KEY 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING)
AND (AMS_EMPLOYEE_KEY IS NOT NULL AND PAYROLL_EMPLOYEE_KEY IS NOT NULL)
AND INACTIVE <> TRUE AND DUP_FLAG <> TRUE;
	

--  UPDATING KEYS FROM FACT_AMS_PAYROLL_MAPPING_TABLE IN "EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS"

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS CW_D
SET CW_D.PAYROLL_EMPLOYEE_KEY = FM.PAYROLL_EMPLOYEE_KEY,
	CW_D.AMS_EMPLOYEE_KEY = FM.AMS_EMPLOYEE_KEY
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.FACT_AMS_PAYROLL_MAPPING FM 
WHERE (
		FM.AMS_EMPLOYEE_KEY = CW_D.AMS_EMPLOYEE_KEY 
		OR FM.PAYROLL_EMPLOYEE_KEY = CW_D.PAYROLL_EMPLOYEE_KEY
	  )
AND (CW_D.INACTIVE <> TRUE AND CW_D.DUP_FLAG <> TRUE)
AND FM.PAYROLL_STATE_CODE <> ''NY''
;	

-- UPDATING DUP AND INACTIVE IN "EMPLOYEE_CROSS_WALK_TO_UPDATE_MAIN" TABLE 
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK M
SET	 M.DUP_FLAG = T.DUP_FLAG,
	M.DUP_FLAG_REASON = T.DUP_FLAG_REASON,
	M.INACTIVE = T.INACTIVE
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS T 
WHERE T.EMPLOYEE_ENTERPRISE_ID = M.EMPLOYEE_ENTERPRISE_ID 
AND (T.DUP_FLAG = TRUE OR T.INACTIVE = TRUE);


-- UPDATING KEYS CHANGED IN "EMPLOYEE_CROSS_WALK_TO_UPDATE_MAIN"

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK M
SET M.AMS_EMPLOYEE_KEY = T.AMS_EMPLOYEE_KEY, 
	M.PAYROLL_EMPLOYEE_KEY = T.PAYROLL_EMPLOYEE_KEY,
	M.APPLICANT_EMPLOYEE_KEY = T.APPLICANT_EMPLOYEE_KEY,
	M.AMS_SOURCE_SYSTEM_ID = M.AMS_SOURCE_SYSTEM_ID, 
	M.AMS_SYSTEM_CODE = T.AMS_SYSTEM_CODE, 
	M.AMS_EMPLOYEE_ID = T.AMS_EMPLOYEE_ID, 
	M.AMS_METADATA = T.AMS_METADATA,
    M.APPLICANT_SOURCE_SYSTEM_ID = T.APPLICANT_SOURCE_SYSTEM_ID,
    M.APPLICANT_SYSTEM_CODE = T.APPLICANT_SYSTEM_CODE
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS T 
WHERE T.EMPLOYEE_ENTERPRISE_ID = M.EMPLOYEE_ENTERPRISE_ID 
AND NOT (T.DUP_FLAG = TRUE OR T.INACTIVE = TRUE)
;

--------
-- UPDATING APPLICANT KEYS 
-- (DOING THIS BECAUSE MAPPING GOT CHANGED FOR APPLICANT KEYS)

UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK TEMP_C
SET TEMP_C.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY 
FROM
	( SELECT COALESCE(CL."AMS / PAYROLL_KEY",VW.AMS_EMPLOYEE_KEY) AS AMS_EMPLOYEE_KEY, VW.APPLICANT_EMPLOYEE_KEY 
	FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK VW
	LEFT JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG CL -- JOINING ON CHANGE LOG TABLE TO GET THE LATEST KEYS
		ON COALESCE(CL.LATEST_INTEGRATION_LAYER_KEY,CL.LATEST_DISC_LAYER_KEY,CL."AMS / PAYROLL_KEY") = VW.AMS_EMPLOYEE_KEY
		AND CL.ETL_INSERTED_DATE = (SELECT MAX(ETL_INSERTED_DATE) FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_CHANGE_LOG)
	) SRC
	WHERE TEMP_C.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY 
	AND NVL(TEMP_C.APPLICANT_EMPLOYEE_KEY,'''') <> NVL(SRC.APPLICANT_EMPLOYEE_KEY,'''')
	;

-- *************************************************************************
-- STEP 6 : MERGE INTO ACTUAL TABLE 

	
MERGE INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK  AS cw
USING 
	(WITH DUP_FLAG_TRUE_KEYS AS--189,768
		(
		SELECT DISTINCT AMS_EMPLOYEE_KEY KEY
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND AMS_EMPLOYEE_KEY IS NOT NULL
		UNION 
		SELECT DISTINCT PAYROLL_EMPLOYEE_KEY 
		FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_TEMP_FOR_DUPS
		WHERE DUP_FLAG = TRUE 
		AND PAYROLL_EMPLOYEE_KEY IS NOT NULL
		)
	SELECT * FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK
		WHERE NVL(AMS_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS)
		 AND NVL(PAYROLL_EMPLOYEE_KEY,'''') NOT IN (SELECT * FROM DUP_FLAG_TRUE_KEYS) 
	 ) 	 
--	DW_${var.SF_ENVIRONMENT}.INTEGRATION.VW_EMPLOYEE_CROSS_WALK
	 as src
    ON
    	(cw.PAYROLL_EMPLOYEE_KEY = src.PAYROLL_EMPLOYEE_KEY 
    	OR cw.AMS_EMPLOYEE_KEY = src.AMS_EMPLOYEE_KEY 
        OR CW.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY
        )
        AND CW.DUP_FLAG <> TRUE 
		AND INACTIVE <> TRUE
WHEN MATCHED THEN UPDATE
SET
	CW.FIRST_NAME = SRC.FIRST_NAME,
	CW.LAST_NAME = SRC.LAST_NAME,
	CW.BRANCH_STATE_CODE = SRC.BRANCH_STATE_CODE,
	CW.AMS_EMPLOYEE_KEY = SRC.AMS_EMPLOYEE_KEY,
	CW.AMS_SOURCE_SYSTEM_ID = SRC.AMS_SOURCE_SYSTEM_ID,
	CW.AMS_SYSTEM_CODE = SRC.AMS_SYSTEM_CODE,
	CW.AMS_EMPLOYEE_ID = SRC.AMS_EMPLOYEE_ID,
	CW.AMS_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.AMS_METADATA),
	CW.PAYROLL_EMPLOYEE_KEY = SRC.PAYROLL_EMPLOYEE_KEY,
	CW.PAYROLL_SOURCE_SYSTEM_ID = SRC.PAYROLL_SOURCE_SYSTEM_ID,
	CW.PAYROLL_SYSTEM_CODE = SRC.PAYROLL_SYSTEM_CODE,
	CW.PAYROLL_EMPLOYEE_ID = SRC.PAYROLL_EMPLOYEE_ID,
	CW.PAYROLL_METADATA = OBJECT_CONSTRUCT(CW.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.PAYROLL_METADATA),
	CW.APPLICANT_EMPLOYEE_KEY = SRC.APPLICANT_EMPLOYEE_KEY,
	CW.APPLICANT_SOURCE_SYSTEM_ID = SRC.APPLICANT_SOURCE_SYSTEM_ID,
	CW.APPLICANT_SYSTEM_CODE = SRC.APPLICANT_SYSTEM_CODE,
	CW.APPLICANT_EMPLOYEE_ID = SRC.APPLICANT_EMPLOYEE_ID,
	CW.EXCEPTION_FLAG = SRC.EXCEPTION_FLAG,
	CW.DUP_FLAG = FALSE,
    CW.DUP_FLAG_REASON = NULL,
	CW.INACTIVE = FALSE,
	CW.ETL_LAST_UPDATED_DATE = CURRENT_TIMESTAMP,
	CW.ETL_LAST_UPDATED_BY = CURRENT_USER
--	CW.BROADSPIRE_ID = SRC.BROADSPIRE_ID
WHEN NOT MATCHED THEN INSERT
	(
	EMPLOYEE_ENTERPRISE_ID,
	FIRST_NAME,
	LAST_NAME,
	BRANCH_STATE_CODE,
	AMS_EMPLOYEE_KEY,
	AMS_SOURCE_SYSTEM_ID,
	AMS_SYSTEM_CODE,
	AMS_EMPLOYEE_ID,
	AMS_METADATA,
	PAYROLL_EMPLOYEE_KEY,
	PAYROLL_SOURCE_SYSTEM_ID,
	PAYROLL_SYSTEM_CODE,
	PAYROLL_EMPLOYEE_ID,
	PAYROLL_METADATA,
	APPLICANT_EMPLOYEE_KEY,
	APPLICANT_SOURCE_SYSTEM_ID,
	APPLICANT_SYSTEM_CODE,
	APPLICANT_EMPLOYEE_ID,
	EXCEPTION_FLAG,
	ETL_TASK_KEY,
	ETL_INSERTED_TASK_KEY,
	ETL_INSERTED_DATE,
	ETL_INSERTED_BY,
	ETL_LAST_UPDATED_DATE,
	ETL_LAST_UPDATED_BY,
	ETL_DELETED_FLAG,
	DUP_FLAG,
	DUP_FLAG_REASON,
	INACTIVE
--	BROADSPIRE_ID
	)
VALUES 
    (
	SRC.EMPLOYEE_ENTERPRISE_ID,
	SRC.FIRST_NAME,
	SRC.LAST_NAME,
	SRC.BRANCH_STATE_CODE,
	SRC.AMS_EMPLOYEE_KEY,
	SRC.AMS_SOURCE_SYSTEM_ID,
	SRC.AMS_SYSTEM_CODE,
	SRC.AMS_EMPLOYEE_ID,
	OBJECT_CONSTRUCT(SRC.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.AMS_METADATA),
	SRC.PAYROLL_EMPLOYEE_KEY,
	SRC.PAYROLL_SOURCE_SYSTEM_ID,
	SRC.PAYROLL_SYSTEM_CODE,
	SRC.PAYROLL_EMPLOYEE_ID,
	OBJECT_CONSTRUCT(SRC.EMPLOYEE_ENTERPRISE_ID::VARCHAR, SRC.PAYROLL_METADATA),
	SRC.APPLICANT_EMPLOYEE_KEY,
	SRC.APPLICANT_SOURCE_SYSTEM_ID,
	SRC.APPLICANT_SYSTEM_CODE,
	SRC.APPLICANT_EMPLOYEE_ID,
	SRC.EXCEPTION_FLAG,
    :STR_ETL_TASK_KEY,
    :STR_ETL_TASK_KEY,
    CURRENT_TIMESTAMP,
    CURRENT_USER,
    CURRENT_TIMESTAMP,
    CURRENT_USER,
    0,0,NULL,FALSE
--	SRC.BROADSPIRE_ID
	);


-- *************************************************************************
-- STEP 7 : UPDATE AMS_IVR_ID AND AMS_PUBLIC_ID

----UPDATE ALAYACRE 
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK T1
SET T1.AMS_PUBLIC_ID = T2.PUBLIC_ID, 
	T1.AMS_IVR_ID = T2.AMS_IVR_ID 
FROM (
	SELECT PROFILE_UID AS AMS_IVR_ID ,
		CW.EMPLOYEE_ENTERPRISE_ID,
		CW.AMS_EMPLOYEE_ID, 
		DM.PAYROLL_ID AS public_id
	FROM
	DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW
	JOIN 
	DISC_DEDUPE_${var.SF_ENVIRONMENT}.ALAYACARE.EMPLOYEE_MASTER_LIST EM 
	ON TRIM(CW.AMS_EMPLOYEE_ID) =TRIM(EM.EMPLOYEE_ID)
	JOIN DW_${var.SF_ENVIRONMENT}.INTEGRATION.DIM_EMPLOYEE_MERGED DM 
	ON TRIM(cw.AMS_EMPLOYEE_KEY) =dm.ORIGINAL_EMPLOYEE_KEY 
	WHERE CW.AMS_SYSTEM_CODE IN (''GEORGIA (1002)'',''ALABAMA (3554)'')
	) T2 
WHERE T2.EMPLOYEE_ENTERPRISE_ID = T1.EMPLOYEE_ENTERPRISE_ID;


-----UPDATE OPENSYSTEMS
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK T1
SET T1.AMS_PUBLIC_ID = T2.PUBLIC_ID
FROM (
SELECT
    DISTINCT
    CW.EMPLOYEE_ENTERPRISE_ID,
    CW.AMS_EMPLOYEE_KEY,
    CW.AMS_EMPLOYEE_ID,
    EMP.CAREGIVERID,
    CONCAT(TRIM(BR.OFFICECODE), ''-'',TRIM(EMP.CAREGIVERCODE)) AS PUBLIC_ID
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW   
JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.HHAEXCHANGEOPENSYSTEMS.EMPLOYEE_MASTER_LIST EMP ON
    CW.AMS_EMPLOYEE_ID  = EMP.CAREGIVERID
JOIN DISC_${var.SF_ENVIRONMENT}.HHAEXCHANGEOPENSYSTEMS.OFFICE_OFFICES_REPL BR ON
    EMP.OFFICEID = BR.OFFICEID ::VARCHAR AND EMP.AGENCYID  = BR.AGENCYID
WHERE CW.AMS_SYSTEM_CODE ILIKE ''%OPENSYSTEMS%''--6229
) T2
WHERE T1.EMPLOYEE_ENTERPRISE_ID = T2.EMPLOYEE_ENTERPRISE_ID;


-----UPDATE OSHAH
UPDATE DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK T1
SET T1.AMS_PUBLIC_ID = T2.PUBLIC_ID
FROM (
SELECT
    DISTINCT
    CW.EMPLOYEE_ENTERPRISE_ID,
    CW.AMS_EMPLOYEE_KEY,
    CW.AMS_EMPLOYEE_ID,
    EMP.CAREGIVERID,
    CONCAT(TRIM(BR.OFFICECODE), ''-'',TRIM(EMP.CAREGIVERCODE)) AS PUBLIC_ID
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK CW   
JOIN DISC_DEDUPE_${var.SF_ENVIRONMENT}.HHAEXCHANGEOSHAH.EMPLOYEE_MASTER_LIST EMP ON
    CW.AMS_EMPLOYEE_ID  = EMP.CAREGIVERID
JOIN DISC_${var.SF_ENVIRONMENT}.HHAEXCHANGEOSHAH.OFFICE_OFFICES_REPL BR ON
    EMP.OFFICEID = BR.OFFICEID ::VARCHAR AND EMP.AGENCYID  = BR.AGENCYID
WHERE CW.AMS_SYSTEM_CODE ILIKE ''%OSHAH%''
) T2
WHERE T1.EMPLOYEE_ENTERPRISE_ID = T2.EMPLOYEE_ENTERPRISE_ID;
 


-- *************************************************************************
-- STEP 8 : INSERT CHANGED RECORDS INTO HISTORICAL TABLE 

INSERT INTO DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK_HISTORICAL
SELECT * EXCLUDE (ETL_INSERTED_DATE, ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE, ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, AMS_PUBLIC_ID),
		CURRENT_TIMESTAMP, CURRENT_USER, AMS_PUBLIC_ID 
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK AT (OFFSET => -60*60*24)
EXCEPT 
SELECT * EXCLUDE (ETL_INSERTED_DATE, ETL_TASK_KEY, ETL_INSERTED_TASK_KEY, ETL_INSERTED_BY, ETL_LAST_UPDATED_DATE, ETL_LAST_UPDATED_BY, ETL_DELETED_FLAG, AMS_PUBLIC_ID),
		CURRENT_TIMESTAMP, CURRENT_USER, AMS_PUBLIC_ID 
FROM DW_${var.SF_ENVIRONMENT}.INTEGRATION.EMPLOYEE_CROSS_WALK;

------------------------------------------------
return ''SUCCEED'';
end;

 EOT
}

