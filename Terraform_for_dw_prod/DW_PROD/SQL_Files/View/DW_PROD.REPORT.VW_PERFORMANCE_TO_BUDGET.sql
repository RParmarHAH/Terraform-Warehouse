create or replace view DW_PROD.REPORT.VW_PERFORMANCE_TO_BUDGET(
	BRANCH_KEY,
	SOURCE_SYSTEM_ID,
	REGION_NAME,
	DETAILED_OFFICE_NAME,
	OFFICE_STATE_CODE,
	SERVICELINE,
	OFFICE_NUMBER,
	MONTH,
	ACTUALHOURS,
	ACTUALREVENUE,
	MONTH_DAYFALL,
	MONTHBUDGET_HOURS,
	MONTHBUDGET_REVENUE,
	TOTALDAYSOFMONTHSOFAR,
	TOTALMONTHDAYS,
	PERIOD_END_DATE
) as          
-- determines what dates we have payroll data through for each month
WITH PAYROLLPERIODS
AS
(
SELECT OFFICE_STATE_CODE AS STATE,CAST(MAX(PERIOD_END_DATE) AS DATE) as PERIODEND
FROM INTEGRATION.FACT_BRANCH_PAYROLL_PERIODS_MERGED o       
WHERE CHECK_DATE < Current_Date() -- This should be CheckDate NOT PeriodEnd, it takes a while for all the timesheets to be entered
group by OFFICE_STATE_CODE
)
,
-- pulls all dates with their various attributes needed later on
DIMDATE
AS
(
  select CALENDAR_DATE,FIRST_DAY_OF_MONTH,
  DATEDIFF(day,FIRST_DAY_OF_MONTH,LAST_DAY_OF_MONTH) + 1 AS MONTHDAYS,
  CASE WHEN DATEDIFF(MONTH,CALENDAR_DATE,PERIODEND) = 0 THEN 
  DATEDIFF(day,FIRST_DAY_OF_MONTH,PERIODEND) + 1 ELSE 
  DATEDIFF(day,FIRST_DAY_OF_MONTH,LAST_DAY_OF_MONTH) + 1 END TOTALDAYSOFMONTHSOFAR,
  CASE WHEN DATEDIFF(MONTH,CALENDAR_DATE,PERIODEND) = 0 THEN 
  PERIODEND ELSE LAST_DAY_OF_MONTH END PERIOD_END_DATE,
  STATE,PERIODEND
  FROM
  hah.dim_date
  cross join 
  (select state,PERIODEND from PAYROLLPERIODS) PAYROLLPERIODS
  where CALENDAR_DATE >= '2017-12-01' and CALENDAR_DATE <= PERIODEND -- need to go back to Dec. 2017 because we calculate holiday dayfall on 12 mos
) --SELECT * FROM DIMDATE ORDER BY 1
,
-- pulls the actual hours served by day, revenue category, branch, and state
ACTUALHOURS_DAY
AS
(
select SERVICE_DATE,CONTRACT.REVENUE_CATEGORY,
    --COMBINIG WARRINGTON TO PHILADELPHIA
    CASE WHEN VISIT.ORIGINAL_BRANCH_KEY  = 'd9833aeae3e12be4707fa3a06454704a' THEN 
  '0010d523d5db5f536745453dc9f21c60' ELSE VISIT.ORIGINAL_BRANCH_KEY END AS ORIGINAL_BRANCH_KEY,
--  	CASE WHEN VISIT.SYSTEM_CODE = '8485' THEN 'PA' ELSE VISIT.SYSTEM_CODE END AS STATE,
    BRANCH.OFFICE_STATE_CODE STATE,
    SUM(HOURS_SERVED) AS HOURS,
    SUM(HOURS_SERVED * BILL_RATE) + COALESCE(SUM(OVERHEAD_RATE),0) As REVENUE 
    from INTEGRATION.FACT_VISIT_MERGED VISIT
    inner join 
    (SELECT CONTRACT_KEY, 
     CONTRACT_CODE,contract_name,
     CASE WHEN SOURCE_SYSTEM_ID = 4 THEN 'HC' ELSE REVENUE_CATEGORY END AS REVENUE_CATEGORY,
     CASE WHEN SOURCE_SYSTEM_ID = 4 THEN TRUE ELSE BILLABLE_FLAG END AS BILLABLE_FLAG,
     CASE WHEN CONTRACT_STATE_CODE = 'AL' AND  CONTRACT_CODE = 'Z2' THEN TRUE
          WHEN CONTRACT_STATE_CODE = 'MO' AND CONTRACT_CODE = 'MI' THEN TRUE 
          WHEN SOURCE_SYSTEM_ID = 4 THEN FALSE 
          ELSE MILEAGE_FLAG END AS MILEAGE_FLAG
     FROM HAH.DIM_CONTRACT) CONTRACT 
    	ON CONTRACT.CONTRACT_KEY = VISIT.CONTRACT_KEY
    	AND BILLABLE_FLAG = TRUE and NVL(MILEAGE_FLAG,FALSE) = FALSE
    	AND CONTRACT.CONTRACT_KEY NOT IN 
    (
      select distinct contract_KEY from hah.dim_contract where upper(contract_name) like '%DCFS%' or 
      upper(contract_name) like '%DRUG%' or upper(contract_name) like '%TRANSPORT%'
    )
    INNER JOIN 
    (
      select DISTINCT SOURCE_SYSTEM_ID,BRANCH_KEY,DETAILED_OFFICE_NAME,OFFICE_STATE_CODE,ORIGINAL_BRANCH_KEY,
       CASE WHEN SYSTEM_CODE = '8485' THEN 'PA' ELSE SYSTEM_CODE END as SYSTEM_CODE,OFFICE_NUMBER 
        from INTEGRATION.DIM_BRANCH_MERGED 
    )BRANCH
    ON BRANCH.ORIGINAL_BRANCH_KEY = VISIT.ORIGINAL_BRANCH_KEY
    INNER JOIN PAYROLLPERIODS
    ON SERVICE_DATE >= '2017-12-01' AND SERVICE_DATE <= PayrollPeriods.PeriodEnd -- this should be the end of the period not CURRENT_DATE() 
    AND PAYROLLPERIODS.STATE = BRANCH.OFFICE_STATE_CODE
    WHERE  NVL(VISIT.CONFIRMED_FLAG,'YES') ='YES' --NVL(VISIT.STATUS_CODE, '02') IN ('02', '03', '04', '05')
    GROUP BY SERVICE_DATE,CONTRACT.REVENUE_CATEGORY, CASE WHEN VISIT.ORIGINAL_BRANCH_KEY  = 'd9833aeae3e12be4707fa3a06454704a' THEN 
  '0010d523d5db5f536745453dc9f21c60' ELSE VISIT.ORIGINAL_BRANCH_KEY END,BRANCH.OFFICE_STATE_CODE --,VISIT.SYSTEM_CODE
) --SELECT SUM(HOURS) , SUM(REVENUE) FROM ACTUALHOURS_DAY;
,
-- sets up day types for various dayfall comparisons; holiday vs. weekday, weekend day vs. weekday
DAY_TYPE
AS
(
SELECT CALENDAR_DATE
	,CASE WHEN ((MONTH = 1 AND DAY_OF_MONTH = 1)										-- New Year's Day
			OR (MONTH = 7 AND DAY_OF_MONTH = 4)											-- 4th of July
			OR (MONTH = 12 AND DAY_OF_MONTH = 25)										-- Christmas
			OR (MONTH = 1 AND Day_Name = 'Mon' AND Day_of_Month BETWEEN 15 AND 21)		-- Martin Luther King Jr Day
			OR (MONTH = 5 AND Day_Name = 'Mon' AND Day_of_Month BETWEEN 25 AND 31)		-- Memorial Day
			OR (MONTH = 9 AND Day_Name = 'Mon' AND Day_of_Month BETWEEN 1 AND 7)		-- Labor Day
			OR (MONTH = 11 AND Day_Name = 'Thu' AND Day_of_Month BETWEEN 22 AND 28)		-- Thanksgiving Day
			) THEN 'Holiday'
		WHEN DAY_NAME IN ('Sat','Sun') THEN DAY_NAME -- we treat the weekend days individually
		ELSE 'Weekday' END AS DAY_TYPE -- everything that's not a holiday or weekend day is logically a weekday
FROM HAH.DIM_DATE dd
) --SELECT * FROM DAY_TYPE ORDER BY 1,2
,
-- count of day_type in each month, informs dayfall calculation
MONTHCOUNT
AS
(
SELECT p.*
FROM
	(
	SELECT DATE_TRUNC( 'MONTH',CALENDAR_DATE) AS MONTH, DAY_TYPE, COUNT( CALENDAR_DATE) AS DAYTYPE_COUNT
	FROM DAY_TYPE
	WHERE CALENDAR_DATE BETWEEN '2017-12-01' AND DATEADD(DAY,-1,ADD_MONTHS( (SELECT MAX( CAST( DATE_TRUNC(MONTH,CALENDAR_DATE) AS DATE)) FROM INTEGRATION.FACT_BUDGET_MERGED),1))
	GROUP BY DATE_TRUNC( 'MONTH',CALENDAR_DATE), DAY_TYPE
	) x
PIVOT( AVG( DAYTYPE_COUNT) FOR DAY_TYPE IN ('Weekday','Sat','Sun','Holiday')) AS p -- pivot brings each day type into a column with its own values
) --SELECT * FROM MONTHCOUNT ORDER BY 1 DESC
,
-- weekend day hour totals for comparison with weekday totals of same timeframe
DAYFALL_WEEKEND
AS
(
SELECT *
FROM (
 SELECT ahd.STATE
	,ahd.REVENUE_CATEGORY
	,mc.MONTH
	,dt.DAY_TYPE
	,AVG( ahd.HOURS) AS HOURS
 FROM MONTHCOUNT mc
 INNER JOIN (SELECT SERVICE_DATE, REVENUE_CATEGORY, STATE, SUM( HOURS) AS HOURS, SUM( REVENUE) AS REVENUE
 			 FROM ACTUALHOURS_DAY
 			 GROUP BY 1,2,3
 			) ahd
 ON DATE_TRUNC(MONTH,ahd.SERVICE_DATE) BETWEEN ADD_MONTHS(mc.MONTH,-4) AND ADD_MONTHS(mc.MONTH,-2) -- 3-month rolling average
 INNER JOIN DAY_TYPE dt
 ON ahd.SERVICE_DATE = dt.CALENDAR_DATE
 WHERE dt.DAY_TYPE <> 'Holiday'
 	AND mc.MONTH <= DATE_TRUNC(MONTH,Current_Date())
 GROUP BY 1,2,3,4
 ORDER BY 1,2,3,4
) AS x
PIVOT( AVG( HOURS) FOR DAY_TYPE IN ('Sat','Sun','Weekday')) AS p -- pivot brings each day type into a column with its own values
) --SELECT * FROM DAYFALL_WEEKEND ORDER BY 1,2,3,4
,
-- holiday hour totals for comparison with weekday totals of same timeframe
DAYFALL_HOLIDAY
AS
(
SELECT *
FROM (
 SELECT ahd.STATE
	,ahd.REVENUE_CATEGORY
	,mc.MONTH
	,dt.DAY_TYPE
	,AVG( ahd.HOURS) AS HOURS
 FROM MONTHCOUNT mc
 INNER JOIN (SELECT SERVICE_DATE, REVENUE_CATEGORY, STATE, SUM( HOURS) AS HOURS, SUM( REVENUE) AS REVENUE
 			 FROM ACTUALHOURS_DAY
 			 GROUP BY 1,2,3
 			) ahd
 ON DATE_TRUNC(MONTH,ahd.SERVICE_DATE) BETWEEN ADD_MONTHS(mc.MONTH,-13) AND ADD_MONTHS(mc.MONTH,-2) -- 12-month rolling average
 INNER JOIN DAY_TYPE dt
 ON ahd.SERVICE_DATE = dt.CALENDAR_DATE
 WHERE dt.DAY_TYPE NOT IN ('Sat','Sun')
 	AND mc.MONTH <= DATE_TRUNC(MONTH,Current_Date())
 GROUP BY 1,2,3,4
 ORDER BY 1,2,3,4
) AS x
PIVOT( AVG( HOURS) FOR DAY_TYPE IN ('Holiday','Weekday')) AS p -- pivot brings each day type into a column with its own values
) --SELECT * FROM DAYFALL_HOLIDAY ORDER BY 1,2,3
,
-- calculates what percent of the accompanying weekday value each day type is
DAYFALL_PERCENT_OFWEEKDAY
AS
(
SELECT dw.STATE
	,dw.REVENUE_CATEGORY
	,dw.MONTH
	,CASE WHEN dw."'Weekday'" = 0 THEN 0 ELSE IFNULL(IFNULL(dw."'Sat'",dw."'Sun'"),dh."'Holiday'")/dw."'Weekday'" END AS PERCENT_SATURDAY
	,CASE WHEN dw."'Weekday'" = 0 THEN 0 ELSE IFNULL(IFNULL(dw."'Sun'",dw."'Sat'"),dh."'Holiday'")/dw."'Weekday'" END AS PERCENT_SUNDAY
	,CASE WHEN dw."'Weekday'" = 0 THEN 0 ELSE IFNULL(IFNULL(dh."'Holiday'",dw."'Sun'"),dw."'Sat'")/dh."'Weekday'" END AS PERCENT_HOLIDAY
FROM DAYFALL_WEEKEND dw -- weekend days and weekdays based on 3-month rolling average
INNER JOIN DAYFALL_HOLIDAY dh -- holidays and weekdays based on 12-month rolling average
ON dw.STATE = dh.STATE
	AND dw.REVENUE_CATEGORY = dh.REVENUE_CATEGORY
	AND dw.MONTH = dh.MONTH
WHERE dw.REVENUE_CATEGORY IN ('HH','HC','OTHER')
	AND dw.MONTH >= '2020-01-01'
) --SELECT * FROM DAYFALL_PERCENT_OFWEEKDAY ORDER BY 1,2,3
,
-- calc dayfall at month, revenue category, branch, and state level
DAYFALL_BYMONTH
AS
(
SELECT b.SOURCE_SYSTEM_ID
	,wd.STATE
	,wd.REVENUE_CATEGORY
	,b.OFFICE_NUMBER
	,b.BRANCH_KEY
--	,b.ORIGINAL_BRANCH_KEY
	,b.MONTH
	,REVENUEVALUE AS MONTHBUDGET_REVENUE -- revenue budget month totals for comparison in dashboard
	,b.HOURSVALUE AS MONTHBUDGET_HOURS -- hours budget month totals for comparison in dashboard
	,b.HOURSVALUE/(mc."'Weekday'"+(wd.PERCENT_SATURDAY*mc."'Sat'")+(wd.PERCENT_SUNDAY*mc."'Sun'")+(wd.PERCENT_HOLIDAY*IFNULL(mc."'Holiday'",0))) AS DAYFALL_WEEKDAY -- THE calculation that figures out dayfall
	,DAYFALL_WEEKDAY*wd.PERCENT_SATURDAY AS DAYFALL_SAT
	,DAYFALL_WEEKDAY*wd.PERCENT_SUNDAY AS DAYFALL_SUN
	,DAYFALL_WEEKDAY*wd.PERCENT_HOLIDAY AS DAYFALL_HOLIDAY
FROM DAYFALL_PERCENT_OFWEEKDAY wd
INNER JOIN (
SELECT DISTINCT SOURCE_SYSTEM_ID, STATE_CODE, SERVICE_LINE_CODE, OFFICE_NUMBER, BRANCH_KEY
				,CAST( DATE_TRUNC(MONTH,CALENDAR_DATE) AS DATE) AS MONTH
				,CAST( HOURS_BUDGETED_MONTHLY AS DECIMAL (15,3)) AS HOURSVALUE
				,CAST( REVENUE_BUDGETED_MONTHLY AS DECIMAL (15,3)) AS REVENUEVALUE
			FROM INTEGRATION.FACT_BUDGET_MERGED
			WHERE SERVICE_LINE_CODE IN ('HH','HC')
--			SELECT DISTINCT SOURCE_SYSTEM_ID, STATE_CODE, SERVICE_LINE_CODE, OFFICE_NUMBER, BRANCH_KEY
--			,FIRST_VALUE(ORIGINAL_BRANCH_KEY) OVER (PARTITION BY BRANCH_KEY ORDER BY IFF(BRANCH_KEY <> ORIGINAL_BRANCH_KEY,0,1)) AS ORIGINAL_BRANCH_KEY
--				,CAST( DATE_TRUNC(MONTH,CALENDAR_DATE) AS DATE) AS MONTH
--				,SUM(SUM(CAST(HOURS_BUDGETED_MONTHLY AS DECIMAL (15,3)))) OVER (PARTITION BY BRANCH_KEY, SOURCE_SYSTEM_ID, STATE_CODE, SERVICE_LINE_CODE, OFFICE_NUMBER ,CAST( DATE_TRUNC(MONTH,CALENDAR_DATE) AS DATE)) AS HOURSVALUE
--				,SUM(SUM(CAST( REVENUE_BUDGETED_MONTHLY AS DECIMAL (15,3)))) OVER (PARTITION BY BRANCH_KEY, SOURCE_SYSTEM_ID, STATE_CODE, SERVICE_LINE_CODE, OFFICE_NUMBER ,CAST( DATE_TRUNC(MONTH,CALENDAR_DATE) AS DATE))  AS REVENUEVALUE
--			FROM HAH.VW_FACT_BUDGET_MERGED 
--			WHERE SERVICE_LINE_CODE IN ('HH','HC')
--			GROUP BY SOURCE_SYSTEM_ID, STATE_CODE, SERVICE_LINE_CODE, OFFICE_NUMBER, BRANCH_KEY, ORIGINAL_BRANCH_KEY,CAST( DATE_TRUNC(MONTH,CALENDAR_DATE) AS DATE)
			) b -- rolling up day-level budget in FACT_BUDGET to be at month-level
ON 
wd.STATE = b.STATE_CODE
AND
	wd.REVENUE_CATEGORY = b.SERVICE_LINE_CODE
	AND wd.MONTH = b.MONTH
INNER JOIN MONTHCOUNT mc
ON b.MONTH = mc.MONTH
) --SELECT DISTINCT STATE, SUM(MONTHBUDGET_REVENUE), SUM(MONTHBUDGET_HOURS) FROM DAYFALL_BYMONTH GROUP BY STATE ;
,
-- applies dayfall amount for each day and what the month dayfall amount should be for that day within the month
DAYFALL_BYDAY
AS
(
SELECT dm.SOURCE_SYSTEM_ID, dm.STATE, dm.REVENUE_CATEGORY, dm.OFFICE_NUMBER, dm.BRANCH_KEY
--, dm.ORIGINAL_BRANCH_KEY
, dm.MONTH
	,dt.CALENDAR_DATE, dt.DAY_TYPE
	,CASE WHEN dt.DAY_TYPE = 'Weekday' THEN dm.DAYFALL_WEEKDAY
		WHEN dt.DAY_TYPE = 'Sat' THEN dm.DAYFALL_SAT
		WHEN dt.DAY_TYPE = 'Sun' THEN dm.DAYFALL_SUN
		WHEN dt.DAY_TYPE = 'Holiday' THEN dm.DAYFALL_HOLIDAY
		ELSE NULL END AS DAYFALL_AMT -- parcels out which dayfall amount should be used for which day
	,SUM(DAYFALL_AMT) OVER( PARTITION BY dm.SOURCE_SYSTEM_ID, dm.STATE, dm.REVENUE_CATEGORY, dm.OFFICE_NUMBER, dm.BRANCH_KEY, dm.MONTH
							ORDER BY dt.CALENDAR_DATE -- applied at state, branch, office, revenue category, and month level
							ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS MONTH_DAYFALL -- how many hours budgeted by this point in the month
	,dd.TOTALDAYSOFMONTHSOFAR -- for display use in dashboard
    ,dd.MonthDays
    ,dd.PERIOD_END_DATE
	,dm.MONTHBUDGET_HOURS -- for use in dashboard to compare budget to projection
	,dm.MONTHBUDGET_REVENUE -- for use in dashboard to compare budget to projection
FROM DAYFALL_BYMONTH dm
INNER JOIN DAY_TYPE dt
ON dm.MONTH = DATE_TRUNC( MONTH,dt.CALENDAR_DATE)
INNER JOIN DIMDATE dd
ON dt.CALENDAR_DATE = dd.CALENDAR_DATE
	AND dm.STATE = dd.STATE
) --SELECT * FROM DAYFALL_BYDAY ORDER BY 1,2,3,4,5,6;
,
-- grabs the record that represents the month to this point (for all completed months, will be last day of month)
DAYFALL_MONTHRECORD
AS
(
SELECT SOURCE_SYSTEM_ID, STATE, OFFICE_NUMBER, BRANCH_KEY
--,ORIGINAL_BRANCH_KEY
, REVENUE_CATEGORY,
	MONTH, CALENDAR_DATE, MONTH_DAYFALL, TOTALDAYSOFMONTHSOFAR,PERIOD_END_DATE, MONTHBUDGET_HOURS, MONTHBUDGET_REVENUE,MONTHDAYS
FROM (SELECT dfbd.SOURCE_SYSTEM_ID, dfbd.STATE, dfbd.OFFICE_NUMBER, dfbd.BRANCH_KEY
--	,dfbd.ORIGINAL_BRANCH_KEY
	, dfbd.REVENUE_CATEGORY, dfbd.MONTH, dfbd.CALENDAR_DATE
		,dfbd.MONTH_DAYFALL, dfbd.TOTALDAYSOFMONTHSOFAR,dfbd.PERIOD_END_DATE, dfbd.MONTHBUDGET_HOURS, dfbd.MONTHBUDGET_REVENUE,
         dfbd.MonthDays
		,RANK() OVER( PARTITION BY dfbd.SOURCE_SYSTEM_ID, dfbd.STATE, dfbd.REVENUE_CATEGORY, dfbd.OFFICE_NUMBER, dfbd.MONTH
						ORDER BY CAST( dfbd.CALENDAR_DATE AS date) DESC) rownum
	  FROM DAYFALL_BYDAY dfbd
	  INNER JOIN PAYROLLPERIODS pp
	  ON dfbd.STATE = pp.STATE
	  	AND dfbd.CALENDAR_DATE <= pp.PERIODEND
	  ) x
WHERE rownum = 1
) --SELECT DISTINCT STATE FROM DAYFALL_MONTHRECORD WHERE  ORIGINAL_BRANCH_KEY = '0dd56328a3f49f1a172bc1fa4ce1802d';
,
-- rolling up actual day hours by month
ACTUALHOURS_MONTH
AS
(
SELECT 
		STATE, 
		ORIGINAL_BRANCH_KEY,
		REVENUE_CATEGORY,
	  DATE_TRUNC( MONTH,CAST( SERVICE_DATE AS DATE)) AS MONTH,
	  SUM( HOURS) AS ACTUALHOURS,
      SUM(REVENUE) AS ACTUALREVENUE
FROM ACTUALHOURS_DAY ahd
WHERE SERVICE_DATE >= '2020-01-01'
GROUP BY 1,2,3,4
) --SELECT DISTINCT state FROM ACTUALHOURS_MONTH WHERE ORIGINAL_BRANCH_KEY = '0dd56328a3f49f1a172bc1fa4ce1802d';
,
-- brings together the budgeted hours with dayfall and the actual hours--all at the month level
BUDGET
AS
(
SELECT BRANCH.BRANCH_KEY ,BRANCH.SOURCE_SYSTEM_ID, BRANCH.REGION_NAME, BRANCH.DETAILED_OFFICE_NAME, BRANCH.OFFICE_STATE_CODE, dmr.REVENUE_CATEGORY AS SERVICELINE, dmr.OFFICE_NUMBER
	,dmr.MONTH
	,ahm.ACTUALHOURS
    ,ahm.ACTUALREVENUE
	,dmr.MONTH_DAYFALL
	,dmr.MONTHBUDGET_HOURS
	,dmr.MONTHBUDGET_REVENUE
	,dmr.TOTALDAYSOFMONTHSOFAR
    ,dmr.MONTHDAYS as tOTALMONTHDAYS
    ,DMR.PERIOD_END_DATE
FROM DAYFALL_MONTHRECORD dmr
  JOIN (select DISTINCT SOURCE_SYSTEM_ID,BRANCH_KEY,DETAILED_OFFICE_NAME,OFFICE_STATE_CODE,ORIGINAL_BRANCH_KEY,
		    CASE WHEN SYSTEM_CODE = '8485' THEN 'PA' ELSE SYSTEM_CODE END as SYSTEM_CODE, OFFICE_NUMBER,
		    REGION_NAME
		    from INTEGRATION.DIM_BRANCH_MERGED) BRANCH
ON dmr.BRANCH_KEY = BRANCH.ORIGINAL_BRANCH_KEY 
LEFT JOIN ACTUALHOURS_MONTH ahm
ON dmr.BRANCH_KEY = ahm.ORIGINAL_BRANCH_KEY
--	AND dmr.STATE = ahm.STATE
	AND dmr.REVENUE_CATEGORY = ahm.REVENUE_CATEGORY
	AND dmr.MONTH = ahm.MONTH 
--WHERE OFFICE_STATE_CODE NOT IN ('SC','GA')
) 
SELECT 
BRANCH_KEY,SOURCE_SYSTEM_ID,REGION_NAME,DETAILED_OFFICE_NAME,OFFICE_STATE_CODE,SERVICELINE,OFFICE_NUMBER
,MONTH,ACTUALHOURS,ACTUALREVENUE,MONTH_DAYFALL,MONTHBUDGET_HOURS,MONTHBUDGET_REVENUE,TOTALDAYSOFMONTHSOFAR,tOTALMONTHDAYS,PERIOD_END_DATE
FROM BUDGET;