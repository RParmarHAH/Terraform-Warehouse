CREATE OR REPLACE PROCEDURE DW_PROD.INTEGRATION.DIM_BRANCH_MERGED_POSTPROCESSING("STR_ETL_TASK_KEY" VARCHAR(16777216), "STR_CDC_START" VARCHAR(16777216), "STR_CDC_END" VARCHAR(16777216))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    return_result VARCHAR;
BEGIN

INSERT OVERWRITE INTO DW_PROD.INTEGRATION.DIM_BRANCH_MERGED
WITH FINAL AS (
	SELECT * 
	FROM HAH.FACT_BRANCH_MAPPING 
	WHERE CONSOLIDATE_DATE <= CURRENT_DATE
), UPDATE_OLD_KEY AS (
	-- UPDATE NEW_BRANCH_KEY IN CASE IF OLD BRANCH IS CONSOLIDATED INTO NEW BRANCH/ANOTHER BRANCH
	-- For Instance if A is consolidated into B and later if A changes to C then A will be treated as C
	SELECT DISTINCT A.*
	FROM FINAL A 
	JOIN FINAL B ON A.OLD_SYSTEM_BRANCH_KEY = B.OLD_SYSTEM_BRANCH_KEY
	AND A.LAYER = (SELECT MAX(LAYER) FROM FINAL WHERE OLD_SYSTEM_BRANCH_KEY = A.OLD_SYSTEM_BRANCH_KEY )
), RESULT AS (
	-- UPDATE NEW_BRANCH_KEY IN CASE IF NEW BRANCH IS CONSOLIDATED TO ANOTHER BRANCH
	-- For Instance if A is treated as B and later B gets consolidate into C then A will be treated as C
	SELECT A.OLD_SYSTEM_BRANCH_KEY , 
	CASE WHEN A.IS_HISTORY THEN A.NEW_SYSTEM_BRANCH_KEY ELSE COALESCE(B.NEW_SYSTEM_BRANCH_KEY,A.NEW_SYSTEM_BRANCH_KEY) END  AS NEW_SYSTEM_BRANCH_KEY,
CASE WHEN A.IS_HISTORY THEN A.CONSOLIDATE_DATE ELSE COALESCE(B.CONSOLIDATE_DATE, A.CONSOLIDATE_DATE) END AS CONSOLIDATE_DATE,
CASE WHEN A.IS_HISTORY THEN A.LAYER ELSE COALESCE(B.LAYER, A.LAYER) END AS LAYER
	FROM UPDATE_OLD_KEY A 
	LEFT JOIN UPDATE_OLD_KEY B ON A.NEW_SYSTEM_BRANCH_KEY = B.OLD_SYSTEM_BRANCH_KEY
)
SELECT 
		A.BRANCH_KEY  AS ORIGINAL_BRANCH_KEY,
		A.BRANCH_NAME AS ORIGINAL_BRANCH_NAME,
		A.SOURCE_SYSTEM_ID AS ORIGINAL_SOURCE_SYSTEM_ID,
		A.SYSTEM_CODE AS ORIGINAL_SYSTEM_CODE,
		A.OFFICE_CODE  AS ORIGINAL_OFFICE_CODE,
		C.BRANCH_KEY,
		C.BRANCH_NAME,
		C.SYSTEM_CODE,
		C.SOURCE_SYSTEM_ID,
		C.SOURCE_SYSTEM_TYPE,
		C.OFFICE_NUMBER,
		C.OFFICE_CODE,
		C.OFFICE_NAME,
		C.OFFICE_NAME_ALT,
		C.DEPARTMENT_NAME,
		C.BRANCH_SERVICE_LINE,
		C.PARENT_FLAG,
		C.PARENT_BRANCH_KEY,
		C.PARENT_OFFICE_NUMBER,
		C.PARENT_OFFICE_CODE,
		C.PARENT_BRANCH_NAME,
		C.OFFICE_ADDRESS1,
		C.OFFICE_ADDRESS2,
		C.OFFICE_CITY,
		C.OFFICE_STATE_CODE,
		C.OFFICE_ZIP,
		C.OFFICE_PHONE,
		C.OFFICE_TOLL_FREE_PHONE,
		C.OFFICE_FAX,
		C.DETAILED_OFFICE_NAME,
		C.REGION_NUMBER,
		COALESCE(D.REGION_NAME,''OTHER'') AS REGION_NAME,
		C.REGION_MANAGER,
		C.REGION_MANAGER_EMPLOYEE_KEY,
		C.SUBREGION_NAME,
		C.PRIMARY_BRANCH_MANAGER_NAME,
		C.PRIMARY_BRANCH_EMAIL,
		C.PRIMARY_BRANCH_MANAGER_EMPLOYEE_KEY,
		C.SECONDARY_BRANCH_MANAGER_NAME,
		C.SECONDARY_BRANCH_EMAIL,
		C.SECONDARY_BRANCH_MANAGER_EMPLOYEE_KEY,
		C.RISKCONNECT_NODE_KEY,
		C.RISKCONNECT_NAME,
		C.HR_OFFICE_NUMBER,
		C.HR_OFFICE_NAME,
		C.ACTIVE_FLAG,
		C.EFFECTIVE_FROM_DATE,
		C.EFFECTIVE_TO_DATE,
		C.ETL_TASK_KEY,
		C.ETL_INSERTED_TASK_KEY,
		C.ETL_INSERTED_DATE,
		C.ETL_INSERTED_BY,
		C.ETL_LAST_UPDATED_DATE,
		C.ETL_LAST_UPDATED_BY,
		C.ETL_DELETED_FLAG,
		C.ETL_INFERRED_MEMBER_FLAG,
		SUBSTRING(REGEXP_replace(REGEXP_REPLACE(C.PARENT_BRANCH_NAME,''\\\\(([^)]*)\\\\)'',''''),'' - '',''#'',1,1),POSITION( ''#'' IN REGEXP_replace(REGEXP_REPLACE(C.PARENT_BRANCH_NAME, ''\\\\(([^)]*)\\\\)'', ''''),'' - '', ''#'', 1, 1))+1 ) AS PARENT_BRANCH_NAME_SHORTENED,
		CASE WHEN A.BRANCH_KEY = C.BRANCH_KEY THEN FALSE ELSE TRUE END AS CONSOLIDATE_FLAG,
		B.CONSOLIDATE_DATE
FROM HAH.DIM_BRANCH A
LEFT JOIN RESULT B 
ON A.BRANCH_KEY = B.OLD_SYSTEM_BRANCH_key
LEFT JOIN HAH.DIM_BRANCH  C ON C.BRANCH_KEY = COALESCE(B.new_system_branch_key, A.BRANCH_KEY)
LEFT JOIN HAH.DIM_BRANCH_REGION_MAPPING D ON D.BRANCH_KEY = C.BRANCH_KEY
WHERE A.SOURCE_SYSTEM_ID NOT IN (''15'');

SELECT CONCAT(''Message : '',"number of rows inserted",'' Rows Inserted.'') into :return_result FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

return return_result;
END;

';